[{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":null,"dir":"","previous_headings":"","what":"Bug Fixes in C++ Source Code","title":"Bug Fixes in C++ Source Code","text":"document records bugs found C++ source files inherited degpd--zidegpd prototype (fork evgam v1.0.1) fixed egpd package.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"id_1-gradhesscpp348--incorrect-hessian-symmetry-indices-in-gh6","dir":"","previous_headings":"Fixed Bugs","what":"1. gradHess.cpp:348 – Incorrect Hessian symmetry indices in .gH6","title":"Bug Fixes in C++ Source Code","text":"Severity: High Affects: 6-parameter models (ZIDEGPD models 2 4 smooth terms) .gH6 function computes gradient Hessian 6-parameter models. computing lower-triangle blocks (5,4) (6,4), code transpose block (6,4) fill symmetric block (4,6). Instead, wrote wrong block (5,6) read wrong column boundaries. left (4,6) block Hessian uninitialized, producing incorrect second-derivative information REML smoothing parameter estimation 6-parameter models.","code":"// BEFORE (buggy): H.submat(s5, s6, e5, e6) = H.submat(s6, s4, e6, e5).t();  // AFTER (fixed): H.submat(s4, s6, e4, e6) = H.submat(s6, s4, e6, e4).t();"},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"id_2-degpdcpp372--wrong-design-matrix-in-degpd2d12","dir":"","previous_headings":"Fixed Bugs","what":"2. degpd.cpp:372 – Wrong design matrix in degpd2d12","title":"Bug Fixes in C++ Source Code","text":"Severity: High Affects: DEGPD model 2 (mixture model) derivative computation degpd2d12 function (first second derivatives DEGPD model 2) used design matrix X4 (lkappa2) instead X5 (logitp) computing mixture proportion linear predictor. corresponding degpd2d0 function correctly used X5. produced silently wrong gradients Hessians DEGPD model 2 whenever X4 X5 differed (e.g., different covariate structures kappa2 p), causing optimizer converge incorrect parameter estimates.","code":"// BEFORE (buggy): arma::vec logitpvec = X4 * Rcpp::as<arma::vec>(pars[4]);  // AFTER (fixed): arma::vec logitpvec = X5 * Rcpp::as<arma::vec>(pars[4]);"},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"id_3-zi_degpdcpp380458--wrong-design-matrix-in-zidegpd2d0-and-zidegpd2d12","dir":"","previous_headings":"Fixed Bugs","what":"3. zi_degpd.cpp:380,458 – Wrong design matrix in zidegpd2d0 and zidegpd2d12","title":"Bug Fixes in C++ Source Code","text":"Severity: High Affects: ZIDEGPD model 2 (mixture model zero-inflation) – likelihood derivative computation zidegpd2d0 zidegpd2d12 used design matrix X5 (logitp) instead X6 (logitpi) computing zero-inflation probability. function signatures correctly accepted X6 parameter, pars[5] correct coefficient vector, multiplied wrong design matrix. class --one design matrix error Bug #2, affecting likelihood evaluation derivatives. X5 X6 happened identical (e.g., intercept-), bug masked.","code":"// BEFORE (buggy, in both zidegpd2d0 and zidegpd2d12): arma::vec logitpivec = X5 * Rcpp::as<arma::vec>(pars[5]);  // AFTER (fixed): arma::vec logitpivec = X6 * Rcpp::as<arma::vec>(pars[5]);"},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"id_4-zi_degpdcpp1664--0e5-typo-in-zidegpd4d12-should-be-05","dir":"","previous_headings":"Fixed Bugs","what":"4. zi_degpd.cpp:1664 – 0e5 typo in zidegpd4d12 (should be 0.5)","title":"Bug Fixes in C++ Source Code","text":"Severity: High Affects: ZIDEGPD model 4 second derivatives (lsigma, lsigma) y > 0 zidegpd4d12 function, (lsigma, lsigma) second derivative contained 0e5 instead 0.5. literal 0e5 valid C++ parses 0.0 * 10^5 = 0.0, silently zeroing entire second term expression. corresponding expression degpd4d12 (degpd.cpp:1384) correctly uses 0.5. bug caused incorrect Hessian values ZIDEGPD model 4, affecting optimizer convergence standard error estimates.","code":"// BEFORE (buggy): ... * R_pow(ee5,2)) - 0e5 *  // AFTER (fixed): ... * R_pow(ee5,2)) - 0.5 *"},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"id_5-familiesr--incorrect-type-attribute-for-models-2-3-and-4","dir":"","previous_headings":"Fixed Bugs","what":"5. families.R – Incorrect type attribute for models 2, 3, and 4","title":"Bug Fixes in C++ Source Code","text":"Severity: Low (latent) Affects: families (EGPD, DEGPD, ZIDEGPD) models 2, 3, 4 attr(family, \"type\") value set .setup.family.egpd() used fitting model number (2, 3, 4) instead distribution type number expected p.G/q.G/r.G functions distributions.R. distribution type numbering follows original degpd_functions.R prototype: bug latent predict.R calls iG inverse functions directly likelihood function list rather dispatching via q.G(..., type=...). runtime use type attribute setup_and_fit.R set initial values model 2; check also updated type == 2 type == 6.","code":"# BEFORE (families.R, model 2/3/4 for each family): attr(family, \"type\") <- 2  # model 2 attr(family, \"type\") <- 3  # model 3 attr(family, \"type\") <- 4  # model 4  # AFTER (fixed): attr(family, \"type\") <- 6  # model 2 attr(family, \"type\") <- 4  # model 3 attr(family, \"type\") <- 5  # model 4"},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"id_6-model-2-label-switching-via-reparameterization","dir":"","previous_headings":"Fixed Bugs","what":"6. Model 2 label switching via reparameterization","title":"Bug Fixes in C++ Source Code","text":"Severity: High Affects: model 2 variants (EGPD-2, DEGPD-2, ZIDEGPD-2) mixture transformation G(u) = pu^kappa1 + (1-p)u^kappa2 invariant swapping (kappa1, p) (kappa2, 1-p), causing label switching: optimizer can converge either mode, producing bimodal parameter estimates poor inference. Simulation tests showed 34% usable fits EGPD-2. Fix: Reparameterized (lkappa1, lkappa2) (lkappa1, ldkappa) ldkappa = log(kappa2 - kappa1), enforcing kappa2 > kappa1 breaking symmetry. C++ d0 functions compute lkappa2 = log(kappa1 + exp(ldkappa)) via numerically stable log-sum-exp. d12 derivative functions apply chain rule transformation end observation convert derivatives old parameterization new one. Files modified: egpd.cpp, degpd.cpp, zi_degpd.cpp, families.R, setup_and_fit.R, predict.R.","code":""},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"id_7-distributionsr--wrong-type-in-qg-for-type-6","dir":"","previous_headings":"Fixed Bugs","what":"7. distributions.R – Wrong type in q.G for type 6","title":"Bug Fixes in C++ Source Code","text":"Severity: Medium Affects: q.G(..., type=6) inverse transformation mixture model root-finding function inside q.G type 6 called p.G(..., type=4) instead p.G(..., type=6), meaning inverted wrong transformation. affected qegpd, qdiscegpd, qzidiscegpd called type=6.","code":"# BEFORE (buggy): p.G(u = u, prob = prob, kappa = kappa, delta = delta, type = 4)  # AFTER (fixed): p.G(u = u, prob = prob, kappa = kappa, delta = delta, type = 6)"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"egpdcpp--no-handling-of-xi--0","dir":"","previous_headings":"Known Limitations (Not Fixed)","what":"egpd.cpp – No handling of xi = 0","title":"Bug Fixes in C++ Source Code","text":"EGPD likelihood functions compute 1/xi without checking xi = 0. xi = 0, GPD reduces exponential distribution requires separate limiting form. unused constant const double xieps = 0.0 line 5 egpd.cpp (degpd.cpp, zi_degpd.cpp) suggests planned never implemented. practice, shape parameter rarely lands exactly zero optimization, extreme parameter values trigger Inf/NaN.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"bamlss--xbin_fun-declared-as-void-causes-converting-null-pointer-to-r-null-warnings","dir":"","previous_headings":"External Bugs","what":"bamlss – xbin_fun declared as void causes “converting NULL pointer to R NULL” warnings","title":"Bug Fixes in C++ Source Code","text":"Package: bamlss (v1.2-5) File: src/bamlss_functions.c:341 C function xbin_fun declared void registered bamlss_init.c returning SEXP called via .Call() R/optimizers.R:2086. .Call() interface expects C functions return SEXP value. Since xbin_fun modifies xweights xrres arguments -place return statement, .Call() receives whatever happens return register – typically null pointer. R >= 4.4 emits warning call: Since xbin_fun called per parameter per backfitting iteration, intercept-models 3 parameters 100 iterations produce ~300 warnings per bamlss() call. Fix: Change signature void xbin_fun(...) SEXP xbin_fun(...) add return R_NilValue; closing brace. init file already declares correct SEXP return type. Workaround: Suppress warnings calling bamlss():","code":"Warning in .Call(\"xbin_fun\", ...) : converting NULL pointer to R NULL fit <- suppressWarnings(bamlss(..., verbose = FALSE))"},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"all-files--missing-boundary-checks-in-derivative-functions","dir":"","previous_headings":"External Bugs","what":"All files – Missing boundary checks in derivative functions","title":"Bug Fixes in C++ Source Code","text":"d0 (negative log-likelihood) functions degpd.cpp include basic boundary checks (e.g., (e3 <= 0) { nllh = 1e20; break; }), corresponding d12 (derivative) d34 (higher derivative) functions . optimizer explores regions GPD support condition violated, derivative functions may produce NaN values. practice, d0 function returns large penalty value steers optimizer away derivatives used.","code":""},{"path":"https://sdwfrost.github.io/egpd/BUGS.html","id":"egpdcpp--dead-code-in-egpd2d34-and-egpd4d34","dir":"","previous_headings":"External Bugs","what":"egpd.cpp – Dead code in egpd2d34 and egpd4d34","title":"Bug Fixes in C++ Source Code","text":"third/fourth derivative functions EGPD models 2 4 (~2300 lines) compiled never called R – likelihood wrapper sets d340=NULL models.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"continuous-egpd-model-1","dir":"Articles","previous_headings":"","what":"Continuous EGPD Model 1","title":"Comparing egpd and bamlss Fits","text":"simulate continuous EGPD G(u) = u^kappa fit using egpd() (penalised likelihood via GAM) bamlss() (backfitting egpd_bamlss() family).","code":"library(egpd) library(bamlss) #> Loading required package: coda #> Loading required package: colorspace #> Loading required package: distributions3 #>  #> Attaching package: 'distributions3' #> The following object is masked from 'package:stats': #>  #>     Gamma #> The following object is masked from 'package:grDevices': #>  #>     pdf #> Loading required package: mgcv #> Loading required package: nlme #> This is mgcv 1.9-3. For overview type 'help(\"mgcv-package\")'. #> - #> For citation info, use citation(\"bamlss\") and see http://www.bamlss.org/. #>  #> Attaching package: 'bamlss' #> The following object is masked from 'package:mgcv': #>  #>     smooth.construct  set.seed(42) sigma_true <- 2 xi_true    <- 0.2 kappa_true <- 1.5 n <- 2000  y <- regpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y, x = rep(1, n))"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"egpd-fit","dir":"Articles","previous_headings":"Continuous EGPD Model 1","what":"egpd fit","title":"Comparing egpd and bamlss Fits","text":"","code":"fit_egpd <- egpd(list(lpsi = y ~ 1, xi = ~ 1, lkappa = ~ 1),                  data = df, family = \"egpd\", egpd.args = list(m = 1)) pars_egpd <- predict(fit_egpd, type = \"response\")[1, ]"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"bamlss-fit","dir":"Articles","previous_headings":"Continuous EGPD Model 1","what":"bamlss fit","title":"Comparing egpd and bamlss Fits","text":"","code":"fit_bamlss <- bamlss(list(y ~ 1, ~ 1, ~ 1),                      data = df, family = egpd_bamlss(m = 1),                      verbose = FALSE)"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"comparison","dir":"Articles","previous_headings":"Continuous EGPD Model 1","what":"Comparison","title":"Comparing egpd and bamlss Fits","text":"approaches recover similar parameter estimates.","code":"sigma_b <- exp(fit_bamlss$parameters$sigma$p) xi_b    <- exp(fit_bamlss$parameters$xi$p) kappa_b <- exp(fit_bamlss$parameters$kappa$p)  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\"),   true      = c(sigma_true, xi_true, kappa_true),   egpd      = round(as.numeric(unlist(pars_egpd)), 4),   bamlss    = round(c(sigma_b, xi_b, kappa_b), 4),   row.names = NULL ) #>   parameter true   egpd bamlss #> 1     sigma  2.0 2.0957 2.0949 #> 2        xi  0.2 0.1933 0.1934 #> 3     kappa  1.5 1.3904 1.3907"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"continuous-egpd-with-smooth-covariate","dir":"Articles","previous_headings":"","what":"Continuous EGPD with smooth covariate","title":"Comparing egpd and bamlss Fits","text":"real advantage frameworks ability model parameters smooth functions covariates. scale varies covariate. Compare recovered scale functions:","code":"set.seed(7) n <- 2000 x <- runif(n, 0, 1) sigma_x <- exp(0.5 + 1.5 * sin(2 * pi * x)) xi_true  <- 0.1 kappa_true <- 1.5  y <- regpd(n, sigma = sigma_x, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y, x = x) fit_egpd_s <- egpd(list(lpsi = y ~ s(x, k = 15), xi = ~ 1, lkappa = ~ 1),                    data = df, family = \"egpd\", egpd.args = list(m = 1)) fit_bamlss_s <- bamlss(list(y ~ s(x, k = 15), ~ 1, ~ 1),                        data = df, family = egpd_bamlss(m = 1),                        verbose = FALSE) xgrid <- data.frame(x = seq(0, 1, length = 200)) pred_egpd <- predict(fit_egpd_s, newdata = xgrid, type = \"response\")  pred_bamlss <- predict(fit_bamlss_s, newdata = xgrid, type = \"parameter\")  plot(xgrid$x, exp(0.5 + 1.5 * sin(2 * pi * xgrid$x)), type = \"l\",      lwd = 2, col = \"black\", ylim = c(0, 15),      xlab = \"x\", ylab = expression(sigma(x)),      main = \"Smooth scale recovery: egpd vs bamlss\") lines(xgrid$x, pred_egpd$scale, col = \"steelblue\", lwd = 2, lty = 2) lines(xgrid$x, pred_bamlss$sigma, col = \"firebrick\", lwd = 2, lty = 3) legend(\"topright\", legend = c(\"True\", \"egpd\", \"bamlss\"),        col = c(\"black\", \"steelblue\", \"firebrick\"), lwd = 2, lty = 1:3)"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"zero-inflated-continuous-egpd","dir":"Articles","previous_headings":"","what":"Zero-inflated continuous EGPD","title":"Comparing egpd and bamlss Fits","text":"ziegpd_bamlss() family supports zero-inflated continuous EGPD models, useful data excess zeros precipitation. bamlss fit recovers four parameters, including zero-inflation probability.","code":"set.seed(123) sigma_true <- 2 xi_true    <- 0.2 kappa_true <- 1.5 pi_true    <- 0.3 n <- 2000  y <- rziegpd(n, pi = pi_true, sigma = sigma_true, xi = xi_true,              kappa = kappa_true, type = 1) df <- data.frame(y = y) cat(\"Proportion of zeros:\", mean(y == 0), \"\\n\") #> Proportion of zeros: 0.296 fit_zi <- bamlss(list(y ~ 1, ~ 1, ~ 1, ~ 1),                  data = df, family = ziegpd_bamlss(m = 1),                  verbose = FALSE) sigma_zb <- exp(fit_zi$parameters$sigma$p) xi_zb    <- exp(fit_zi$parameters$xi$p) kappa_zb <- exp(fit_zi$parameters$kappa$p) pi_zb    <- 1 / (1 + exp(-fit_zi$parameters$pi$p))  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\", \"pi\"),   true      = c(sigma_true, xi_true, kappa_true, pi_true),   bamlss    = round(c(sigma_zb, xi_zb, kappa_zb, pi_zb), 4),   row.names = NULL ) #>   parameter true bamlss #> 1     sigma  2.0 1.9946 #> 2        xi  0.2 0.2015 #> 3     kappa  1.5 1.4613 #> 4        pi  0.3 0.2960"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"discrete-egpd-degpd-model-1","dir":"Articles","previous_headings":"","what":"Discrete EGPD (DEGPD) Model 1","title":"Comparing egpd and bamlss Fits","text":"degpd_bamlss() family allows fitting discrete EGPD models via bamlss. compare egpd() (penalised likelihood) bamlss() simulated count data.","code":"set.seed(99) sigma_true <- 3 xi_true    <- 0.15 kappa_true <- 2 n <- 2000  y <- rdiscegpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y) cat(\"Range of y:\", range(y), \"\\n\") #> Range of y: 0 147"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"egpd-fit-1","dir":"Articles","previous_headings":"Discrete EGPD (DEGPD) Model 1","what":"egpd fit","title":"Comparing egpd and bamlss Fits","text":"","code":"fit_degpd <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                   data = df, family = \"degpd\", degpd.args = list(m = 1)) pars_degpd <- predict(fit_degpd, type = \"response\")[1, ]"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"bamlss-fit-1","dir":"Articles","previous_headings":"Discrete EGPD (DEGPD) Model 1","what":"bamlss fit","title":"Comparing egpd and bamlss Fits","text":"","code":"fit_degpd_b <- bamlss(list(y ~ 1, ~ 1, ~ 1),                       data = df, family = degpd_bamlss(m = 1),                       verbose = FALSE)"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"comparison-1","dir":"Articles","previous_headings":"Discrete EGPD (DEGPD) Model 1","what":"Comparison","title":"Comparing egpd and bamlss Fits","text":"approaches recover similar estimates discrete model.","code":"sigma_db <- exp(fit_degpd_b$parameters$sigma$p) xi_db    <- exp(fit_degpd_b$parameters$xi$p) kappa_db <- exp(fit_degpd_b$parameters$kappa$p)  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\"),   true      = c(sigma_true, xi_true, kappa_true),   egpd      = round(as.numeric(unlist(pars_degpd)), 4),   bamlss    = round(c(sigma_db, xi_db, kappa_db), 4),   row.names = NULL ) #>   parameter true   egpd bamlss #> 1     sigma 3.00 2.7332 2.7301 #> 2        xi 0.15 0.1974 0.1977 #> 3     kappa 2.00 2.1228 2.1248"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"zero-inflated-discrete-egpd-zidegpd-model-1","dir":"Articles","previous_headings":"","what":"Zero-inflated discrete EGPD (ZIDEGPD) Model 1","title":"Comparing egpd and bamlss Fits","text":"zidegpd_bamlss() family supports zero-inflated discrete EGPD models.","code":"set.seed(77) sigma_true <- 3 xi_true    <- 0.15 kappa_true <- 2 pi_true    <- 0.25 n <- 2000  y <- rzidiscegpd(n, pi = pi_true, sigma = sigma_true, xi = xi_true,                  kappa = kappa_true, type = 1) df <- data.frame(y = y) cat(\"Proportion of zeros:\", mean(y == 0), \"\\n\") #> Proportion of zeros: 0.292"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"egpd-fit-2","dir":"Articles","previous_headings":"Zero-inflated discrete EGPD (ZIDEGPD) Model 1","what":"egpd fit","title":"Comparing egpd and bamlss Fits","text":"","code":"fit_zidegpd <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1, logitpi = ~ 1),                     data = df, family = \"zidegpd\", zidegpd.args = list(m = 1)) pars_zidegpd <- predict(fit_zidegpd, type = \"response\")[1, ]"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"bamlss-fit-2","dir":"Articles","previous_headings":"Zero-inflated discrete EGPD (ZIDEGPD) Model 1","what":"bamlss fit","title":"Comparing egpd and bamlss Fits","text":"","code":"fit_zidegpd_b <- bamlss(list(y ~ 1, ~ 1, ~ 1, ~ 1),                         data = df, family = zidegpd_bamlss(m = 1),                         verbose = FALSE)"},{"path":"https://sdwfrost.github.io/egpd/articles/bamlss-comparison.html","id":"comparison-2","dir":"Articles","previous_headings":"Zero-inflated discrete EGPD (ZIDEGPD) Model 1","what":"Comparison","title":"Comparing egpd and bamlss Fits","text":"fitting approaches recover four parameters zero-inflated discrete model.","code":"sigma_zdb <- exp(fit_zidegpd_b$parameters$sigma$p) xi_zdb    <- exp(fit_zidegpd_b$parameters$xi$p) kappa_zdb <- exp(fit_zidegpd_b$parameters$kappa$p) pi_zdb    <- 1 / (1 + exp(-fit_zidegpd_b$parameters$pi$p))  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\", \"pi\"),   true      = c(sigma_true, xi_true, kappa_true, pi_true),   egpd      = round(as.numeric(unlist(pars_zidegpd)), 4),   bamlss    = round(c(sigma_zdb, xi_zdb, kappa_zdb, pi_zdb), 4),   row.names = NULL ) #>   parameter true   egpd bamlss #> 1     sigma 3.00 3.0878 3.0733 #> 2        xi 0.15 0.1465 0.1479 #> 3     kappa 2.00 1.7892 1.8001 #> 4        pi 0.25 0.2161 0.2167"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"construction","dir":"Articles","previous_headings":"1. The BDEGPD model","what":"Construction","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"BDEGPD constructs bivariate non-negative integer observations discretizing continuous BEGPD: Generate (Y1*,Y2*)(Y_1^*, Y_2^*) bivariate BEGPD (radial-angular construction parameters κ\\kappa, σ\\sigma, ξ\\xi, θL\\theta_L, θU\\theta_U, θω\\theta_\\omega). Apply Yj=⌊Yj*⌋Y_j = \\lfloor Y_j^* \\rfloor j=1,2j = 1, 2. parallels univariate discrete EGPD, uses P(X=k)=FEGPD(k+1)−FEGPD(k)P(X = k) = F_{\\mathrm{EGPD}}(k+1) - F_{\\mathrm{EGPD}}(k), extends two dimensions via BEGPD’s dependence structure.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"zero-inflated-extension-bzidegpd","dir":"Articles","previous_headings":"1. The BDEGPD model","what":"Zero-inflated extension (BZIDEGPD)","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"Many bivariate count datasets excess joint zeros – example, paired event counts components simultaneously inactive. BZIDEGPD adds joint zero-inflation parameter π0∈(0,1)\\pi_0 \\(0, 1): (Y1,Y2)={(0,0)probability π0⌊BEGPD⌋probability 1−π0 (Y_1, Y_2) = \\begin{cases} (0, 0) & \\text{probability } \\pi_0 \\\\ \\lfloor\\text{BEGPD}\\rfloor & \\text{probability } 1 - \\pi_0 \\end{cases}","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"simulating-bivariate-discrete-data","dir":"Articles","previous_headings":"","what":"2. Simulating bivariate discrete data","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"rbdegpd() rbzidegpd() functions generate bivariate discrete samples. pure R require Julia.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"basic-bdegpd","dir":"Articles","previous_headings":"2. Simulating bivariate discrete data","what":"Basic BDEGPD","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"Since data integers, scatter plots benefit jittering avoid overplotting grid:","code":"library(egpd) set.seed(42)  Y <- rbdegpd(2000, kappa = 2, sigma = 1, xi = 0.1,              thL = 5, thU = 5, thw = 0.2) head(Y) #>      Y1 Y2 #> [1,]  1  2 #> [2,]  2  1 #> [3,]  0  0 #> [4,]  1  1 #> [5,]  1  0 #> [6,]  0  0 cat(\"Dimensions:\", nrow(Y), \"x\", ncol(Y), \"\\n\") #> Dimensions: 2000 x 2 cat(\"Storage mode:\", storage.mode(Y), \"\\n\") #> Storage mode: integer cat(\"Range Y1:\", range(Y[, 1]), \"  Range Y2:\", range(Y[, 2]), \"\\n\") #> Range Y1: 0 9   Range Y2: 0 7 plot(jitter(Y[, 1]), jitter(Y[, 2]), pch = 20, cex = 0.3,      xlab = expression(Y[1]), ylab = expression(Y[2]),      main = \"Simulated BDEGPD (jittered)\",      col = adjustcolor(\"steelblue\", 0.4))"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"marginal-distributions","dir":"Articles","previous_headings":"2. Simulating bivariate discrete data","what":"Marginal distributions","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"marginal distributions BDEGPD univariate discrete EGPD (DEGPD):","code":"op <- par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))  barplot(table(Y[, 1]) / nrow(Y), main = expression(\"Marginal \" * Y[1]),         xlab = expression(Y[1]), ylab = \"Proportion\",         col = \"lightblue\", border = \"grey\")  barplot(table(Y[, 2]) / nrow(Y), main = expression(\"Marginal \" * Y[2]),         xlab = expression(Y[2]), ylab = \"Proportion\",         col = \"lightblue\", border = \"grey\") par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"zero-inflated-bzidegpd","dir":"Articles","previous_headings":"2. Simulating bivariate discrete data","what":"Zero-inflated BZIDEGPD","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"","code":"set.seed(42) Y_zi <- rbzidegpd(2000, kappa = 2, sigma = 1, xi = 0.1,                    thL = 5, thU = 5, thw = 0.2, pi0 = 0.3)  joint_zeros <- mean(Y_zi[, 1] == 0 & Y_zi[, 2] == 0) cat(\"Proportion of joint (0,0) rows:\", round(joint_zeros, 3), \"\\n\") #> Proportion of joint (0,0) rows: 0.725 cat(\"(Expected >= pi0 = 0.3 due to natural zeros)\\n\") #> (Expected >= pi0 = 0.3 due to natural zeros)"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"exploring-the-parameter-space","dir":"Articles","previous_headings":"","what":"3. Exploring the parameter space","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"six BDEGPD parameters control different aspects bivariate discrete distribution.  Key observations: Light tails + weak dependence (θL=θU=10\\theta_L = \\theta_U = 10): mass near zero, observations roughly independent. Heavy tails + strong dependence (θL=θU=1\\theta_L = \\theta_U = 1): Larger values, strong clustering along diagonal. Asymmetric tails (θU=0.5\\theta_U = 0.5): Upper tail exhibits strong dependence (components tend simultaneously large). Zero-inflation (π0=0.4\\pi_0 = 0.4): Prominent spike (0,0)(0, 0) beyond base model produces.","code":"set.seed(123) n <- 3000  scenarios <- list(   \"Light tails, weak dep.\\n(kappa=3, xi=0.05, thL=thU=10)\" = list(     kappa = 3, sigma = 1, xi = 0.05, thL = 10, thU = 10, thw = 0.25   ),   \"Heavy tails, strong dep.\\n(kappa=1, xi=0.3, thL=thU=1)\" = list(     kappa = 1, sigma = 2, xi = 0.3, thL = 1, thU = 1, thw = 0.25   ),   \"Asymmetric tails\\n(kappa=0.5, thU=0.5)\" = list(     kappa = 0.5, sigma = 1, xi = 0.1, thL = 10, thU = 0.5, thw = 0.25   ),   \"Zero-inflated (pi0=0.4)\\n(kappa=2, sigma=1, xi=0.1)\" = list(     kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2, pi0 = 0.4   ) )  op <- par(mfrow = c(2, 2), mar = c(4, 4, 3, 1)) for (i in seq_along(scenarios)) {   sc <- scenarios[[i]]   if (!is.null(sc$pi0)) {     Y_sc <- rbzidegpd(n, kappa = sc$kappa, sigma = sc$sigma, xi = sc$xi,                        thL = sc$thL, thU = sc$thU, thw = sc$thw, pi0 = sc$pi0)   } else {     Y_sc <- rbdegpd(n, kappa = sc$kappa, sigma = sc$sigma, xi = sc$xi,                      thL = sc$thL, thU = sc$thU, thw = sc$thw)   }   plot(jitter(Y_sc[, 1]), jitter(Y_sc[, 2]), pch = 20, cex = 0.3,        main = names(scenarios)[i], cex.main = 0.85,        xlab = expression(Y[1]), ylab = expression(Y[2]),        col = adjustcolor(\"steelblue\", 0.4)) } par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"dependence-structure","dir":"Articles","previous_headings":"","what":"4. Dependence structure","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"BDEGPD inherits dependence structure continuous BEGPD, discretized integer lattice. can visualise correlation joint zero probability vary parameters:","code":"set.seed(1) n_dep <- 5000  ## Vary thL = thU jointly (dependence strength) th_vals <- c(0.5, 1, 2, 5, 10, 20) cors <- sapply(th_vals, function(th) {   Y_tmp <- rbdegpd(n_dep, kappa = 2, sigma = 1, xi = 0.1,                     thL = th, thU = th, thw = 0.25)   cor(Y_tmp[, 1], Y_tmp[, 2]) })  op <- par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))  plot(th_vals, cors, type = \"b\", pch = 16,      xlab = expression(theta[L] == theta[U]),      ylab = \"Correlation\",      main = \"Pearson correlation vs dependence\") abline(h = 0, col = \"grey\", lty = 2)  ## Vary xi (tail heaviness affects joint structure) xi_vals <- c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5) cors_xi <- sapply(xi_vals, function(xi_v) {   Y_tmp <- rbdegpd(n_dep, kappa = 2, sigma = 1, xi = xi_v,                     thL = 3, thU = 3, thw = 0.25)   cor(Y_tmp[, 1], Y_tmp[, 2]) })  plot(xi_vals, cors_xi, type = \"b\", pch = 16,      xlab = expression(xi),      ylab = \"Correlation\",      main = expression(\"Correlation vs \" * xi * \" (thL=thU=3)\")) par(op)"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"why-neural-estimation","dir":"Articles","previous_headings":"5. Neural Bayes estimation","what":"Why neural estimation?","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"BDEGPD closed-form bivariate discrete likelihood. discretization floor(BEGPD) breaks analytical structure continuous model: computing joint PMF P(Y1=k1,Y2=k2)P(Y_1 = k_1, Y_2 = k_2) require integrating bivariate density unit square, intractable six parameters. Neural Bayes estimation sidesteps likelihood training neural network simulated data. trained, inference new datasets nearly instant.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"prerequisites","dir":"Articles","previous_headings":"5. Neural Bayes estimation","what":"Prerequisites","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"Neural Bayes estimation requires Julia (>= 1.11):","code":"# R packages install.packages(\"JuliaConnectoR\") remotes::install_github(\"msainsburydale/NeuralEstimators\")  # Julia packages (run in Julia REPL) # using Pkg # Pkg.add([\"NeuralEstimators\", \"Flux\"])"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"fitting-bdegpd-with-npe","dir":"Articles","previous_headings":"5. Neural Bayes estimation","what":"Fitting BDEGPD with NPE","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"summary reports posterior medians, posterior standard deviations, 95% credible intervals six parameters.","code":"set.seed(42)  Y <- rbdegpd(2000, kappa = 2, sigma = 1, xi = 0.1,              thL = 5, thU = 5, thw = 0.2)  fit <- fitegpd(Y, family = \"bdegpd\", method = \"neuralbayes\",                estimator = \"npe\", nsamples = 2000) #> Starting Julia ... summary(fit) #> Fitting of bivariate discrete EGPD (BDEGPD) [Experimental] #> Method: neuralbayes (npe)  [2000 posterior samples] #>  #> Posterior summary: #>        Median Post.SD   2.5%   97.5% #> kappa  4.4929  3.1151 0.9939 12.3908 #> sigma  0.6330  0.2939 0.2654  1.4040 #> xi     0.1629  0.1128 0.0166  0.4279 #> thL   10.0429  6.3580 0.5709 23.1020 #> thU    5.8545  2.8684 1.9730 13.1217 #> thw    0.2309  0.1377 0.0245  0.5024 #>  #> Note: log-likelihood, AIC, and BIC are not available for neural estimation #> Number of observations:  2000"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"fitting-bzidegpd-with-npe","dir":"Articles","previous_headings":"5. Neural Bayes estimation","what":"Fitting BZIDEGPD with NPE","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"BZIDEGPD fit estimates seven parameters (six BDEGPD parameters plus π0\\pi_0).","code":"set.seed(42)  Y_zi <- rbzidegpd(2000, kappa = 2, sigma = 1, xi = 0.1,                    thL = 5, thU = 5, thw = 0.2, pi0 = 0.3)  fit_zi <- fitegpd(Y_zi, family = \"bzidegpd\", method = \"neuralbayes\",                    estimator = \"npe\", nsamples = 2000) summary(fit_zi) #> Fitting of zero-inflated bivariate discrete EGPD (BZIDEGPD) [Experimental] #> Method: neuralbayes (npe)  [2000 posterior samples] #>  #> Posterior summary: #>       Median Post.SD   2.5%   97.5% #> kappa 4.3215  3.2761 0.8761 13.0502 #> sigma 0.7046  0.3256 0.2804  1.4882 #> xi    0.1604  0.1103 0.0127  0.3971 #> thL   8.8578  5.7294 0.7478 21.4948 #> thU   5.1771  3.4908 0.8581 14.1159 #> thw   0.2558  0.1429 0.0290  0.5420 #> pi0   0.2724  0.2055 0.0087  0.6872 #>  #> Note: log-likelihood, AIC, and BIC are not available for neural estimation #> Number of observations:  2000"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"diagnostic-plots","dir":"Articles","previous_headings":"5. Neural Bayes estimation","what":"Diagnostic plots","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"diagnostic plot BDEGPD/BZIDEGPD shows four panels: Observed scatter (jittered) – integer-valued input data Simulated scatter (jittered) – data fitted model Marginal barplot – observed vs simulated distribution Y1+Y2Y_1 + Y_2 Posterior marginals (NPE) parameter bar chart (NBE)","code":"plot(fit)"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"s3-methods","dir":"Articles","previous_headings":"5. Neural Bayes estimation","what":"S3 methods","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"standard S3 methods work BDEGPD fits: Since neural estimation bypasses likelihood, logLik(), AIC(), BIC() return NA.","code":"coef(fit)                # Posterior median estimates #>      kappa      sigma         xi        thL        thU        thw  #>  4.4928845  0.6330015  0.1628595 10.0428603  5.8544827  0.2309155 confint(fit)             # 95% credible intervals #>            2.5 %     97.5 % #> kappa 0.99389462 12.3907538 #> sigma 0.26536305  1.4040061 #> xi    0.01660769  0.4278888 #> thL   0.57088922 23.1019973 #> thU   1.97297296 13.1216692 #> thw   0.02453829  0.5024474 confint(fit, level = 0.9) # 90% credible intervals #>              5 %       95 % #> kappa 1.25211543 11.1133906 #> sigma 0.29931825  1.2648777 #> xi    0.02604579  0.3832131 #> thL   1.06572944 21.2153999 #> thU   2.45191137 11.7026999 #> thw   0.03691453  0.4698184 vcov(fit)                # Posterior covariance matrix #>             kappa         sigma            xi         thL         thU #> kappa  9.70354669 -0.7342482901  0.1827664998  0.45042036  1.38813252 #> sigma -0.73424829  0.0863741629 -0.0234915696  0.01452720 -0.09187063 #> xi     0.18276650 -0.0234915696  0.0127243260 -0.03512248 -0.02389033 #> thL    0.45042036  0.0145272021 -0.0351224829 40.42441686 -2.10625723 #> thU    1.38813252 -0.0918706289 -0.0238903321 -2.10625723  8.22761354 #> thw    0.01395369 -0.0009261211  0.0005739534  0.11202078  0.03024729 #>                 thw #> kappa  0.0139536868 #> sigma -0.0009261211 #> xi     0.0005739534 #> thL    0.1120207780 #> thU    0.0302472858 #> thw    0.0189747138 nobs(fit)                # Number of observations #> [1] 2000"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"comparison-with-begpd","dir":"Articles","previous_headings":"","what":"6. Comparison with BEGPD","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"One natural question discrete BDEGPD compares continuous BEGPD. key differences : discretization preserves dependence structure upper tail (large counts remain correlated) introduces point masses small values.","code":"set.seed(42) n_compare <- 2000  Y_cont <- rbegpd(n_compare, kappa = 2, sigma = 1, xi = 0.1,                   thL = 5, thU = 5, thw = 0.2) Y_disc <- rbdegpd(n_compare, kappa = 2, sigma = 1, xi = 0.1,                    thL = 5, thU = 5, thw = 0.2)  op <- par(mfrow = c(1, 2), mar = c(4, 4, 2, 1)) plot(Y_cont[, 1], Y_cont[, 2], pch = 20, cex = 0.3,      main = \"Continuous BEGPD\",      xlab = expression(Y[1]), ylab = expression(Y[2]),      col = adjustcolor(\"steelblue\", 0.4)) plot(jitter(Y_disc[, 1]), jitter(Y_disc[, 2]), pch = 20, cex = 0.3,      main = \"Discrete BDEGPD (jittered)\",      xlab = expression(Y[1]), ylab = expression(Y[2]),      col = adjustcolor(\"firebrick\", 0.4)) par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"training-custom-models","dir":"Articles","previous_headings":"","what":"7. Training custom models","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"bundled .bson models trained broad uniform priors. specific applications may want train narrower prior.","code":"# Quick training (for testing) paths <- train_bdegpd(   savepath = tempdir(),   family = \"bdegpd\",   estimator = \"both\",   quick = TRUE,   verbose = TRUE )  # Use the custom-trained model fit_custom <- fitegpd(Y, family = \"bdegpd\", method = \"neuralbayes\",                       model.path = paths$npe, estimator = \"npe\")  # Train BZIDEGPD model paths_zi <- train_bdegpd(   savepath = tempdir(),   family = \"bzidegpd\",   estimator = \"npe\",   quick = TRUE )"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/bivariate-discrete-egpd.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Bivariate Discrete EGPD via Neural Bayes Estimation","text":"Alotaibi, N., Sainsbury-Dale, M., Naveau, P., Gaetan, C., Huser, R. (2025). Joint modeling low high extremes using multivariate extended generalized Pareto distribution. arXiv preprint arXiv:2509.05982. https://arxiv.org/abs/2509.05982 Sainsbury-Dale, M., Zammit-Mangion, ., Huser, R. (2024). Likelihood-free parameter estimation neural Bayes estimators. American Statistician, 78(1), 1–14. Naveau, P., Huser, R., Ribereau, P., Hannart, . (2016). Modeling jointly low, moderate, heavy rainfall intensities without threshold selection. Water Resources Research, 52(4), 2897–2911.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"high proportion zeros suggests zero-inflated model may appropriate.","code":"library(egpd) data(docvisits) str(docvisits) #> 'data.frame':    1812 obs. of  1 variable: #>  $ visits: int  0 1 0 0 0 0 11 4 0 0 ... y <- docvisits$visits plot(table(y[y <= 30]), main = \"Doctor visits\",      xlab = \"Number of visits\", ylab = \"Frequency\") cat(\"n =\", length(y), \"\\n\") #> n = 1812 cat(\"Proportion of zeros:\", mean(y == 0), \"\\n\") #> Proportion of zeros: 0.4116998 cat(\"Range:\", range(y), \"\\n\") #> Range: 0 93"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"fitting-zidegpd-models","dir":"Articles","previous_headings":"","what":"Fitting ZIDEGPD models","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"ZIDEGPD family adds zero-inflation probability pi (logit scale: logitpi) DEGPD parameters. intercept-models, parameters get ~ 1 formulae.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"zidegpd-model-1-power-transformation-with-zero-inflation","dir":"Articles","previous_headings":"Fitting ZIDEGPD models","what":"ZIDEGPD Model 1: Power transformation with zero-inflation","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"Four parameters: sigma, xi, kappa, pi.","code":"df <- data.frame(y = y, x = rep(1, length(y))) fit1 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1, logitpi = ~ 1),              data = df, family = \"zidegpd\", zidegpd.args = list(m = 1)) summary(fit1) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)      0.2       0.31    0.65    0.259 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.92       0.15   -6.23 2.28e-10 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.47       0.39    3.77 8.31e-05 #>  #> logitpi #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.49       0.08   -6.26 1.91e-10 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit1), \"\\n\") #> Log-likelihood: -3868.713 cat(\"AIC:\", AIC(fit1), \"\\n\") #> AIC: 7745.425"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"zidegpd-model-2-mixture-of-power-transformations-with-zero-inflation","dir":"Articles","previous_headings":"Fitting ZIDEGPD models","what":"ZIDEGPD Model 2: Mixture of power transformations with zero-inflation","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"Six parameters: sigma, xi, kappa1, dkappa, p, pi.","code":"fit2 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa1 = ~ 1, ldkappa = ~ 1,                   logitp = ~ 1, logitpi = ~ 1),              data = df, family = \"zidegpd\", zidegpd.args = list(m = 2)) #> Final Hessian of negative penalized log-likelihood not numerically positive definite. summary(fit2) #> Warning in sqrt(obj$Vp[cbind(id2, id2)]): NaNs produced #> Warning in sqrt(obj$Vp[cbind(id2, id2)]): NaNs produced #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)      0.2       0.31    0.65    0.259 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.92       0.15   -6.23 2.28e-10 #>  #> logkappa1 #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.44        NaN     NaN      NaN #>  #> logdkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.03        NaN     NaN      NaN #>  #> logitp #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)   -15.39    1721.72   -0.01    0.496 #>  #> logitpi #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.49       0.08   -6.26 1.91e-10 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit2), \"\\n\") #> Log-likelihood: -3870.55 cat(\"AIC:\", AIC(fit2), \"\\n\") #> AIC: 7753.101"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"zidegpd-model-3-incomplete-beta-with-zero-inflation","dir":"Articles","previous_headings":"Fitting ZIDEGPD models","what":"ZIDEGPD Model 3: Incomplete beta with zero-inflation","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"Four parameters: sigma, xi, delta, pi.","code":"fit3 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, ldelta = ~ 1, logitpi = ~ 1),              data = df, family = \"zidegpd\", zidegpd.args = list(m = 3)) summary(fit3) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.86        0.3    2.85   0.0022 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -1.28       0.19   -6.87 3.29e-12 #>  #> logdelta #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.22       1.11     0.2     0.42 #>  #> logitpi #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     -0.7       0.07  -10.65   <2e-16 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit3), \"\\n\") #> Log-likelihood: -3871.392 cat(\"AIC:\", AIC(fit3), \"\\n\") #> AIC: 7750.784"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"zidegpd-model-4-power-beta-with-zero-inflation","dir":"Articles","previous_headings":"Fitting ZIDEGPD models","what":"ZIDEGPD Model 4: Power-beta with zero-inflation","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"Five parameters: sigma, xi, kappa, delta, pi.","code":"fit4 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1, ldelta = ~ 1,                   logitpi = ~ 1),              data = df, family = \"zidegpd\", zidegpd.args = list(m = 4)) summary(fit4) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.25       0.39   -0.65    0.258 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -1.02       0.21   -4.82 7.25e-07 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.57       0.43    3.67 0.000123 #>  #> logdelta #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -9.09    2843.62       0    0.499 #>  #> logitpi #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.48       0.08   -6.31 1.43e-10 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit4), \"\\n\") #> Log-likelihood: -3869.405 cat(\"AIC:\", AIC(fit4), \"\\n\") #> AIC: 7748.81"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"zidegpd-model-5-truncated-normal-with-zero-inflation","dir":"Articles","previous_headings":"Fitting ZIDEGPD models","what":"ZIDEGPD Model 5: Truncated normal with zero-inflation","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"Four parameters: sigma, xi, kappa, pi.","code":"fit5 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1, logitpi = ~ 1),              data = df, family = \"zidegpd\", zidegpd.args = list(m = 5)) summary(fit5) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.51       0.19    2.75  0.00298 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.97       0.15   -6.65 1.48e-11 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     2.27        0.4    5.76 4.32e-09 #>  #> logitpi #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.54        0.1   -5.34 4.65e-08 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit5), \"\\n\") #> Log-likelihood: -3868.477 cat(\"AIC:\", AIC(fit5), \"\\n\") #> AIC: 7744.953"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"zidegpd-model-6-truncated-beta-with-zero-inflation","dir":"Articles","previous_headings":"Fitting ZIDEGPD models","what":"ZIDEGPD Model 6: Truncated beta with zero-inflation","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"Four parameters: sigma, xi, kappa, pi.","code":"fit6 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1, logitpi = ~ 1),              data = df, family = \"zidegpd\", zidegpd.args = list(m = 6)) summary(fit6) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.57       0.18    3.11 0.000929 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)       -1       0.15   -6.59 2.14e-11 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.67       0.35    4.82  7.2e-07 #>  #> logitpi #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.49       0.08   -6.34 1.14e-10 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit6), \"\\n\") #> Log-likelihood: -3868.112 cat(\"AIC:\", AIC(fit6), \"\\n\") #> AIC: 7744.225"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"model-comparison","dir":"Articles","previous_headings":"","what":"Model comparison","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"","code":"aic_table <- data.frame(   Model = c(\"ZIDEGPD-1\", \"ZIDEGPD-2\", \"ZIDEGPD-3\", \"ZIDEGPD-4\",             \"ZIDEGPD-5\", \"ZIDEGPD-6\"),   npar = c(4, 6, 4, 5, 4, 4),   logLik = c(logLik(fit1), logLik(fit2), logLik(fit3), logLik(fit4),              logLik(fit5), logLik(fit6)),   AIC = c(AIC(fit1), AIC(fit2), AIC(fit3), AIC(fit4),           AIC(fit5), AIC(fit6)) ) aic_table #>       Model npar    logLik      AIC #> 1 ZIDEGPD-1    4 -3868.713 7745.425 #> 2 ZIDEGPD-2    6 -3870.550 7753.101 #> 3 ZIDEGPD-3    4 -3871.392 7750.784 #> 4 ZIDEGPD-4    5 -3869.405 7748.810 #> 5 ZIDEGPD-5    4 -3868.477 7744.953 #> 6 ZIDEGPD-6    4 -3868.112 7744.225"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"","what":"Goodness of fit","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"","code":"# Extract fitted parameters on the response scale pars1 <- predict(fit1, type = \"response\") sigma1 <- pars1$scale[1]; xi1 <- pars1$shape[1] kappa1 <- pars1$kappa[1]; pi1 <- pars1$pi[1]  xvals <- 0:30 emp_pmf <- tabulate(y + 1, nbins = max(xvals) + 1) / length(y) emp_pmf <- emp_pmf[seq_along(xvals)]  fit_pmf1 <- dzidiscegpd(xvals, pi = pi1, sigma = sigma1, xi = xi1,                          kappa = kappa1, type = 1)  plot(xvals, emp_pmf, type = \"h\", lwd = 2, col = \"grey60\",      main = \"Empirical vs fitted PMF (ZIDEGPD-1)\",      xlab = \"Count\", ylab = \"Probability\") lines(xvals + 0.2, fit_pmf1, type = \"h\", lwd = 2, col = \"firebrick\") legend(\"topright\", legend = c(\"Empirical\", \"ZIDEGPD-1\"),        col = c(\"grey60\", \"firebrick\"), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"q-q-plots","dir":"Articles","previous_headings":"","what":"Q-Q plots","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"Randomized quantile residuals provide model-agnostic diagnostic: model correct, residuals follow standard normal distribution.","code":"set.seed(1) par(mfrow = c(3, 2))  r1 <- rqresid(fit1) qqnorm(r1, main = \"Q-Q Plot (ZIDEGPD-1)\", pch = 20, col = \"grey60\") qqline(r1, col = \"red\")  r2 <- rqresid(fit2) qqnorm(r2, main = \"Q-Q Plot (ZIDEGPD-2)\", pch = 20, col = \"grey60\") qqline(r2, col = \"red\")  r3 <- rqresid(fit3) qqnorm(r3, main = \"Q-Q Plot (ZIDEGPD-3)\", pch = 20, col = \"grey60\") qqline(r3, col = \"red\")  r4 <- rqresid(fit4) qqnorm(r4, main = \"Q-Q Plot (ZIDEGPD-4)\", pch = 20, col = \"grey60\") qqline(r4, col = \"red\")  r5 <- rqresid(fit5) qqnorm(r5, main = \"Q-Q Plot (ZIDEGPD-5)\", pch = 20, col = \"grey60\") qqline(r5, col = \"red\")  r6 <- rqresid(fit6) qqnorm(r6, main = \"Q-Q Plot (ZIDEGPD-6)\", pch = 20, col = \"grey60\") qqline(r6, col = \"red\") par(mfrow = c(1, 1))"},{"path":"https://sdwfrost.github.io/egpd/articles/doctor-visits.html","id":"comparing-degpd-and-zidegpd","dir":"Articles","previous_headings":"","what":"Comparing DEGPD and ZIDEGPD","title":"Zero-Inflated Discrete EGPD Models for Doctor Visit Counts","text":"see whether zero-inflation needed, can also fit standard DEGPD model compare.","code":"fit_degpd1 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                    data = df, family = \"degpd\", degpd.args = list(m = 1))  cat(\"DEGPD-1  AIC:\", AIC(fit_degpd1), \"\\n\") #> DEGPD-1  AIC: 7783.052 cat(\"ZIDEGPD-1 AIC:\", AIC(fit1), \"\\n\") #> ZIDEGPD-1 AIC: 7745.425 cat(\"Estimated zero-inflation probability:\", round(pi1, 3), \"\\n\") #> Estimated zero-inflation probability: 0.38"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"standard-egpd","dir":"Articles","previous_headings":"","what":"1. Standard EGPD","title":"Fitting Continuous Distributions with fitegpd","text":"Extended GPD prepends CDF transformation GG uniform component GPD: F(x)=G(H(x;σ,ξ))F(x) = G\\!\\bigl(H(x;\\,\\sigma,\\xi)\\bigr) HH standard GPD CDF. type argument selects parametric form GG. Type 1 uses G(u)=uκG(u) = u^\\kappa single shape parameter κ>0\\kappa > 0.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"simulating-and-fitting","dir":"Articles","previous_headings":"1. Standard EGPD","what":"Simulating and fitting","title":"Fitting Continuous Distributions with fitegpd","text":"","code":"library(egpd) set.seed(1)  # True parameters sigma_true <- 2 xi_true    <- 0.1 kappa_true <- 1.5  x <- regpd(1000, sigma = sigma_true, xi = xi_true,            kappa = kappa_true, type = 1)  fit_egpd <- fitegpd(x, type = 1, family = \"egpd\") summary(fit_egpd) #> Fitting of the distribution 'egpd' (type 1) #> Method: mle #>  #> Estimated parameters: #>       Estimate Std. Error z value Pr(>|z|)     #> sigma  1.81412    0.15064  12.043  < 2e-16 *** #> xi     0.15344    0.03979   3.856 0.000115 *** #> kappa  1.61603    0.10592  15.257  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Convergence:  successful  #> Loglikelihood:  -2037.6   AIC:  4081.21   BIC:  4095.93  #> Number of observations:  1000"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"diagnostics","dir":"Articles","previous_headings":"1. Standard EGPD","what":"Diagnostics","title":"Fitting Continuous Distributions with fitegpd","text":"four-panel diagnostic plot shows histogram fitted density, empirical vs fitted CDF, Q-Q plot, P-P plot.","code":"plot(fit_egpd)"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"model-comparison-across-types","dir":"Articles","previous_headings":"1. Standard EGPD","what":"Model comparison across types","title":"Fitting Continuous Distributions with fitegpd","text":"Different types impose different shapes GG. can compare AIC: Since data generated Type 1, expect lowest AIC (close).","code":"aic_table <- data.frame(   type = c(1, 4, 5),   AIC = c(     AIC(fitegpd(x, type = 1)),     AIC(fitegpd(x, type = 4)),     AIC(fitegpd(x, type = 5))   ) ) aic_table #>   type      AIC #> 1    1 4081.205 #> 2    4 4083.362 #> 3    5 4083.240"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"fixing-parameters","dir":"Articles","previous_headings":"1. Standard EGPD","what":"Fixing parameters","title":"Fitting Continuous Distributions with fitegpd","text":"Sometimes want fix one parameter known value. fix.arg argument removes optimization: fixed parameter shown separately summary output, confidence intervals cover free parameters:","code":"fit_fix <- fitegpd(x, type = 1, fix.arg = list(xi = 0.1)) summary(fit_fix) #> Fitting of the distribution 'egpd' (type 1) #> Method: mle #>  #> Estimated parameters: #>       Estimate Std. Error z value Pr(>|z|)     #> sigma  1.99292    0.08802   22.64   <2e-16 *** #> kappa  1.52398    0.07320   20.82   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Fixed parameters: #>    Value #> xi   0.1 #>  #> Convergence:  successful  #> Loglikelihood:  -2038.58   AIC:  4081.16   BIC:  4090.98  #> Number of observations:  1000 confint(fit_fix) #>          2.5 %   97.5 % #> sigma 1.820400 2.165441 #> kappa 1.380523 1.667447"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"bernstein-egpd","dir":"Articles","previous_headings":"","what":"2. Bernstein EGPD","title":"Fitting Continuous Distributions with fitegpd","text":"parametric GG standard EGPD may rigid datasets. Bernstein EGPD replaces flexible Bernstein polynomial density: f(x)=b(H(x)κ)κH(x)κ−1h(x)f(x) = b\\!\\bigl(H(x)^\\kappa\\bigr)\\;\\kappa\\,H(x)^{\\kappa-1}\\,h(x) bb Bernstein polynomial density degree mm softmax-parameterized weights. gives semiparametric model can approximate smooth density (0,1)(0,1).","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"fitting","dir":"Articles","previous_headings":"2. Bernstein EGPD","what":"Fitting","title":"Fitting Continuous Distributions with fitegpd","text":"Select method = \"bernstein\" choose polynomial degree bernstein.m. two-stage procedure first estimates GPD parameters via parametric MLE, jointly optimizes parameters. reported parameters σ\\sigma, ξ\\xi, κ\\kappa; Bernstein weights stored internally. effective number parameters 3+(m−1)3 + (m - 1) since mm weights sum 1.","code":"fit_bern <- fitegpd(x, type = 1, method = \"bernstein\", bernstein.m = 8) summary(fit_bern) #> Fitting of the distribution 'egpd' (type 1) #> Method: bernstein (Bernstein degree = 8) #>  #> Estimated parameters: #>       Estimate Std. Error z value Pr(>|z|)     #> sigma  1.46578    0.36935   3.968 7.23e-05 *** #> xi     0.17174    0.05082   3.380 0.000726 *** #> kappa  1.77748    0.38894   4.570 4.88e-06 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Convergence:  successful  #> Loglikelihood:  -2036.2   AIC:  4092.4   BIC:  4141.48  #> Number of observations:  1000"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"comparing-parametric-and-semiparametric-fits","dir":"Articles","previous_headings":"2. Bernstein EGPD","what":"Comparing parametric and semiparametric fits","title":"Fitting Continuous Distributions with fitegpd","text":"well-specified parametric data standard EGPD typically wins AIC due fewer effective parameters. Bernstein model useful true GG unknown match six parametric types.","code":"cat(\"Parametric AIC:     \", AIC(fit_egpd), \"\\n\") #> Parametric AIC:      4081.205 cat(\"Bernstein (m=8) AIC:\", AIC(fit_bern), \"\\n\") #> Bernstein (m=8) AIC: 4092.405"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"diagnostics-1","dir":"Articles","previous_headings":"2. Bernstein EGPD","what":"Diagnostics","title":"Fitting Continuous Distributions with fitegpd","text":"","code":"plot(fit_bern)"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"sensitivity-to-bernstein-degree","dir":"Articles","previous_headings":"2. Bernstein EGPD","what":"Sensitivity to Bernstein degree","title":"Fitting Continuous Distributions with fitegpd","text":"","code":"aic_m <- sapply(c(4, 6, 8, 12), function(m) {   AIC(fitegpd(x, type = 1, method = \"bernstein\", bernstein.m = m)) }) data.frame(m = c(4, 6, 8, 12), AIC = round(aic_m, 2)) #>    m     AIC #> 1  4 4086.59 #> 2  6 4088.85 #> 3  8 4092.40 #> 4 12 4097.91"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"compound-poisson-egpd","dir":"Articles","previous_headings":"","what":"3. Compound Poisson EGPD","title":"Fitting Continuous Distributions with fitegpd","text":"Compound Poisson EGPD models aggregated positive data (e.g. total rainfall period) random sum S=X1+⋯+XNS = X_1 + \\cdots + X_N : N∼Poisson(λ)N \\sim \\mathrm{Poisson}(\\lambda) number events, Xi∼EGPD(σ,ξ,κ)X_i \\sim \\mathrm{EGPD}(\\sigma, \\xi, \\kappa) ..d. event sizes. distribution SS point mass zero (P(S=0)=e−λP(S=0) = e^{-\\lambda}) continuous positive part. PMF evaluated via Panjer recursion discretized EGPD severity. model described Naveau et al. (2025) aggregated rainfall.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"panjer-recursion","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Panjer recursion","title":"Fitting Continuous Distributions with fitegpd","text":"severity CDF discretized grid {0,h,2h,…}\\{0, h, 2h, \\ldots\\} using mean-preserving rounding method: f0=FEGPD(h/2),fk=FEGPD((k+12)h)−FEGPD((k−12)h),k≥1f_0 = F_{\\mathrm{EGPD}}(h/2),\\qquad f_k = F_{\\mathrm{EGPD}}\\!\\bigl((k+\\tfrac12)h\\bigr) - F_{\\mathrm{EGPD}}\\!\\bigl((k-\\tfrac12)h\\bigr),\\quad k \\ge 1 compound distribution computed recursively: g0=e−λ(1−f0),gk=λk∑j=1kjfjgk−j,k≥1g_0 = e^{-\\lambda(1-f_0)},\\qquad g_k = \\frac{\\lambda}{k}\\sum_{j=1}^{k} j\\,f_j\\,g_{k-j},\\quad k \\ge 1","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"simulating-compound-poisson-egpd-data","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Simulating compound Poisson-EGPD data","title":"Fitting Continuous Distributions with fitegpd","text":"rcpegpd() function uses direct simulation (Panjer needed): draw N∼Poisson(λ)N \\sim \\mathrm{Poisson}(\\lambda), sum NN ..d. EGPD draws.","code":"set.seed(42) sigma_true  <- 2 xi_true     <- 0.1 kappa_true  <- 1.5 lambda_true <- 2  y <- rcpegpd(1000, sigma = sigma_true, xi = xi_true,              kappa = kappa_true, lambda = lambda_true, type = 1)  cat(\"Proportion of zeros:\", mean(y == 0), \"\\n\") #> Proportion of zeros: 0.147 cat(\"Theoretical P(S=0):\", exp(-lambda_true), \"\\n\") #> Theoretical P(S=0): 0.1353353 cat(\"Mean:\", round(mean(y), 2), \"\\n\") #> Mean: 5.62 hist(y, breaks = 40, freq = FALSE, col = \"lightblue\", border = \"grey\",      main = \"Simulated Compound Poisson-EGPD data\", xlab = \"S\")"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"fitting-1","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Fitting","title":"Fitting Continuous Distributions with fitegpd","text":"Select family = \"cpegpd\". discretization step size controlled cpegpd.h (default 0.2); smaller values give better accuracy cost speed.","code":"fit_cp <- fitegpd(y, type = 1, family = \"cpegpd\", cpegpd.h = 0.1) summary(fit_cp) #> Fitting of the distribution 'cpegpd' (type 1) #> Method: mle (cpegpd discretization h = 0.1) #>  #> Estimated parameters: #>        Estimate Std. Error z value Pr(>|z|)     #> sigma   2.09304    0.30220   6.926 4.33e-12 *** #> xi      0.08062    0.06037   1.335    0.182     #> kappa   1.49342    0.19439   7.682 1.56e-14 *** #> lambda  1.91981    0.07678  25.003  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Convergence:  successful  #> Loglikelihood:  -4808.26   AIC:  9624.53   BIC:  9644.16  #> Number of observations:  1000 truth <- c(sigma = sigma_true, xi = xi_true,            kappa = kappa_true, lambda = lambda_true) est <- fit_cp$estimate cbind(true = truth, estimate = round(est, 4),       SE = round(fit_cp$sd, 4)) #>        true estimate     SE #> sigma   2.0   2.0930 0.3022 #> xi      0.1   0.0806 0.0604 #> kappa   1.5   1.4934 0.1944 #> lambda  2.0   1.9198 0.0768"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"diagnostics-2","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Diagnostics","title":"Fitting Continuous Distributions with fitegpd","text":"","code":"plot(fit_cp)"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"checking-the-panjer-approximation","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Checking the Panjer approximation","title":"Fitting Continuous Distributions with fitegpd","text":"can verify Panjer-based CDF matches empirical distribution large simulation:","code":"set.seed(1) y_large <- rcpegpd(50000, sigma = sigma_true, xi = xi_true,                     kappa = kappa_true, lambda = lambda_true, type = 1) qvals <- seq(0, 30, by = 0.5) emp_cdf <- sapply(qvals, function(q) mean(y_large <= q)) theo_cdf <- pcpegpd(qvals, lambda = lambda_true, sigma = sigma_true,                      xi = xi_true, kappa = kappa_true, type = 1, h = 0.05)  plot(qvals, emp_cdf, type = \"l\", lwd = 2,      xlab = \"s\", ylab = \"CDF\", main = \"Panjer CDF vs empirical\") lines(qvals, theo_cdf, col = \"red\", lwd = 2, lty = 2) legend(\"bottomright\", c(\"Empirical (n=50000)\", \"Panjer (h=0.05)\"),        col = c(\"black\", \"red\"), lty = 1:2, lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"effect-of-discretization-step-size","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Effect of discretization step size","title":"Fitting Continuous Distributions with fitegpd","text":"Smaller h gives accurate approximation increases computation time: AIC stabilises sufficiently small h, indicating discretization error negligible. recommend h = 0.1 good default applications.","code":"h_grid <- c(0.5, 0.2, 0.1, 0.05) aic_h <- sapply(h_grid, function(hv) {   AIC(fitegpd(y, type = 1, family = \"cpegpd\", cpegpd.h = hv)) }) data.frame(h = h_grid, AIC = round(aic_h, 2)) #>      h      AIC #> 1 0.50  6826.97 #> 2 0.20  8423.21 #> 3 0.10  9624.53 #> 4 0.05 10817.72"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"confidence-intervals","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Confidence intervals","title":"Fitting Continuous Distributions with fitegpd","text":"","code":"confint(fit_cp) #>              2.5 %    97.5 % #> sigma   1.50074025 2.6853474 #> xi     -0.03770876 0.1989388 #> kappa   1.11242047 1.8744276 #> lambda  1.76932217 2.0703067"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"fixing-parameters-1","dir":"Articles","previous_headings":"3. Compound Poisson EGPD","what":"Fixing parameters","title":"Fitting Continuous Distributions with fitegpd","text":"families, individual parameters can fixed:","code":"fit_cp_fix <- fitegpd(y, type = 1, family = \"cpegpd\",                        fix.arg = list(xi = 0.1), cpegpd.h = 0.1) summary(fit_cp_fix) #> Fitting of the distribution 'cpegpd' (type 1) #> Method: mle (cpegpd discretization h = 0.1) #>  #> Estimated parameters: #>        Estimate Std. Error z value Pr(>|z|)     #> sigma   2.00603    0.12407   16.17   <2e-16 *** #> kappa   1.53851    0.14254   10.79   <2e-16 *** #> lambda  1.92366    0.07586   25.36   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Fixed parameters: #>    Value #> xi   0.1 #>  #> Convergence:  successful  #> Loglikelihood:  -4808.32   AIC:  9622.64   BIC:  9637.36  #> Number of observations:  1000"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-continuous.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Fitting Continuous Distributions with fitegpd","text":"three approaches: Return S3 objects class \"fitegpd\" interface (summary, plot, AIC, confint, coef, vcov, logLik) Support fix.arg fixing parameters known values Estimate standard errors via delta method Hessian Provide four-panel diagnostic plots","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"the-model","dir":"Articles","previous_headings":"1. Discrete EGPD","what":"The model","title":"Fitting Discrete Distributions with fitegpd","text":"discrete EGPD (DEGPD) PMF P(X=k)=G(H(k+1))−G(H(k)),k=0,1,2,…P(X = k) = G\\!\\bigl(H(k+1)\\bigr) - G\\!\\bigl(H(k)\\bigr), \\qquad k = 0, 1, 2, \\ldots HH standard GPD CDF GG EGPD transformation function. continuous EGPD, type argument selects parametric form GG.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"simulating-and-fitting","dir":"Articles","previous_headings":"1. Discrete EGPD","what":"Simulating and fitting","title":"Fitting Discrete Distributions with fitegpd","text":"generate data DEGPD Type 1 model fit back.","code":"library(egpd) set.seed(1)  sigma_true <- 3 xi_true    <- 0.1 kappa_true <- 1.5  x <- rdiscegpd(1000, sigma = sigma_true, xi = xi_true,                kappa = kappa_true, type = 1)  cat(\"Range:\", range(x), \"\\n\") #> Range: 0 51 cat(\"Mean:\", round(mean(x), 2), \"  Var:\", round(var(x), 2), \"\\n\") #> Mean: 3.89   Var: 19 cat(\"Proportion zeros:\", mean(x == 0), \"\\n\") #> Proportion zeros: 0.145 barplot(table(x) / length(x), main = \"Simulated DEGPD data\",         xlab = \"x\", ylab = \"Proportion\", col = \"lightblue\", border = \"grey\") fit_degpd <- fitegpd(x, type = 1, family = \"degpd\") summary(fit_degpd) #> Fitting of the distribution 'degpd' (type 1) #> Method: mle #>  #> Estimated parameters: #>       Estimate Std. Error z value Pr(>|z|)     #> sigma  2.79011    0.27440  10.168  < 2e-16 *** #> xi     0.14362    0.04309   3.333 0.000859 *** #> kappa  1.59145    0.13492  11.796  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Convergence:  successful  #> Loglikelihood:  -2457.38   AIC:  4920.77   BIC:  4935.49  #> Number of observations:  1000"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"parameter-recovery","dir":"Articles","previous_headings":"1. Discrete EGPD","what":"Parameter recovery","title":"Fitting Discrete Distributions with fitegpd","text":"","code":"truth <- c(sigma = sigma_true, xi = xi_true, kappa = kappa_true) est <- fit_degpd$estimate cbind(true = truth, estimate = round(est, 4),       SE = round(fit_degpd$sd, 4)) #>       true estimate     SE #> sigma  3.0   2.7901 0.2744 #> xi     0.1   0.1436 0.0431 #> kappa  1.5   1.5915 0.1349"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"diagnostics","dir":"Articles","previous_headings":"1. Discrete EGPD","what":"Diagnostics","title":"Fitting Discrete Distributions with fitegpd","text":"diagnostic plot discrete families shows empirical PMF fitted probabilities (panel 1), step-function CDF comparison (panel 2), normal Q-Q plot randomized quantile residuals (panel 3), P-P plot using randomized probability integral transform (panel 4). randomized PIT (Dunn & Smyth, 1996) spreads tied discrete values continuous uniform variates, producing clean diagonal plots instead banded patterns arise integer-valued quantiles.","code":"plot(fit_degpd)"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"comparing-types-by-aic","dir":"Articles","previous_headings":"1. Discrete EGPD","what":"Comparing types by AIC","title":"Fitting Discrete Distributions with fitegpd","text":"Different G-transformation types suit different data shapes. can use AIC select among :","code":"aic_table <- data.frame(   type = c(1, 4, 5),   AIC = c(     AIC(fitegpd(x, type = 1, family = \"degpd\")),     AIC(fitegpd(x, type = 4, family = \"degpd\")),     AIC(fitegpd(x, type = 5, family = \"degpd\"))   ) ) aic_table #>   type      AIC #> 1    1 4920.769 #> 2    4 4921.979 #> 3    5 4922.722"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"confidence-intervals","dir":"Articles","previous_headings":"1. Discrete EGPD","what":"Confidence intervals","title":"Fitting Discrete Distributions with fitegpd","text":"","code":"confint(fit_degpd) #>            2.5 %    97.5 % #> sigma 2.25229832 3.3279173 #> xi    0.05916484 0.2280755 #> kappa 1.32702000 1.8558842"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"fixing-parameters","dir":"Articles","previous_headings":"1. Discrete EGPD","what":"Fixing parameters","title":"Fitting Discrete Distributions with fitegpd","text":"continuous fits, individual parameters can fixed known values:","code":"fit_fix <- fitegpd(x, type = 1, family = \"degpd\",                     fix.arg = list(xi = 0.1)) summary(fit_fix) #> Fitting of the distribution 'degpd' (type 1) #> Method: mle #>  #> Estimated parameters: #>       Estimate Std. Error z value Pr(>|z|)     #> sigma  3.03816    0.14717   20.64   <2e-16 *** #> kappa  1.49640    0.08492   17.62   <2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Fixed parameters: #>    Value #> xi   0.1 #>  #> Convergence:  successful  #> Loglikelihood:  -2457.94   AIC:  4919.87   BIC:  4929.69  #> Number of observations:  1000"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"the-model-1","dir":"Articles","previous_headings":"2. Zero-Inflated Discrete EGPD","what":"The model","title":"Fitting Discrete Distributions with fitegpd","text":"Many count datasets zeros standard count model can explain — e.g. number insurance claims (many policyholders file none), species counts (many sites zero individuals), disease counts (many days cases). zero-inflated discrete EGPD (ZIDEGPD) handles mixing point mass zero DEGPD: P(X=k)={π+(1−π)PDEGPD(X=0)k=0(1−π)PDEGPD(X=k)k≥1P(X = k) = \\begin{cases} \\pi + (1-\\pi)\\,P_{\\mathrm{DEGPD}}(X=0) & k = 0 \\\\ (1-\\pi)\\,P_{\\mathrm{DEGPD}}(X=k) & k \\ge 1 \\end{cases} π∈(0,1)\\pi \\(0,1) zero-inflation probability. overall zero probability π+(1−π)PDEGPD(0)\\pi + (1-\\pi)\\,P_{\\mathrm{DEGPD}}(0), always larger PDEGPD(0)P_{\\mathrm{DEGPD}}(0) alone.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"simulating-and-fitting-1","dir":"Articles","previous_headings":"2. Zero-Inflated Discrete EGPD","what":"Simulating and fitting","title":"Fitting Discrete Distributions with fitegpd","text":"zero proportion notably higher non-inflated model extra π=0.3\\pi = 0.3 point mass.","code":"set.seed(42)  sigma_true <- 2 xi_true    <- 0.1 kappa_true <- 1.5 pi_true    <- 0.3  y <- rzidiscegpd(1000, pi = pi_true, sigma = sigma_true,                   xi = xi_true, kappa = kappa_true, type = 1)  cat(\"Range:\", range(y), \"\\n\") #> Range: 0 27 cat(\"Mean:\", round(mean(y), 2), \"  Var:\", round(var(y), 2), \"\\n\") #> Mean: 1.72   Var: 7.42 cat(\"Proportion zeros:\", mean(y == 0), \"\\n\") #> Proportion zeros: 0.477 barplot(table(y) / length(y), main = \"Simulated ZIDEGPD data\",         xlab = \"y\", ylab = \"Proportion\", col = \"lightblue\", border = \"grey\") fit_zi <- fitegpd(y, type = 1, family = \"zidegpd\") summary(fit_zi) #> Fitting of the distribution 'zidegpd' (type 1) #> Method: mle #>  #> Estimated parameters: #>       Estimate Std. Error z value Pr(>|z|)     #> sigma  1.75201    0.45741   3.830 0.000128 *** #> xi     0.15800    0.07385   2.140 0.032389 *   #> kappa  1.97969    0.84112   2.354 0.018590 *   #> pi     0.36187    0.05998   6.034  1.6e-09 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Convergence:  successful  #> Loglikelihood:  -1745.38   AIC:  3498.76   BIC:  3518.39  #> Number of observations:  1000"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"parameter-recovery-1","dir":"Articles","previous_headings":"2. Zero-Inflated Discrete EGPD","what":"Parameter recovery","title":"Fitting Discrete Distributions with fitegpd","text":"","code":"truth <- c(sigma = sigma_true, xi = xi_true,            kappa = kappa_true, pi = pi_true) est <- fit_zi$estimate cbind(true = truth, estimate = round(est, 4),       SE = round(fit_zi$sd, 4)) #>       true estimate     SE #> sigma  2.0   1.7520 0.4574 #> xi     0.1   0.1580 0.0738 #> kappa  1.5   1.9797 0.8411 #> pi     0.3   0.3619 0.0600"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"diagnostics-1","dir":"Articles","previous_headings":"2. Zero-Inflated Discrete EGPD","what":"Diagnostics","title":"Fitting Discrete Distributions with fitegpd","text":"","code":"plot(fit_zi)"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"confidence-intervals-1","dir":"Articles","previous_headings":"2. Zero-Inflated Discrete EGPD","what":"Confidence intervals","title":"Fitting Discrete Distributions with fitegpd","text":"","code":"confint(fit_zi) #>            2.5 %    97.5 % #> sigma 0.85549768 2.6485174 #> xi    0.01326359 0.3027374 #> kappa 0.33113076 3.6282584 #> pi    0.24431952 0.4794218"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"comparing-degpd-and-zidegpd","dir":"Articles","previous_headings":"","what":"3. Comparing DEGPD and ZIDEGPD","title":"Fitting Discrete Distributions with fitegpd","text":"faced zero-heavy count data, natural question whether zero inflation needed whether base DEGPD already accounts zeros adequately. can compare two models AIC.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"fitting-both-models-to-zero-inflated-data","dir":"Articles","previous_headings":"3. Comparing DEGPD and ZIDEGPD","what":"Fitting both models to zero-inflated data","title":"Fitting Discrete Distributions with fitegpd","text":"Since data generated π=0.3\\pi = 0.3, zero-inflated model substantially lower AIC.","code":"fit_no_zi <- fitegpd(y, type = 1, family = \"degpd\") fit_with_zi <- fit_zi  # already fitted above  cat(\"DEGPD AIC:   \", AIC(fit_no_zi), \"\\n\") #> DEGPD AIC:    3503.567 cat(\"ZIDEGPD AIC: \", AIC(fit_with_zi), \"\\n\") #> ZIDEGPD AIC:  3498.756"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"fitting-both-models-to-non-inflated-data","dir":"Articles","previous_headings":"3. Comparing DEGPD and ZIDEGPD","what":"Fitting both models to non-inflated data","title":"Fitting Discrete Distributions with fitegpd","text":"Conversely, data excess zeros, extra π\\pi parameter help: estimated π\\pi near zero ZIDEGPD AIC slightly higher (penalised extra parameter).","code":"fit_degpd_on_x <- fit_degpd  # fitted to non-inflated x above fit_zi_on_x <- fitegpd(x, type = 1, family = \"zidegpd\")  cat(\"DEGPD AIC:   \", AIC(fit_degpd_on_x), \"\\n\") #> DEGPD AIC:    4920.769 cat(\"ZIDEGPD AIC: \", AIC(fit_zi_on_x), \"\\n\") #> ZIDEGPD AIC:  4922.401 cat(\"Estimated pi:\", round(fit_zi_on_x$estimate[\"pi\"], 4), \"\\n\") #> Estimated pi: 0.0278"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"higher-order-types","dir":"Articles","previous_headings":"","what":"4. Higher-order types","title":"Fitting Discrete Distributions with fitegpd","text":"Types 5 6 provide additional flexibility. Type 5 δ\\delta κ\\kappa parameters; Type 6 adds mixing probability pp.","code":"set.seed(99) x5 <- rdiscegpd(1000, sigma = 2, xi = 0.1, delta = 1.2,                  kappa = 1.8, type = 5) fit5 <- fitegpd(x5, type = 5, family = \"degpd\") summary(fit5) #> Fitting of the distribution 'degpd' (type 5) #> Method: mle #>  #> Estimated parameters: #>       Estimate Std. Error z value Pr(>|z|)     #> sigma  1.63595    0.60546   2.702  0.00689 **  #> xi     0.15591    0.03919   3.978 6.94e-05 *** #> delta  0.41132    0.97364   0.422  0.67269     #> kappa  1.65941    0.15856  10.466  < 2e-16 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Convergence:  successful  #> Loglikelihood:  -2117.78   AIC:  4243.56   BIC:  4263.19  #> Number of observations:  1000 plot(fit5)"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"the-model-2","dir":"Articles","previous_headings":"5. Compound Poisson-Discrete EGPD","what":"The model","title":"Fitting Discrete Distributions with fitegpd","text":"Compound Poisson-Discrete EGPD (family = \"cpdegpd\") models aggregate sum S=X1+⋯+XNS = X_1 + \\cdots + X_N N∼Poisson(λ)N \\sim \\mathrm{Poisson}(\\lambda) random number events, Xi∼Discrete-EGPD(σ,ξ,κ,…)X_i \\sim \\mathrm{Discrete\\text{-}EGPD}(\\sigma, \\xi, \\kappa, \\ldots) ..d. non-negative integer severities. Since individual claims already integer-valued, Panjer recursion computes exact compound distribution {0,1,2,…}\\{0, 1, 2, \\ldots\\} — discretization step needed bin-width parameter h tune (unlike family = \"cpegpd\").","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"simulating-and-fitting-2","dir":"Articles","previous_headings":"5. Compound Poisson-Discrete EGPD","what":"Simulating and fitting","title":"Fitting Discrete Distributions with fitegpd","text":"","code":"set.seed(42)  sigma_true  <- 3 xi_true     <- 0.1 kappa_true  <- 1.5 lambda_true <- 2  z <- rcpdegpd(500, sigma = sigma_true, xi = xi_true,                kappa = kappa_true, lambda = lambda_true, type = 1)  cat(\"Range:\", range(z), \"\\n\") #> Range: 0 43 cat(\"Mean:\", round(mean(z), 2), \"  Var:\", round(var(z), 2), \"\\n\") #> Mean: 7.03   Var: 61.4 cat(\"Proportion zeros:\", mean(z == 0), \"\\n\") #> Proportion zeros: 0.214 barplot(table(z) / length(z), main = \"Simulated CPDEGPD data\",         xlab = \"z\", ylab = \"Proportion\", col = \"lightblue\", border = \"grey\") fit_cpdegpd <- fitegpd(z, type = 1, family = \"cpdegpd\") summary(fit_cpdegpd) #> Fitting of the distribution 'cpdegpd' (type 1) #> Method: mle #>  #> Estimated parameters: #>        Estimate Std. Error z value Pr(>|z|)     #> sigma    2.7440     1.1024   2.489   0.0128 *   #> xi       0.1482     0.1137   1.303   0.1924     #> kappa    1.6625     1.0139   1.640   0.1011     #> lambda   1.7767     0.2376   7.477  7.6e-14 *** #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 #>  #> Convergence:  successful  #> Loglikelihood:  -1488.58   AIC:  2985.17   BIC:  3002.02  #> Number of observations:  500"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"parameter-recovery-2","dir":"Articles","previous_headings":"5. Compound Poisson-Discrete EGPD","what":"Parameter recovery","title":"Fitting Discrete Distributions with fitegpd","text":"","code":"truth <- c(sigma = sigma_true, xi = xi_true,            kappa = kappa_true, lambda = lambda_true) est <- fit_cpdegpd$estimate cbind(true = truth, estimate = round(est, 4),       SE = round(fit_cpdegpd$sd, 4)) #>        true estimate     SE #> sigma   3.0   2.7440 1.1024 #> xi      0.1   0.1482 0.1137 #> kappa   1.5   1.6625 1.0139 #> lambda  2.0   1.7767 0.2376"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"diagnostics-2","dir":"Articles","previous_headings":"5. Compound Poisson-Discrete EGPD","what":"Diagnostics","title":"Fitting Discrete Distributions with fitegpd","text":"diagnostic plots use discrete-style panels: barplot fitted PMF points, step-function CDF, randomized PIT-based Q-Q P-P plots.","code":"plot(fit_cpdegpd)"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"comparing-with-plain-degpd-on-the-same-data","dir":"Articles","previous_headings":"5. Compound Poisson-Discrete EGPD","what":"Comparing with plain DEGPD on the same data","title":"Fitting Discrete Distributions with fitegpd","text":"Since cpdegpd compound sum model degpd single-event model, can compare AIC data see fits better: compound model fit noticeably better data-generating process truly involves random summation.","code":"fit_degpd_on_z <- fitegpd(z, type = 1, family = \"degpd\")  cat(\"DEGPD AIC:   \", AIC(fit_degpd_on_z), \"\\n\") #> DEGPD AIC:    2995.597 cat(\"CPDEGPD AIC: \", AIC(fit_cpdegpd), \"\\n\") #> CPDEGPD AIC:  2985.166"},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"practical-guidelines","dir":"Articles","previous_headings":"","what":"6. Practical guidelines","title":"Fitting Discrete Distributions with fitegpd","text":"Choosing DEGPD ZIDEGPD. Start family = \"degpd\". diagnostic plots show model underestimates zero probability, refit family = \"zidegpd\" compare AIC. Choosing type. Fit several types compare AIC. Types 1 4 three parameters good defaults. Type 5 (four parameters) Type 6 (five parameters) offer flexibility need larger samples. Starting values. automatic starting values work well cases. difficult datasets (e.g. heavy tails), supply custom start values via start = list(sigma = ..., xi = ...). Fixed parameters. Use fix.arg external information available — e.g. fix.arg = list(xi = 0) exponential tail.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/fitegpd-discrete.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Fitting Discrete Distributions with fitegpd","text":"families: Return S3 objects class \"fitegpd\" interface (summary, plot, AIC, confint, coef, vcov, logLik) Support fix.arg fixing parameters known values Estimate standard errors via delta method Hessian Provide four-panel diagnostic plots tailored discrete data (bar plots PMF, step functions CDF, randomized PIT-based Q-Q P-P plots)","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Threshold Exceedance Modeling with DEGPD","text":"","code":"library(egpd) data(nsw_offenses) str(nsw_offenses) #> 'data.frame':    342 obs. of  1 variable: #>  $ offenses: int  3 3 6 8 4 7 5 2 3 4 ... d <- nsw_offenses$offenses plot(table(d), main = \"Gaming and betting offenses (NSW)\",      xlab = \"Number of offenses\", ylab = \"Frequency\") cat(\"n =\", length(d), \" range:\", range(d), \"\\n\") #> n = 342  range: 0 88"},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"threshold-selection","dir":"Articles","previous_headings":"","what":"Threshold selection","title":"Threshold Exceedance Modeling with DEGPD","text":"extreme value analysis, model observations exceed chosen threshold. choice threshold involves bias–variance trade-: higher threshold gives better model fit fewer observations. demonstrate two threshold choices: 10th 20th percentiles.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"threshold-at-10th-percentile","dir":"Articles","previous_headings":"Threshold selection","what":"Threshold at 10th percentile","title":"Threshold Exceedance Modeling with DEGPD","text":"","code":"u10 <- floor(quantile(d, 0.10)) cat(\"Threshold u (10th percentile):\", u10, \"\\n\") #> Threshold u (10th percentile): 1 y10 <- d[d >= u10] - u10 cat(\"Exceedances: n =\", length(y10), \"\\n\") #> Exceedances: n = 328  hist(y10, breaks = 50, col = \"lightblue\", border = \"white\",      main = paste0(\"Threshold exceedances (u = \", u10, \")\"),      xlab = \"Excess count\", ylab = \"Frequency\")"},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"fitting-degpd-models-to-the-10th-percentile-exceedances","dir":"Articles","previous_headings":"Threshold selection","what":"Fitting DEGPD models to the 10th-percentile exceedances","title":"Threshold Exceedance Modeling with DEGPD","text":"","code":"df10 <- data.frame(y = y10, x = rep(1, length(y10)))  fit10_m1 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df10, family = \"degpd\", degpd.args = list(m = 1))  fit10_m2 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa1 = ~ 1, ldkappa = ~ 1,                       logitp = ~ 1),                  data = df10, family = \"degpd\", degpd.args = list(m = 2)) #> Final Hessian of negative penalized log-likelihood not numerically positive definite.  fit10_m3 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, ldelta = ~ 1),                  data = df10, family = \"degpd\", degpd.args = list(m = 3))  fit10_m4 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, ldelta = ~ 1, lkappa = ~ 1),                  data = df10, family = \"degpd\", degpd.args = list(m = 4))  fit10_m5 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df10, family = \"degpd\", degpd.args = list(m = 5))  fit10_m6 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df10, family = \"degpd\", degpd.args = list(m = 6))  aic10 <- data.frame(   Model = c(\"DEGPD-1\", \"DEGPD-2\", \"DEGPD-3\", \"DEGPD-4\", \"DEGPD-5\", \"DEGPD-6\"),   npar = c(3, 5, 3, 4, 3, 3),   logLik = c(logLik(fit10_m1), logLik(fit10_m2), logLik(fit10_m3),              logLik(fit10_m4), logLik(fit10_m5), logLik(fit10_m6)),   AIC = c(AIC(fit10_m1), AIC(fit10_m2), AIC(fit10_m3),           AIC(fit10_m4), AIC(fit10_m5), AIC(fit10_m6)) ) aic10 #>     Model npar    logLik      AIC #> 1 DEGPD-1    3 -1126.689 2259.378 #> 2 DEGPD-2    5 -1128.527 2267.054 #> 3 DEGPD-3    3 -1126.477 2258.955 #> 4 DEGPD-4    4 -1126.537 2261.075 #> 5 DEGPD-5    3 -1126.936 2259.872 #> 6 DEGPD-6    3 -1126.736 2259.472 summary(fit10_m1) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     2.26       0.17   13.38   <2e-16 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -2.23       0.84   -2.66  0.00391 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.08       0.12     0.7    0.243 #>  #> ** Smooth terms **"},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"threshold-at-20th-percentile","dir":"Articles","previous_headings":"Threshold selection","what":"Threshold at 20th percentile","title":"Threshold Exceedance Modeling with DEGPD","text":"","code":"u20 <- floor(quantile(d, 0.20)) cat(\"Threshold u (20th percentile):\", u20, \"\\n\") #> Threshold u (20th percentile): 3 y20 <- d[d >= u20] - u20 cat(\"Exceedances: n =\", length(y20), \"\\n\") #> Exceedances: n = 274  hist(y20, breaks = 50, col = \"lightblue\", border = \"white\",      main = paste0(\"Threshold exceedances (u = \", u20, \")\"),      xlab = \"Excess count\", ylab = \"Frequency\") df20 <- data.frame(y = y20, x = rep(1, length(y20)))  fit20_m1 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df20, family = \"degpd\", degpd.args = list(m = 1))  fit20_m2 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa1 = ~ 1, ldkappa = ~ 1,                       logitp = ~ 1),                  data = df20, family = \"degpd\", degpd.args = list(m = 2)) #> Final Hessian of negative penalized log-likelihood not numerically positive definite.  fit20_m3 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, ldelta = ~ 1),                  data = df20, family = \"degpd\", degpd.args = list(m = 3))  fit20_m4 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, ldelta = ~ 1, lkappa = ~ 1),                  data = df20, family = \"degpd\", degpd.args = list(m = 4))  fit20_m5 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df20, family = \"degpd\", degpd.args = list(m = 5)) #> Final Hessian of negative penalized log-likelihood not numerically positive definite.  fit20_m6 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df20, family = \"degpd\", degpd.args = list(m = 6))  aic20 <- data.frame(   Model = c(\"DEGPD-1\", \"DEGPD-2\", \"DEGPD-3\", \"DEGPD-4\", \"DEGPD-5\", \"DEGPD-6\"),   npar = c(3, 5, 3, 4, 3, 3),   logLik = c(logLik(fit20_m1), logLik(fit20_m2), logLik(fit20_m3),              logLik(fit20_m4), logLik(fit20_m5), logLik(fit20_m6)),   AIC = c(AIC(fit20_m1), AIC(fit20_m2), AIC(fit20_m3),           AIC(fit20_m4), AIC(fit20_m5), AIC(fit20_m6)) ) aic20 #>     Model npar    logLik      AIC #> 1 DEGPD-1    3 -942.2068 1890.414 #> 2 DEGPD-2    5 -944.0447 1898.089 #> 3 DEGPD-3    3 -941.1046 1888.209 #> 4 DEGPD-4    4 -940.8346 1889.669 #> 5 DEGPD-5    3 -942.4606 1890.921 #> 6 DEGPD-6    3 -942.3979 1890.796"},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"","what":"Goodness of fit","title":"Threshold Exceedance Modeling with DEGPD","text":"","code":"# Fitted parameters for the 10th-percentile model 1 pars <- predict(fit10_m1, type = \"response\") sigma <- pars$scale[1]; xi <- pars$shape[1]; kappa <- pars$kappa[1]  xvals <- 0:max(y10) emp_pmf <- tabulate(y10 + 1, nbins = max(xvals) + 1) / length(y10) fit_pmf <- ddiscegpd(xvals, sigma = sigma, xi = xi, kappa = kappa, type = 1)  plot(xvals[1:40], emp_pmf[1:40], type = \"h\", lwd = 2, col = \"grey60\",      main = \"Empirical vs fitted PMF (DEGPD-1, u = 10th pctl)\",      xlab = \"Excess count\", ylab = \"Probability\") lines(xvals[1:40] + 0.2, fit_pmf[1:40], type = \"h\", lwd = 2, col = \"steelblue\") legend(\"topright\", legend = c(\"Empirical\", \"DEGPD-1\"),        col = c(\"grey60\", \"steelblue\"), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"q-q-plots","dir":"Articles","previous_headings":"","what":"Q-Q plots","title":"Threshold Exceedance Modeling with DEGPD","text":"Randomized quantile residuals 10th-percentile exceedance models:  20th-percentile exceedance models:","code":"set.seed(1) par(mfrow = c(3, 2))  r10_1 <- rqresid(fit10_m1) qqnorm(r10_1, main = \"Q-Q Plot (DEGPD-1, u = 10th pctl)\", pch = 20, col = \"grey60\") qqline(r10_1, col = \"red\")  r10_2 <- rqresid(fit10_m2) qqnorm(r10_2, main = \"Q-Q Plot (DEGPD-2, u = 10th pctl)\", pch = 20, col = \"grey60\") qqline(r10_2, col = \"red\")  r10_3 <- rqresid(fit10_m3) qqnorm(r10_3, main = \"Q-Q Plot (DEGPD-3, u = 10th pctl)\", pch = 20, col = \"grey60\") qqline(r10_3, col = \"red\")  r10_4 <- rqresid(fit10_m4) qqnorm(r10_4, main = \"Q-Q Plot (DEGPD-4, u = 10th pctl)\", pch = 20, col = \"grey60\") qqline(r10_4, col = \"red\")  r10_5 <- rqresid(fit10_m5) qqnorm(r10_5, main = \"Q-Q Plot (DEGPD-5, u = 10th pctl)\", pch = 20, col = \"grey60\") qqline(r10_5, col = \"red\")  r10_6 <- rqresid(fit10_m6) #> Warning in qnorm(u): NaNs produced qqnorm(r10_6, main = \"Q-Q Plot (DEGPD-6, u = 10th pctl)\", pch = 20, col = \"grey60\") qqline(r10_6, col = \"red\") par(mfrow = c(1, 1)) set.seed(1) par(mfrow = c(3, 2))  r20_1 <- rqresid(fit20_m1) qqnorm(r20_1, main = \"Q-Q Plot (DEGPD-1, u = 20th pctl)\", pch = 20, col = \"grey60\") qqline(r20_1, col = \"red\")  r20_2 <- rqresid(fit20_m2) qqnorm(r20_2, main = \"Q-Q Plot (DEGPD-2, u = 20th pctl)\", pch = 20, col = \"grey60\") qqline(r20_2, col = \"red\")  r20_3 <- rqresid(fit20_m3) qqnorm(r20_3, main = \"Q-Q Plot (DEGPD-3, u = 20th pctl)\", pch = 20, col = \"grey60\") qqline(r20_3, col = \"red\")  r20_4 <- rqresid(fit20_m4) qqnorm(r20_4, main = \"Q-Q Plot (DEGPD-4, u = 20th pctl)\", pch = 20, col = \"grey60\") qqline(r20_4, col = \"red\")  r20_5 <- rqresid(fit20_m5) qqnorm(r20_5, main = \"Q-Q Plot (DEGPD-5, u = 20th pctl)\", pch = 20, col = \"grey60\") qqline(r20_5, col = \"red\")  r20_6 <- rqresid(fit20_m6) #> Warning in qnorm(u): NaNs produced qqnorm(r20_6, main = \"Q-Q Plot (DEGPD-6, u = 20th pctl)\", pch = 20, col = \"grey60\") qqline(r20_6, col = \"red\") par(mfrow = c(1, 1))"},{"path":"https://sdwfrost.github.io/egpd/articles/gaming-offenses.html","id":"threshold-sensitivity","dir":"Articles","previous_headings":"","what":"Threshold sensitivity","title":"Threshold Exceedance Modeling with DEGPD","text":"Comparing fitted parameters across thresholds gives insight model stability.","code":"p10 <- predict(fit10_m1, type = \"response\")[1, ] p20 <- predict(fit20_m1, type = \"response\")[1, ] rbind(\"u = 10th pctl\" = unlist(p10), \"u = 20th pctl\" = unlist(p20)) #>                  scale     shape    kappa #> u = 10th pctl 9.603810 0.1075324 1.085790 #> u = 20th pctl 9.270029 0.1345322 1.100231"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"parameter-mapping","dir":"Articles","previous_headings":"","what":"Parameter Mapping","title":"Comparing egpd and gamlss Fits","text":"gamlss framework uses standard parameter names (mu, sigma, nu, tau). map EGPD parameters follows:","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"fitting-notes","dir":"Articles","previous_headings":"","what":"Fitting notes","title":"Comparing egpd and gamlss Fits","text":"gamlss convergence: EGPD families use numerical derivatives, can require iterations gamlss default (n.cyc = 20). recommend setting n.cyc = 200 via gamlss.control() ensure convergence. Penalised vs raw log-likelihood: egpd() uses penalised likelihood estimation (mgcv), logLik() egpd object returns penalised log-likelihood, slightly lower raw log-likelihood. gamlss logLik() returns raw log-likelihood. Despite difference objective function, approaches recover similar parameter estimates.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"discrete-egpd-model-1","dir":"Articles","previous_headings":"","what":"Discrete EGPD Model 1","title":"Comparing egpd and gamlss Fits","text":"simulate discrete EGPD G(u) = u^kappa fit using egpd() (penalised likelihood via GAM) gamlss() (DEGPD1() family).","code":"library(egpd) library(gamlss) #> Loading required package: splines #> Loading required package: gamlss.data #>  #> Attaching package: 'gamlss.data' #> The following object is masked from 'package:datasets': #>  #>     sleep #> Loading required package: gamlss.dist #> Loading required package: nlme #> Loading required package: parallel #>  **********   GAMLSS Version 5.5-0  ********** #> For more on GAMLSS look at https://www.gamlss.com/ #> Type gamlssNews() to see new features/changes/bug fixes.  set.seed(99) sigma_true <- 3 xi_true    <- 0.15 kappa_true <- 2 n <- 2000  y <- rdiscegpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y) cat(\"Range of y:\", range(y), \"\\n\") #> Range of y: 0 147"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"egpd-fit","dir":"Articles","previous_headings":"Discrete EGPD Model 1","what":"egpd fit","title":"Comparing egpd and gamlss Fits","text":"","code":"fit_egpd <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df, family = \"degpd\", degpd.args = list(m = 1)) pars_egpd <- predict(fit_egpd, type = \"response\")[1, ]"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"gamlss-fit","dir":"Articles","previous_headings":"Discrete EGPD Model 1","what":"gamlss fit","title":"Comparing egpd and gamlss Fits","text":"","code":"fit_gamlss <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                      data = df, family = DEGPD1(),                      control = gamlss.control(n.cyc = 200, trace = FALSE))"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"comparison","dir":"Articles","previous_headings":"Discrete EGPD Model 1","what":"Comparison","title":"Comparing egpd and gamlss Fits","text":"approaches recover similar parameter estimates discrete model.","code":"mu_g    <- exp(coef(fit_gamlss, what = \"mu\")) sigma_g <- exp(coef(fit_gamlss, what = \"sigma\")) nu_g    <- exp(coef(fit_gamlss, what = \"nu\"))  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\"),   true      = c(sigma_true, xi_true, kappa_true),   egpd      = round(as.numeric(unlist(pars_egpd)), 4),   gamlss    = round(c(mu_g, sigma_g, nu_g), 4),   row.names = NULL ) #>   parameter true   egpd gamlss #> 1     sigma 3.00 2.7332 2.7205 #> 2        xi 0.15 0.1974 0.1989 #> 3     kappa 2.00 2.1228 2.1310"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"zero-inflated-discrete-egpd-model-1","dir":"Articles","previous_headings":"","what":"Zero-Inflated Discrete EGPD Model 1","title":"Comparing egpd and gamlss Fits","text":"ZIDEGPD1() family supports zero-inflated discrete EGPD models via gamlss. compare egpd() gamlss() simulated data excess zeros.","code":"set.seed(77) sigma_true <- 3 xi_true    <- 0.15 kappa_true <- 2 pi_true    <- 0.25 n <- 2000  y <- rzidiscegpd(n, pi = pi_true, sigma = sigma_true, xi = xi_true,                  kappa = kappa_true, type = 1) df <- data.frame(y = y) cat(\"Proportion of zeros:\", mean(y == 0), \"\\n\") #> Proportion of zeros: 0.292"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"egpd-fit-1","dir":"Articles","previous_headings":"Zero-Inflated Discrete EGPD Model 1","what":"egpd fit","title":"Comparing egpd and gamlss Fits","text":"","code":"fit_zidegpd <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1, logitpi = ~ 1),                     data = df, family = \"zidegpd\", zidegpd.args = list(m = 1)) pars_zidegpd <- predict(fit_zidegpd, type = \"response\")[1, ]"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"gamlss-fit-1","dir":"Articles","previous_headings":"Zero-Inflated Discrete EGPD Model 1","what":"gamlss fit","title":"Comparing egpd and gamlss Fits","text":"","code":"fit_zi_gamlss <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                         tau.formula = ~ 1, data = df, family = ZIDEGPD1(),                         control = gamlss.control(n.cyc = 200, trace = FALSE))"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"comparison-1","dir":"Articles","previous_headings":"Zero-Inflated Discrete EGPD Model 1","what":"Comparison","title":"Comparing egpd and gamlss Fits","text":"fitting approaches recover four parameters zero-inflated discrete model.","code":"mu_zg    <- exp(coef(fit_zi_gamlss, what = \"mu\")) sigma_zg <- exp(coef(fit_zi_gamlss, what = \"sigma\")) nu_zg    <- exp(coef(fit_zi_gamlss, what = \"nu\")) tau_zg   <- plogis(coef(fit_zi_gamlss, what = \"tau\"))  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\", \"pi\"),   true      = c(sigma_true, xi_true, kappa_true, pi_true),   egpd      = round(as.numeric(unlist(pars_zidegpd)), 4),   gamlss    = round(c(mu_zg, sigma_zg, nu_zg, tau_zg), 4),   row.names = NULL ) #>   parameter true   egpd gamlss #> 1     sigma 3.00 3.0878 3.0460 #> 2        xi 0.15 0.1465 0.1505 #> 3     kappa 2.00 1.7892 1.8202 #> 4        pi 0.25 0.2161 0.2178"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"continuous-egpd-model-1","dir":"Articles","previous_headings":"","what":"Continuous EGPD Model 1","title":"Comparing egpd and gamlss Fits","text":"also demonstrate continuous EGPD family.","code":"set.seed(42) sigma_true <- 2 xi_true    <- 0.2 kappa_true <- 1.5 n <- 2000  y <- regpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y, x = rep(1, n))"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"egpd-fit-2","dir":"Articles","previous_headings":"Continuous EGPD Model 1","what":"egpd fit","title":"Comparing egpd and gamlss Fits","text":"","code":"fit_egpd_c <- egpd(list(lpsi = y ~ 1, xi = ~ 1, lkappa = ~ 1),                    data = df, family = \"egpd\", egpd.args = list(m = 1)) pars_egpd_c <- predict(fit_egpd_c, type = \"response\")[1, ]"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"gamlss-fit-2","dir":"Articles","previous_headings":"Continuous EGPD Model 1","what":"gamlss fit","title":"Comparing egpd and gamlss Fits","text":"","code":"fit_gamlss_c <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                        data = df, family = EGPD1(),                        control = gamlss.control(n.cyc = 200, trace = FALSE))"},{"path":"https://sdwfrost.github.io/egpd/articles/gamlss-comparison.html","id":"comparison-2","dir":"Articles","previous_headings":"Continuous EGPD Model 1","what":"Comparison","title":"Comparing egpd and gamlss Fits","text":"approaches recover similar estimates continuous model well.","code":"mu_gc    <- exp(coef(fit_gamlss_c, what = \"mu\")) sigma_gc <- exp(coef(fit_gamlss_c, what = \"sigma\")) nu_gc    <- exp(coef(fit_gamlss_c, what = \"nu\"))  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\"),   true      = c(sigma_true, xi_true, kappa_true),   egpd      = round(as.numeric(unlist(pars_egpd_c)), 4),   gamlss    = round(c(mu_gc, sigma_gc, nu_gc), 4),   row.names = NULL ) #>   parameter true   egpd gamlss #> 1     sigma  2.0 2.0957 2.0900 #> 2        xi  0.2 0.1933 0.1943 #> 3     kappa  1.5 1.3904 1.3928"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"response variable number upheld complaints per insurer per year. non-negative integer counts heavy right tail.","code":"library(egpd) data(ny_complaints) str(ny_complaints) #> 'data.frame':    1942 obs. of  4 variables: #>  $ year    : int  2020 2020 2020 2020 2020 2020 2020 2020 2020 2020 ... #>  $ upheld  : int  0 0 0 0 0 0 0 0 0 0 ... #>  $ total   : int  20 2 13 5 0 4 5 5 3 5 ... #>  $ premiums: num  107.1 65 63.5 53.2 43.8 ... y <- ny_complaints$upheld plot(table(y[y <= 30]), main = \"Upheld insurance complaints (NY)\",      xlab = \"Number of upheld complaints\", ylab = \"Frequency\") cat(\"n =\", length(y), \" range:\", range(y), \"\\n\") #> n = 1942  range: 0 265"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"fitting-degpd-models","dir":"Articles","previous_headings":"","what":"Fitting DEGPD models","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"egpd() function fits DEGPD models within GAM framework. intercept-models (covariates), parameter gets ~ 1 formula. DEGPD family uses log link scale (sigma) shape (xi) parameters, fitted coefficients log scale.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"degpd-model-1-power-transformation","dir":"Articles","previous_headings":"Fitting DEGPD models","what":"DEGPD Model 1: Power transformation","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"Model 1 uses G(u) = u^kappa three parameters: sigma, xi, kappa.","code":"df <- data.frame(y = y, x = rep(1, length(y))) fit1 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),              data = df, family = \"degpd\", degpd.args = list(m = 1)) summary(fit1) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.23       0.27   -0.85    0.198 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.32       0.08   -4.06 2.44e-05 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.35       0.22    1.57    0.058 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit1), \"\\n\") #> Log-likelihood: -3645.223 cat(\"AIC:\", AIC(fit1), \"\\n\") #> AIC: 7296.447"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"degpd-model-2-mixture-of-power-transformations","dir":"Articles","previous_headings":"Fitting DEGPD models","what":"DEGPD Model 2: Mixture of power transformations","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"Model 2 uses G(u) = p·u^kappa1 + (1-p)·u^kappa2 five parameters: sigma, xi, kappa1, dkappa, p.","code":"fit2 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa1 = ~ 1, ldkappa = ~ 1,                   logitp = ~ 1),              data = df, family = \"degpd\", degpd.args = list(m = 2)) #> Final Hessian of negative penalized log-likelihood not numerically positive definite. summary(fit2) #> Warning in sqrt(obj$Vp[cbind(id2, id2)]): NaNs produced #> Warning in sqrt(obj$Vp[cbind(id2, id2)]): NaNs produced #> Warning in sqrt(obj$Vp[cbind(id2, id2)]): NaNs produced #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)   -13.18        NaN     NaN      NaN #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.24       0.03   -8.11 2.63e-16 #>  #> logkappa1 #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     3.66        NaN     NaN      NaN #>  #> logdkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     16.9        NaN     NaN      NaN #>  #> logitp #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.58       0.12    -4.7 1.32e-06 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit2), \"\\n\") #> Log-likelihood: -3646.202 cat(\"AIC:\", AIC(fit2), \"\\n\") #> AIC: 7302.405"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"degpd-model-3-incomplete-beta-transformation","dir":"Articles","previous_headings":"Fitting DEGPD models","what":"DEGPD Model 3: Incomplete beta transformation","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"Model 3 uses incomplete beta transformation three parameters: sigma, xi, delta.","code":"fit3 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, ldelta = ~ 1),              data = df, family = \"degpd\", degpd.args = list(m = 3)) summary(fit3) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.02       0.15   -0.15    0.439 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.34       0.08   -4.29 8.93e-06 #>  #> logdelta #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     2.02       0.73    2.75  0.00295 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit3), \"\\n\") #> Log-likelihood: -3645.448 cat(\"AIC:\", AIC(fit3), \"\\n\") #> AIC: 7296.895"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"degpd-model-4-power-beta-transformation","dir":"Articles","previous_headings":"Fitting DEGPD models","what":"DEGPD Model 4: Power-beta transformation","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"Model 4 combines incomplete beta power transformations four parameters: sigma, xi, delta, kappa.","code":"fit4 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, ldelta = ~ 1, lkappa = ~ 1),              data = df, family = \"degpd\", degpd.args = list(m = 4)) summary(fit4) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.22       0.28   -0.77    0.221 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.32       0.08   -4.05  2.6e-05 #>  #> logdelta #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     4.52       7.23    0.62    0.266 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.02       0.28    3.62 0.000146 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit4), \"\\n\") #> Log-likelihood: -3646.155 cat(\"AIC:\", AIC(fit4), \"\\n\") #> AIC: 7300.31"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"degpd-model-5-truncated-normal-transformation","dir":"Articles","previous_headings":"Fitting DEGPD models","what":"DEGPD Model 5: Truncated normal transformation","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"Model 5 uses truncated normal G-transformation three parameters: sigma, xi, kappa.","code":"fit5 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),              data = df, family = \"degpd\", degpd.args = list(m = 5)) summary(fit5) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     -0.2       0.21   -0.94    0.175 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.31       0.08   -3.95 3.91e-05 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.65       0.59    1.11    0.133 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit5), \"\\n\") #> Log-likelihood: -3645.066 cat(\"AIC:\", AIC(fit5), \"\\n\") #> AIC: 7296.131"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"degpd-model-6-truncated-beta-transformation","dir":"Articles","previous_headings":"Fitting DEGPD models","what":"DEGPD Model 6: Truncated beta transformation","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"Model 6 uses truncated beta G-transformation three parameters: sigma, xi, kappa.","code":"fit6 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),              data = df, family = \"degpd\", degpd.args = list(m = 6)) summary(fit6) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.13       0.19   -0.68    0.249 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.32       0.08   -4.09 2.16e-05 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.45       0.24    1.86   0.0317 #>  #> ** Smooth terms ** cat(\"Log-likelihood:\", logLik(fit6), \"\\n\") #> Log-likelihood: -3645.199 cat(\"AIC:\", AIC(fit6), \"\\n\") #> AIC: 7296.398"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"model-comparison","dir":"Articles","previous_headings":"","what":"Model comparison","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"","code":"aic_table <- data.frame(   Model = c(\"DEGPD-1\", \"DEGPD-2\", \"DEGPD-3\", \"DEGPD-4\", \"DEGPD-5\", \"DEGPD-6\"),   npar = c(3, 5, 3, 4, 3, 3),   logLik = c(logLik(fit1), logLik(fit2), logLik(fit3), logLik(fit4),              logLik(fit5), logLik(fit6)),   AIC = c(AIC(fit1), AIC(fit2), AIC(fit3), AIC(fit4),           AIC(fit5), AIC(fit6)) ) aic_table #>     Model npar    logLik      AIC #> 1 DEGPD-1    3 -3645.223 7296.447 #> 2 DEGPD-2    5 -3646.202 7302.405 #> 3 DEGPD-3    3 -3645.448 7296.895 #> 4 DEGPD-4    4 -3646.155 7300.310 #> 5 DEGPD-5    3 -3645.066 7296.131 #> 6 DEGPD-6    3 -3645.199 7296.398"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"","what":"Goodness of fit","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"can assess model fit comparing empirical fitted PMFs.","code":"# Extract fitted parameters on the response scale pars1 <- predict(fit1, type = \"response\") sigma1 <- pars1$scale[1]; xi1 <- pars1$shape[1]; kappa1 <- pars1$kappa[1]  xvals <- 0:30 emp_pmf <- tabulate(y + 1, nbins = max(xvals) + 1) / length(y) emp_pmf <- emp_pmf[seq_along(xvals)]  fit_pmf1 <- ddiscegpd(xvals, sigma = sigma1, xi = xi1, kappa = kappa1, type = 1)  plot(xvals, emp_pmf, type = \"h\", lwd = 2, col = \"grey60\",      main = \"Empirical vs fitted PMF (DEGPD-1)\",      xlab = \"Count\", ylab = \"Probability\") lines(xvals + 0.2, fit_pmf1, type = \"h\", lwd = 2, col = \"steelblue\") legend(\"topright\", legend = c(\"Empirical\", \"DEGPD-1\"),        col = c(\"grey60\", \"steelblue\"), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"q-q-plots","dir":"Articles","previous_headings":"","what":"Q-Q plots","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"Randomized quantile residuals provide model-agnostic diagnostic: model correct, residuals follow standard normal distribution. rqresid() function computes drawing uniform variate lower upper CDF bounds observation transforming normal scale.","code":"set.seed(1) par(mfrow = c(3, 2))  r1 <- rqresid(fit1) qqnorm(r1, main = \"Q-Q Plot (DEGPD-1)\", pch = 20, col = \"grey60\") qqline(r1, col = \"red\")  r2 <- rqresid(fit2) qqnorm(r2, main = \"Q-Q Plot (DEGPD-2)\", pch = 20, col = \"grey60\") qqline(r2, col = \"red\")  r3 <- rqresid(fit3) qqnorm(r3, main = \"Q-Q Plot (DEGPD-3)\", pch = 20, col = \"grey60\") qqline(r3, col = \"red\")  r4 <- rqresid(fit4) qqnorm(r4, main = \"Q-Q Plot (DEGPD-4)\", pch = 20, col = \"grey60\") qqline(r4, col = \"red\")  r5 <- rqresid(fit5) qqnorm(r5, main = \"Q-Q Plot (DEGPD-5)\", pch = 20, col = \"grey60\") qqline(r5, col = \"red\")  r6 <- rqresid(fit6) #> Warning in qnorm(u): NaNs produced qqnorm(r6, main = \"Q-Q Plot (DEGPD-6)\", pch = 20, col = \"grey60\") qqline(r6, col = \"red\") par(mfrow = c(1, 1))"},{"path":"https://sdwfrost.github.io/egpd/articles/insurance-complaints.html","id":"quantile-predictions","dir":"Articles","previous_headings":"","what":"Quantile predictions","title":"Discrete EGPD Models for Insurance Complaint Counts","text":"predict method type = \"quantile\" computes quantile estimates fitted model. Compare empirical quantiles:","code":"probs <- c(0.5, 0.9, 0.95, 0.99) qpred <- predict(fit1, type = \"quantile\", prob = probs) qpred[1, ] #>   q:0.5 q:0.9 q:0.95 q:0.99 #> 1     1     6     11     38 emp_q <- quantile(y, probs) cbind(prob = probs, empirical = emp_q, fitted = unlist(qpred[1, ])) #>     prob empirical fitted #> 50% 0.50      1.00      1 #> 90% 0.90      5.00      6 #> 95% 0.95     10.00     11 #> 99% 0.99     47.18     38"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"standard-mdgpd-geometric-marginals","dir":"Articles","previous_headings":"1. The MDGPD construction","what":"Standard MDGPD (geometric marginals)","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"Aka-Kratz-Naveau construction builds dd-dimensional discrete GPD three components: Step 1: Equicorrelated Poisson generator. Generate dd correlated Poisson random variables via common random effect: Tj=Xj+Z,j=1,…,dT_j = X_j + Z, \\quad j = 1, \\ldots, d Z∼Poisson(ρλ)Z \\sim \\mathrm{Poisson}(\\rho\\lambda) shared across components Xj∼Poisson((1−ρ)λ)X_j \\sim \\mathrm{Poisson}((1-\\rho)\\lambda) independent. correlation pair (Ti,Tj)(T_i, T_j) ρ\\rho. Step 2: Spectral differences. component ii, compute: Δi=Ti−maxj≠iTj\\Delta_i = T_i - \\max_{j \\neq } T_j captures much component ii exceeds maximum others. Note Δi≤0\\Delta_i \\leq 0 component ii overall maximum. Step 3: Geometric maximum. Generate G∼Geometric(1−e−1)G \\sim \\mathrm{Geometric}(1 - e^{-1}), independently Poisson generator. Step 4: Standard MDGPD. Combine: Ni=G+min⁡(Δi,0),=1,…,dN_i = G + \\min(\\Delta_i, 0), \\quad = 1, \\ldots, d resulting vector (N1,…,Nd)(N_1, \\ldots, N_d) geometric marginals Geom(1−e−1)\\mathrm{Geom}(1 - e^{-1}) property max⁡(N1,…,Nd)=G\\max(N_1, \\ldots, N_d) = G.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"non-standard-mdgpd-discrete-gpd-marginals","dir":"Articles","previous_headings":"1. The MDGPD construction","what":"Non-standard MDGPD (discrete GPD marginals)","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"obtain discrete GPD marginals parameters σ>0\\sigma > 0 ξ≥0\\xi \\geq 0, apply quantile transform: Mi=⌊σξ(eξmax⁡(Ni,0)−1)⌋M_i = \\left\\lfloor \\frac{\\sigma}{\\xi}\\left(e^{\\xi \\max(N_i, 0)} - 1\\right) \\right\\rfloor ξ=0\\xi = 0, reduces Mi=⌊σNi⌋M_i = \\lfloor \\sigma N_i \\rfloor (scaled geometric marginals).","code":""},{"path":[]},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"bivariate-mdgpd-default","dir":"Articles","previous_headings":"2. Simulating data","what":"Bivariate MDGPD (default)","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"rmdgpd() function generates samples dd-dimensional MDGPD. pure R require Julia.","code":"library(egpd) set.seed(42)  Y <- rmdgpd(2000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5) head(Y) #>      Y1 Y2 #> [1,]  0  0 #> [2,]  0  0 #> [3,]  2  0 #> [4,]  0  0 #> [5,]  2  0 #> [6,]  0  0 cat(\"Dimensions:\", nrow(Y), \"x\", ncol(Y), \"\\n\") #> Dimensions: 2000 x 2 cat(\"Storage mode:\", storage.mode(Y), \"\\n\") #> Storage mode: integer cat(\"Range Y1:\", range(Y[, 1]), \"  Range Y2:\", range(Y[, 2]), \"\\n\") #> Range Y1: 0 39   Range Y2: 0 30 plot(jitter(Y[, 1]), jitter(Y[, 2]), pch = 20, cex = 0.3,      xlab = expression(Y[1]), ylab = expression(Y[2]),      main = \"Simulated bivariate MDGPD (jittered)\",      col = adjustcolor(\"steelblue\", 0.4))"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"marginal-distributions","dir":"Articles","previous_headings":"2. Simulating data","what":"Marginal distributions","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"marginals non-standard MDGPD discrete GPD. σ=1\\sigma = 1 ξ=0\\xi = 0, reduce Geom(1−e−1)\\mathrm{Geom}(1 - e^{-1}):","code":"set.seed(42) Y_geom <- rmdgpd(5000, sigma = 1, xi = 0, lambda = 1, rho = 0.5)  op <- par(mfrow = c(1, 2), mar = c(4, 4, 2, 1)) barplot(table(Y_geom[, 1]) / nrow(Y_geom),         main = expression(\"Marginal \" * Y[1] * \" (sigma=1, xi=0)\"),         xlab = expression(Y[1]), ylab = \"Proportion\",         col = \"lightblue\", border = \"grey\")  ## Overlay theoretical Geom(1-e^{-1}) p_geom <- 1 - exp(-1) k_vals <- 0:max(Y_geom[, 1]) points(seq_along(k_vals), dgeom(k_vals, prob = p_geom),        pch = 16, col = \"red\", cex = 0.8) legend(\"topright\", \"Geom(1-e^{-1})\", pch = 16, col = \"red\",        cex = 0.8, bg = \"white\")  ## With sigma=2, xi=0.2: heavier tails barplot(table(Y[, 1]) / nrow(Y),         main = expression(\"Marginal \" * Y[1] * \" (sigma=2, xi=0.2)\"),         xlab = expression(Y[1]), ylab = \"Proportion\",         col = \"lightblue\", border = \"grey\") par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"maximum-component-is-geometric","dir":"Articles","previous_headings":"2. Simulating data","what":"Maximum component is geometric","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"key theoretical property: component-wise maximum max⁡(N1,…,Nd)=G∼Geom(1−e−1)\\max(N_1, \\ldots, N_d) = G \\sim \\mathrm{Geom}(1-e^{-1}). verify standard MDGPD (σ=1\\sigma=1, ξ=0\\xi=0):","code":"maxY <- pmax(Y_geom[, 1], Y_geom[, 2])  barplot(table(maxY) / length(maxY),         main = expression(\"max(\" * Y[1] * \", \" * Y[2] * \") vs Geom(1-\" * e^{-1} * \")\"),         xlab = \"max(Y1, Y2)\", ylab = \"Proportion\",         col = \"lightblue\", border = \"grey\") k_max <- 0:max(maxY) points(seq_along(k_max), dgeom(k_max, prob = p_geom),        pch = 16, col = \"red\", cex = 0.8) legend(\"topright\", \"Geom(1-e^{-1})\", pch = 16, col = \"red\",        cex = 0.8, bg = \"white\") cat(\"Empirical mean of max:\", round(mean(maxY), 3), \"\\n\") #> Empirical mean of max: 0.578 cat(\"Theoretical mean:\", round(exp(-1) / (1 - exp(-1)), 3), \"\\n\") #> Theoretical mean: 0.582"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"zero-inflated-mdgpd","dir":"Articles","previous_headings":"2. Simulating data","what":"Zero-inflated MDGPD","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"","code":"set.seed(42) Y_zi <- rzimdgpd(2000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5,                   pi0 = 0.3)  joint_zeros <- mean(rowSums(Y_zi) == 0) cat(\"Proportion of all-zero rows:\", round(joint_zeros, 3), \"\\n\") #> Proportion of all-zero rows: 0.754 cat(\"(Expected >= pi0 = 0.3 due to natural zeros)\\n\") #> (Expected >= pi0 = 0.3 due to natural zeros)"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"dependence-strength-rho","dir":"Articles","previous_headings":"3. The role of parameters","what":"Dependence strength (ρ\\rho)","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"parameter ρ\\rho directly controls equicorrelation Poisson generator. Higher ρ\\rho means common component ZZ dominates, making TjT_j nearly identical thus producing near-identical (Y1,…,Yd)(Y_1, \\ldots, Y_d):","code":"set.seed(42) n_demo <- 3000  rho_vals <- c(0, 0.3, 0.7, 0.95) op <- par(mfrow = c(2, 2), mar = c(4, 4, 3, 1)) for (rho_v in rho_vals) {   Y_rho <- rmdgpd(n_demo, sigma = 2, xi = 0.2, lambda = 1, rho = rho_v)   cor_val <- cor(Y_rho[, 1], Y_rho[, 2])   plot(jitter(Y_rho[, 1]), jitter(Y_rho[, 2]), pch = 20, cex = 0.3,        main = bquote(rho == .(rho_v) ~ \" (cor = \" * .(round(cor_val, 2)) * \")\"),        xlab = expression(Y[1]), ylab = expression(Y[2]),        col = adjustcolor(\"steelblue\", 0.4)) } par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"spectral-spread-lambda","dir":"Articles","previous_headings":"3. The role of parameters","what":"Spectral spread (λ\\lambda)","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"parameter λ\\lambda controls Poisson rate. Larger λ\\lambda produces larger spectral differences Δi\\Delta_i, turn makes NiN_i variable relative GG:","code":"set.seed(42)  lambda_vals <- c(0.1, 1, 5) op <- par(mfrow = c(1, 3), mar = c(4, 4, 3, 1)) for (lam_v in lambda_vals) {   Y_lam <- rmdgpd(n_demo, sigma = 2, xi = 0.2, lambda = lam_v, rho = 0.5)   cor_val <- cor(Y_lam[, 1], Y_lam[, 2])   plot(jitter(Y_lam[, 1]), jitter(Y_lam[, 2]), pch = 20, cex = 0.3,        main = bquote(lambda == .(lam_v) ~ \" (cor = \" * .(round(cor_val, 2)) * \")\"),        xlab = expression(Y[1]), ylab = expression(Y[2]),        col = adjustcolor(\"steelblue\", 0.4)) } par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"tail-heaviness-xi","dir":"Articles","previous_headings":"3. The role of parameters","what":"Tail heaviness (ξ\\xi)","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"shape parameter ξ\\xi controls tail behaviour. Larger ξ\\xi produces heavier tails (occasional large values):","code":"set.seed(42)  xi_vals <- c(0, 0.1, 0.5) op <- par(mfrow = c(1, 3), mar = c(4, 4, 3, 1)) for (xi_v in xi_vals) {   Y_xi <- rmdgpd(n_demo, sigma = 2, xi = xi_v, lambda = 1, rho = 0.5)   plot(jitter(Y_xi[, 1]), jitter(Y_xi[, 2]), pch = 20, cex = 0.3,        main = bquote(xi == .(xi_v)),        xlab = expression(Y[1]), ylab = expression(Y[2]),        col = adjustcolor(\"steelblue\", 0.4)) } par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"higher-dimensions","dir":"Articles","previous_headings":"","what":"4. Higher dimensions","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"MDGPD generalises naturally d≥2d \\geq 2 dimensions. Simply pass d parameter rmdgpd():","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"trivariate-mdgpd-d-3","dir":"Articles","previous_headings":"4. Higher dimensions","what":"Trivariate MDGPD (d=3d = 3)","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"","code":"set.seed(42)  Y3 <- rmdgpd(2000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5, d = 3) cat(\"Dimensions:\", nrow(Y3), \"x\", ncol(Y3), \"\\n\") #> Dimensions: 2000 x 3 cat(\"Column names:\", colnames(Y3), \"\\n\") #> Column names: Y1 Y2 Y3  ## Pairwise scatter plots op <- par(mfrow = c(1, 3), mar = c(4, 4, 2, 1)) pairs_list <- list(c(1, 2), c(1, 3), c(2, 3)) for (pr in pairs_list) {   plot(jitter(Y3[, pr[1]]), jitter(Y3[, pr[2]]), pch = 20, cex = 0.3,        main = paste0(\"Y\", pr[1], \" vs Y\", pr[2]),        xlab = paste0(\"Y\", pr[1]), ylab = paste0(\"Y\", pr[2]),        col = adjustcolor(\"steelblue\", 0.4)) } par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"pairwise-correlation-in-d-3","dir":"Articles","previous_headings":"4. Higher dimensions","what":"Pairwise correlation in d=3d = 3","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"","code":"cat(\"Pairwise correlations:\\n\") #> Pairwise correlations: print(round(cor(Y3), 3)) #>       Y1    Y2    Y3 #> Y1 1.000 0.875 0.871 #> Y2 0.875 1.000 0.853 #> Y3 0.871 0.853 1.000"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"dependence-at-high-rho-in-d-3","dir":"Articles","previous_headings":"4. Higher dimensions","what":"Dependence at high ρ\\rho in d=3d = 3","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"","code":"set.seed(42) Y3_high <- rmdgpd(2000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.95, d = 3)  op <- par(mfrow = c(1, 3), mar = c(4, 4, 2, 1)) for (pr in pairs_list) {   plot(jitter(Y3_high[, pr[1]]), jitter(Y3_high[, pr[2]]), pch = 20, cex = 0.3,        main = paste0(\"Y\", pr[1], \" vs Y\", pr[2], \" (rho=0.95)\"),        xlab = paste0(\"Y\", pr[1]), ylab = paste0(\"Y\", pr[2]),        col = adjustcolor(\"steelblue\", 0.4)) } par(op)  cat(\"Pairwise correlations (rho=0.95):\\n\") #> Pairwise correlations (rho=0.95): print(round(cor(Y3_high), 3)) #>       Y1    Y2    Y3 #> Y1 1.000 0.988 0.986 #> Y2 0.988 1.000 0.982 #> Y3 0.986 0.982 1.000"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"even-higher-dimensions","dir":"Articles","previous_headings":"4. Higher dimensions","what":"Even higher dimensions","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"construction works d≥2d \\geq 2:","code":"set.seed(42)  Y5 <- rmdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5, d = 5) cat(\"5-dimensional MDGPD:\", nrow(Y5), \"x\", ncol(Y5), \"\\n\") #> 5-dimensional MDGPD: 1000 x 5 cat(\"Columns:\", colnames(Y5), \"\\n\") #> Columns: Y1 Y2 Y3 Y4 Y5 cat(\"\\nPairwise correlations:\\n\") #>  #> Pairwise correlations: print(round(cor(Y5), 3)) #>       Y1    Y2    Y3    Y4    Y5 #> Y1 1.000 0.823 0.831 0.836 0.821 #> Y2 0.823 1.000 0.827 0.821 0.831 #> Y3 0.831 0.827 1.000 0.788 0.813 #> Y4 0.836 0.821 0.788 1.000 0.841 #> Y5 0.821 0.831 0.813 0.841 1.000"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"zero-inflated-mdgpd-in-higher-dimensions","dir":"Articles","previous_headings":"","what":"5. Zero-inflated MDGPD in higher dimensions","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"rzimdgpd() function also supports arbitrary dd:","code":"set.seed(42) Y3_zi <- rzimdgpd(2000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5,                     pi0 = 0.3, d = 3)  joint_zeros_3d <- mean(rowSums(Y3_zi) == 0) cat(\"Proportion of all-zero rows (d=3):\", round(joint_zeros_3d, 3), \"\\n\") #> Proportion of all-zero rows (d=3): 0.744"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"fitting-bivariate-mdgpd","dir":"Articles","previous_headings":"6. Neural Bayes estimation","what":"Fitting bivariate MDGPD","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"MDGPD closed-form likelihood (construction involves discrete maximum floor operations). Neural Bayes estimation used instead, via pre-trained neural networks.","code":"set.seed(42)  Y <- rmdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5) fit <- fitegpd(Y, family = \"mdgpd\", method = \"neuralbayes\",                estimator = \"npe\", nsamples = 2000) #> Starting Julia ... summary(fit) #> Fitting of bivariate MDGPD (Aka-Kratz-Naveau) [Experimental] #> Method: neuralbayes (npe)  [2000 posterior samples] #>  #> Posterior summary: #>        Median Post.SD   2.5%  97.5% #> sigma  2.0373  0.2556 1.5729 2.5548 #> xi     0.2339  0.1408 0.0238 0.5114 #> lambda 1.4712  1.2878 0.4035 4.9281 #> rho    0.6811  0.2611 0.0666 0.9148 #>  #> Note: log-likelihood, AIC, and BIC are not available for neural estimation #> Number of observations:  1000 plot(fit)"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"fitting-zimdgpd","dir":"Articles","previous_headings":"6. Neural Bayes estimation","what":"Fitting ZIMDGPD","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"","code":"set.seed(42)  Y_zi <- rzimdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5,                   pi0 = 0.3) fit_zi <- fitegpd(Y_zi, family = \"zimdgpd\", method = \"neuralbayes\",                    estimator = \"npe\") summary(fit_zi) #> Fitting of zero-inflated bivariate MDGPD (ZIMDGPD) [Experimental] #> Method: neuralbayes (npe)  [1000 posterior samples] #>  #> Posterior summary: #>        Median Post.SD   2.5%  97.5% #> sigma  1.7381  0.2975 1.2077 2.3554 #> xi     0.2191  0.1212 0.0162 0.4268 #> lambda 1.6117  1.1618 0.3807 4.7926 #> rho    0.6366  0.2383 0.0965 0.9081 #> pi0    0.2503  0.1101 0.0482 0.4624 #>  #> Note: log-likelihood, AIC, and BIC are not available for neural estimation #> Number of observations:  1000"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"s3-methods","dir":"Articles","previous_headings":"6. Neural Bayes estimation","what":"S3 methods","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"","code":"coef(fit)                # Posterior median estimates #>    sigma       xi   lambda      rho  #> 2.037282 0.233938 1.471153 0.681051 confint(fit)             # 95% credible intervals #>             2.5 %    97.5 % #> sigma  1.57288426 2.5547769 #> xi     0.02377782 0.5114318 #> lambda 0.40350734 4.9280589 #> rho    0.06656750 0.9148393 vcov(fit)                # Posterior covariance matrix #>                sigma           xi       lambda          rho #> sigma   0.0653121330 -0.024736149 -0.005829067 0.0005754695 #> xi     -0.0247361487  0.019833619  0.012748590 0.0028251108 #> lambda -0.0058290666  0.012748590  1.658399252 0.2762968616 #> rho     0.0005754695  0.002825111  0.276296862 0.0681657652 nobs(fit)                # Number of observations #> [1] 1000"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"higher-dimensional-estimation","dir":"Articles","previous_headings":"6. Neural Bayes estimation","what":"Higher-dimensional estimation","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"d≥3d \\geq 3, separate neural network must trained data dimension, since network architecture depends input dimension. Use train_mdgpd() data_dim parameter:","code":"# Fit 3D data using a pre-trained model Y3_fit <- rmdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5, d = 3)  model_3d_path <- system.file(\"models\", \"MDGPD_3D_NPE.bson\", package = \"egpd\") fit_3d <- fitegpd(Y3_fit, family = \"mdgpd\", method = \"neuralbayes\",                    model.path = model_3d_path, estimator = \"npe\") summary(fit_3d) #> Fitting of 3-variate MDGPD (Aka-Kratz-Naveau) [Experimental] #> Method: neuralbayes (npe)  [1000 posterior samples] #>  #> Posterior summary: #>        Median Post.SD   2.5%  97.5% #> sigma  1.8967  0.2849 1.3838 2.4651 #> xi     0.1942  0.1274 0.0143 0.4506 #> lambda 1.4899  1.2285 0.4130 4.9407 #> rho    0.6957  0.2439 0.0907 0.9179 #>  #> Note: log-likelihood, AIC, and BIC are not available for neural estimation #> Number of observations:  1000"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"comparison-mdgpd-vs-bdegpd","dir":"Articles","previous_headings":"","what":"7. Comparison: MDGPD vs BDEGPD","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"package provides two approaches bivariate discrete extreme value modelling. suited different settings: use BDEGPD: data exhibit asymmetric dependence lower upper tails, want directly compare continuous discrete BEGPD fits parameter set. use MDGPD: want parsimonious model theoretical threshold stability, exchangeable dependence, ability extend d>2d > 2 dimensions.","code":"set.seed(42) n_cmp <- 3000  Y_bdegpd <- rbdegpd(n_cmp, kappa = 2, sigma = 1.5, xi = 0.1,                      thL = 3, thU = 3, thw = 0.2) Y_mdgpd  <- rmdgpd(n_cmp, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5)  op <- par(mfrow = c(1, 2), mar = c(4, 4, 2, 1)) plot(jitter(Y_bdegpd[, 1]), jitter(Y_bdegpd[, 2]), pch = 20, cex = 0.3,      main = \"BDEGPD (6 params)\",      xlab = expression(Y[1]), ylab = expression(Y[2]),      col = adjustcolor(\"steelblue\", 0.4)) plot(jitter(Y_mdgpd[, 1]), jitter(Y_mdgpd[, 2]), pch = 20, cex = 0.3,      main = \"MDGPD (4 params)\",      xlab = expression(Y[1]), ylab = expression(Y[2]),      col = adjustcolor(\"firebrick\", 0.4)) par(op)"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"mdgpd-training","dir":"Articles","previous_headings":"8. Training custom models","what":"MDGPD training","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"","code":"# Quick training for 2D MDGPD paths <- train_mdgpd(   savepath = tempdir(),   family = \"mdgpd\",   data_dim = 2L,   estimator = \"both\",   quick = TRUE,   verbose = TRUE )  # Quick training for 3D MDGPD paths_3d <- train_mdgpd(   savepath = tempdir(),   family = \"mdgpd\",   data_dim = 3L,   estimator = \"npe\",   quick = TRUE )  # ZIMDGPD training paths_zi <- train_mdgpd(   savepath = tempdir(),   family = \"zimdgpd\",   data_dim = 2L,   estimator = \"npe\",   quick = TRUE )"},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"prior-distributions","dir":"Articles","previous_headings":"8. Training custom models","what":"Prior distributions","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"training procedure samples parameters following priors: Model files named dimension-specific prefix: MDGPD_NPE.bson (2D), MDGPD3D_NPE.bson (3D), etc.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/mdgpd.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation","text":"Aka, S., Kratz, M., Naveau, P. (2025). Multivariate discrete generalized Pareto distributions: theory, simulation, applications dry spells. arXiv preprint arXiv:2506.19361. https://arxiv.org/abs/2506.19361 Sainsbury-Dale, M., Zammit-Mangion, ., Huser, R. (2024). Likelihood-free parameter estimation neural Bayes estimators. American Statistician, 78(1), 1–14.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"the-bivariate-begpd-model","dir":"Articles","previous_headings":"","what":"1. The bivariate BEGPD model","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"BEGPD jointly models two variables (Y1,Y2)(Y_1, Y_2) decomposing radial (intensity) component angular (dependence) components.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"radial-component","dir":"Articles","previous_headings":"1. The bivariate BEGPD model","what":"Radial component","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"intensity RR follows power-transformed GPD: R=σξ[(1−U1/κ)−ξ−1],U∼Uniform(0,1)R = \\frac{\\sigma}{\\xi}\\left[\\left(1 - U^{1/\\kappa}\\right)^{-\\xi} - 1\\right], \\qquad U \\sim \\mathrm{Uniform}(0,1) κ>0\\kappa > 0 EGPD shape, σ>0\\sigma > 0 GPD scale, ξ>0\\xi > 0 GPD shape parameter. CDF RR EGPD CDF: FR(r)=[1−(1+ξr/σ)−1/ξ]κF_R(r) = \\left[1 - \\left(1 + \\xi\\, r / \\sigma\\right)^{-1/\\xi}\\right]^\\kappa","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"lower-and-upper-tail-dependence","dir":"Articles","previous_headings":"1. The bivariate BEGPD model","what":"Lower and upper tail dependence","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"angular structure governed two symmetric Beta distributions control lower upper tail behaviour respectively: Lower tail angles: V1∼Beta(θL,θL)V_1 \\sim \\mathrm{Beta}(\\theta_L, \\theta_L), L1=1/V1L_1 = 1/V_1 L2=1/(1−V1)L_2 = 1/(1-V_1) Upper tail angles: U1∼Beta(θU,θU)U_1 \\sim \\mathrm{Beta}(\\theta_U, \\theta_U), U2=1−U1U_2 = 1 - U_1 Large values θL\\theta_L θU\\theta_U concentrate angular distribution around equal splitting (independence), small values induce stronger dependence.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"mixing","dir":"Articles","previous_headings":"1. The bivariate BEGPD model","what":"Mixing","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"weight function smoothly transitions lower upper tail regimes. Given radial quantile u=FR(R)u = F_R(R), weight : w(u)=FBeta(3,3)(u−θω1−2θω)w(u) = F_{\\mathrm{Beta}(3,3)}\\!\\left(\\frac{u - \\theta_\\omega}{1 - 2\\theta_\\omega}\\right) θω∈(0,0.5)\\theta_\\omega \\(0, 0.5) controls transition point. bivariate observations : Y1=R[(1−w)V1+wU1],Y2=R[(1−w)(1−V1)+wU2]Y_1 = R\\left[(1-w)\\,V_1 + w\\,U_1\\right], \\qquad Y_2 = R\\left[(1-w)\\,(1-V_1) + w\\,U_2\\right]","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"simulating-bivariate-data","dir":"Articles","previous_headings":"","what":"2. Simulating bivariate data","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"rbegpd() function generates bivariate samples BEGPD. pure R require Julia.","code":"library(egpd) set.seed(42)  Y <- rbegpd(2000, kappa = 3, sigma = 1, xi = 0.1,             thL = 10, thU = 10, thw = 0.25) head(Y) #>             Y1        Y2 #> [1,] 2.8277805 1.4084486 #> [2,] 2.5063541 2.1793926 #> [3,] 0.6210209 0.5147301 #> [4,] 1.1398503 2.1080683 #> [5,] 1.1267881 1.0683751 #> [6,] 0.8451407 0.9228765 dim(Y) #> [1] 2000    2 plot(Y[, 1], Y[, 2], pch = 20, cex = 0.4, asp = 1,      xlab = expression(Y[1]), ylab = expression(Y[2]),      main = \"Simulated bivariate BEGPD sample\") abline(h = 0, v = 0, col = \"lightgrey\")"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"illustrative-scenarios","dir":"Articles","previous_headings":"","what":"3. Illustrative scenarios","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"six parameters BEGPD control different aspects bivariate distribution. illustrate three scenarios highlight effects.  Interpretation: Scenario 1 (κ=3\\kappa=3, θL=θU=10\\theta_L=\\theta_U=10): Symmetric dependence tails. upper lower extremes (red blue) roughly equally spread. Scenario 2 (κ=0.3\\kappa=0.3, θU=0.5\\theta_U=0.5): Small κ\\kappa concentrates mass near zero, small θU\\theta_U induces strong upper tail dependence (red points cluster along diagonal). Scenario 3 (ξ=0.2\\xi=0.2, θL=4\\theta_L=4, θU=0.5\\theta_U=0.5): Heavier GPD tail (ξ=0.2\\xi=0.2) stronger dependence tails.","code":"scenarios <- list(   \"Scenario 1:\\nsymmetric dependence\" = list(     kappa = 3, sigma = 1, xi = 0.05, thL = 10, thU = 10, thw = 0.25   ),   \"Scenario 2:\\nasymmetric tails\" = list(     kappa = 0.3, sigma = 1, xi = 0.05, thL = 10, thU = 0.5, thw = 0.25   ),   \"Scenario 3:\\nheavy tails\" = list(     kappa = 3, sigma = 1, xi = 0.2, thL = 4, thU = 0.5, thw = 0.25   ) ) set.seed(198345) n <- 2000 op <- par(mfrow = c(3, 3), mar = c(4, 4, 2.5, 1), mgp = c(2.5, 1, 0))  for (i in seq_along(scenarios)) {   sc <- scenarios[[i]]   Y <- rbegpd(n, kappa = sc$kappa, sigma = sc$sigma, xi = sc$xi,               thL = sc$thL, thU = sc$thU, thw = sc$thw)   R <- Y[, 1] + Y[, 2]   ind_upp <- which(R > quantile(R, 0.95))   ind_low <- which(R < quantile(R, 0.05))    # Panel 1: scatter on original scale   plot(Y[, 1], Y[, 2], pch = 20, cex = 0.4, asp = 1,        xlim = range(Y), ylim = range(Y),        xlab = expression(Y[1]), ylab = expression(Y[2]),        main = names(scenarios)[i])   points(Y[ind_upp, 1], Y[ind_upp, 2], pch = 20, col = \"red\", cex = 0.6)   points(Y[ind_low, 1], Y[ind_low, 2], pch = 20, col = \"blue\", cex = 0.6)   abline(h = 0, v = 0, col = \"lightgrey\")    # Panel 2: scatter on uniform (copula) scale   U1 <- rank(Y[, 1]) / (n + 1)   U2 <- rank(Y[, 2]) / (n + 1)   plot(U1, U2, pch = 20, cex = 0.4, asp = 1, xlim = c(0, 1), ylim = c(0, 1),        xlab = expression(Y[1] ~ \"(Unif scale)\"),        ylab = expression(Y[2] ~ \"(Unif scale)\"))   points(U1[ind_upp], U2[ind_upp], pch = 20, col = \"red\", cex = 0.6)   points(U1[ind_low], U2[ind_low], pch = 20, col = \"blue\", cex = 0.6)   abline(h = c(0, 1), v = c(0, 1), col = \"lightgrey\")    # Panel 3: marginal histograms of radial component   hist(R, breaks = 50, freq = FALSE, col = \"lightblue\", border = \"grey\",        main = expression(\"Radial: \" * Y[1] + Y[2]),        xlab = expression(Y[1] + Y[2])) } par(op)"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"tail-dependence-measures","dir":"Articles","previous_headings":"3. Illustrative scenarios","what":"Tail dependence measures","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"can quantify dependence structure using chi coefficients. threshold uu: χ(u)=P(FY2(Y2)>u∣FY1(Y1)>u)\\chi(u) = P(F_{Y_2}(Y_2) > u \\mid F_{Y_1}(Y_1) > u)","code":"set.seed(1) n_big <- 50000  chi_u <- function(data, u) {   U1 <- rank(data[, 1]) / (nrow(data) + 1)   U2 <- rank(data[, 2]) / (nrow(data) + 1)   sum(U1 > u & U2 > u) / sum(U1 > u) } chi_l <- function(data, l) {   U1 <- rank(data[, 1]) / (nrow(data) + 1)   U2 <- rank(data[, 2]) / (nrow(data) + 1)   sum(U1 < l & U2 < l) / sum(U1 < l) }  thresholds <- seq(0.05, 0.95, by = 0.02)  op <- par(mfrow = c(1, 2), mar = c(4, 4, 2, 1)) cols <- c(\"steelblue\", \"firebrick\", \"forestgreen\")  # Upper tail chi plot(0, 0, type = \"n\", xlim = c(0, 1), ylim = c(0, 1),      xlab = \"Threshold u\", ylab = expression(chi(u)),      main = expression(\"Upper tail \" * chi(u))) for (i in seq_along(scenarios)) {   sc <- scenarios[[i]]   Y_big <- rbegpd(n_big, kappa = sc$kappa, sigma = sc$sigma, xi = sc$xi,                   thL = sc$thL, thU = sc$thU, thw = sc$thw)   chi_vals <- sapply(thresholds, function(u) chi_u(Y_big, u))   lines(thresholds, chi_vals, col = cols[i], lwd = 2) } legend(\"topright\", legend = paste(\"Scenario\", 1:3), col = cols, lwd = 2,        cex = 0.8, bg = \"white\")  # Lower tail chi plot(0, 0, type = \"n\", xlim = c(0, 1), ylim = c(0, 1),      xlab = \"Threshold l\", ylab = expression(chi(l)),      main = expression(\"Lower tail \" * chi(l))) for (i in seq_along(scenarios)) {   sc <- scenarios[[i]]   Y_big <- rbegpd(n_big, kappa = sc$kappa, sigma = sc$sigma, xi = sc$xi,                   thL = sc$thL, thU = sc$thU, thw = sc$thw)   chi_vals <- sapply(thresholds, function(l) chi_l(Y_big, l))   lines(thresholds, chi_vals, col = cols[i], lwd = 2) } legend(\"topleft\", legend = paste(\"Scenario\", 1:3), col = cols, lwd = 2,        cex = 0.8, bg = \"white\") par(op)"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"why-neural-estimation","dir":"Articles","previous_headings":"4. Neural Bayes estimation","what":"Why neural estimation?","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"bivariate BEGPD six parameters closed-form likelihood joint distribution. Traditional likelihood-moment approaches require multi-stage procedure: (1) fit radial EGPD MLE, (2) estimate angular parameters matching moments tails, (3) estimate mixing parameter least-squares covariance. slow can sensitive threshold choices. Neural Bayes estimation sidesteps likelihood entirely. neural network trained simulated data learn mapping data parameters. trained, inference new datasets nearly instant. egpd package supports two estimators: use DeepSet architecture can handle varying sample sizes.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"prerequisites","dir":"Articles","previous_headings":"4. Neural Bayes estimation","what":"Prerequisites","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"Neural Bayes estimation requires Julia (>= 1.11) additional packages:","code":"# R packages install.packages(\"JuliaConnectoR\") remotes::install_github(\"msainsburydale/NeuralEstimators\")  # Julia packages (run in Julia REPL) # using Pkg # Pkg.add([\"NeuralEstimators\", \"Flux\"])"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"fitting-with-npe","dir":"Articles","previous_headings":"4. Neural Bayes estimation","what":"Fitting with NPE","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"NPE provides full posterior inference: given data, returns samples approximate posterior distribution six parameters. nsamples argument controls many draws taken approximate posterior (default: 1000). samples give smoother posterior summaries cost slightly longer inference. summary provides: Median: Posterior median (point estimate) Post.SD: Posterior standard deviation 2.5% / 97.5%: 95% credible interval posterior quantiles","code":"set.seed(42)  # Simulate data from known parameters Y <- rbegpd(2000, kappa = 2, sigma = 1, xi = 0.1,             thL = 5, thU = 5, thw = 0.2)  # Fit using Neural Posterior Estimation fit_npe <- fitegpd(Y, family = \"begpd\", method = \"neuralbayes\",                    estimator = \"npe\", nsamples = 2000) #> Starting Julia ... summary(fit_npe) #> Fitting of bivariate BEGPD #> Method: neuralbayes (npe)  [2000 posterior samples] #>  #> Posterior summary: #>       Median Post.SD   2.5%   97.5% #> kappa 4.1296  2.4917 1.1319 10.2463 #> sigma 0.5916  0.2868 0.2745  1.3622 #> xi    0.1786  0.1074 0.0180  0.4073 #> thL   7.0179  5.8291 0.6013 21.6860 #> thU   4.9276  3.2240 2.2466 13.9202 #> thw   0.2560  0.1440 0.0374  0.5616 #>  #> Note: log-likelihood, AIC, and BIC are not available for neural estimation #> Number of observations:  2000"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"fitting-with-nbe","dir":"Articles","previous_headings":"4. Neural Bayes estimation","what":"Fitting with NBE","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"NBE faster provides point estimates (uncertainty quantification):","code":"fit_nbe <- fitegpd(Y, family = \"begpd\", method = \"neuralbayes\",                    estimator = \"nbe\") summary(fit_nbe) #> Fitting of bivariate BEGPD #> Method: neuralbayes (nbe) #>  #> Estimated parameters: #>       Estimate SE #> kappa   2.8949 NA #> sigma   0.7741 NA #> xi      0.2000 NA #> thL     8.0920 NA #> thU     3.8026 NA #> thw     0.2455 NA #>  #> Note: log-likelihood, AIC, and BIC are not available for neural estimation #> Number of observations:  2000"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"diagnostic-plots","dir":"Articles","previous_headings":"5. Diagnostics and inference","what":"Diagnostic plots","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"plot() method produces 4-panel diagnostic plot adapted bivariate data:  panels show: Observed scatter – input data (Y1,Y2)(Y_1, Y_2) Simulated scatter – data generated fitted model via rbegpd() estimated parameters Radial Q-Q plot – quantiles Y1+Y2Y_1+Y_2 (observed vs simulated) Posterior marginals (NPE) parameter bar chart (NBE)","code":"plot(fit_npe)"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"extracting-estimates","dir":"Articles","previous_headings":"5. Diagnostics and inference","what":"Extracting estimates","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"Standard S3 methods work expected:","code":"# Point estimates (posterior median for NPE) coef(fit_npe) #>     kappa     sigma        xi       thL       thU       thw  #> 4.1296459 0.5915987 0.1785721 7.0179195 4.9275990 0.2559894  # Variance-covariance (from posterior sample covariance for NPE) vcov(fit_npe) #>             kappa        sigma            xi          thL           thU #> kappa  6.20876884 -0.571721025  0.1335469245   0.63108999   0.601615525 #> sigma -0.57172103  0.082238160 -0.0210034243   0.10547034  -0.175714043 #> xi     0.13354692 -0.021003424  0.0115331643  -0.01193396   0.005737354 #> thL    0.63108999  0.105470336 -0.0119339605  33.97843008 -10.499744226 #> thU    0.60161552 -0.175714043  0.0057373543 -10.49974423  10.394390693 #> thw    0.04488354 -0.005127827  0.0001122861   0.00196085   0.124885490 #>                 thw #> kappa  0.0448835378 #> sigma -0.0051278273 #> xi     0.0001122861 #> thL    0.0019608500 #> thU    0.1248854900 #> thw    0.0207488274  # 95% credible intervals (from posterior quantiles for NPE) confint(fit_npe) #>            2.5 %     97.5 % #> kappa 1.13185648 10.2462680 #> sigma 0.27450253  1.3621800 #> xi    0.01798964  0.4073298 #> thL   0.60129781 21.6860339 #> thU   2.24656541 13.9202364 #> thw   0.03736404  0.5616213 confint(fit_npe, level = 0.90) #>              5 %       95 % #> kappa 1.38581448  9.1184592 #> sigma 0.30007208  1.1953838 #> xi    0.02824100  0.3728958 #> thL   0.96799042 18.8530634 #> thU   2.51369718 11.7649020 #> thw   0.05467705  0.5223033  # Subset parameters confint(fit_npe, parm = c(\"kappa\", \"xi\")) #>            2.5 %     97.5 % #> kappa 1.13185648 10.2462680 #> xi    0.01798964  0.4073298"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"comparing-to-true-values","dir":"Articles","previous_headings":"5. Diagnostics and inference","what":"Comparing to true values","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"Since know true parameters, can assess estimation quality:","code":"truth <- c(kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2) est <- coef(fit_npe) ci <- confint(fit_npe)  comparison <- data.frame(   True = truth,   Estimate = round(est, 4),   Lower = round(ci[, 1], 4),   Upper = round(ci[, 2], 4),   Covered = truth >= ci[, 1] & truth <= ci[, 2] ) comparison #>       True Estimate  Lower   Upper Covered #> kappa  2.0   4.1296 1.1319 10.2463    TRUE #> sigma  1.0   0.5916 0.2745  1.3622    TRUE #> xi     0.1   0.1786 0.0180  0.4073    TRUE #> thL    5.0   7.0179 0.6013 21.6860    TRUE #> thU    5.0   4.9276 2.2466 13.9202    TRUE #> thw    0.2   0.2560 0.0374  0.5616    TRUE"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"limitations","dir":"Articles","previous_headings":"5. Diagnostics and inference","what":"Limitations","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"Since neural estimator bypasses likelihood, standard likelihood-based quantities available:","code":"logLik(fit_npe)   # returns NA with a warning #> Warning: Log-likelihood is not available for neural Bayes estimation #> 'log Lik.' NA (df=6) AIC(fit_npe)      # NA #> Warning: Log-likelihood is not available for neural Bayes estimation #> [1] NA BIC(fit_npe)      # NA #> Warning: Log-likelihood is not available for neural Bayes estimation #> [1] NA # vcov and confint require NPE (not available for NBE) vcov(fit_nbe)     # error: no posterior samples #> Error: #> ! Variance-covariance matrix not available for NBE estimator (no posterior samples) confint(fit_nbe)  # error: no posterior samples #> Error: #> ! Credible intervals not available for NBE estimator (no posterior samples)"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"simulation-study","dir":"Articles","previous_headings":"","what":"6. Simulation study","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"assess quality neural estimators, can run small simulation study. Julia available, datasets can estimated:","code":"set.seed(1) K <- 100  # number of replications n <- 2000 true_params <- c(kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2)  # Simulate K datasets (pure R -- fast) datasets <- lapply(seq_len(K), function(k) {   rbegpd(n, kappa = true_params[\"kappa\"], sigma = true_params[\"sigma\"],          xi = true_params[\"xi\"], thL = true_params[\"thL\"],          thU = true_params[\"thU\"], thw = true_params[\"thw\"]) })  cat(\"Generated\", K, \"datasets, each with\", n, \"observations\\n\") #> Generated 100 datasets, each with 2000 observations cat(\"Each dataset is a\", nrow(datasets[[1]]), \"x\", ncol(datasets[[1]]), \"matrix\\n\") #> Each dataset is a 2000 x 2 matrix # Estimate a subset of datasets (full study would use all K) K_est <- min(K, 10) estimates <- sapply(datasets[seq_len(K_est)], function(Y) {   fit <- fitegpd(Y, family = \"begpd\", method = \"neuralbayes\",                  estimator = \"npe\", nsamples = 1000)   coef(fit) })  # RMSE for each parameter (based on K_est replications) rmse <- sqrt(rowMeans((estimates - true_params)^2)) cat(\"RMSE (based on\", K_est, \"replications):\\n\") #> RMSE (based on 10 replications): print(round(rmse, 4)) #>  kappa  sigma     xi    thL    thU    thw  #> 2.2449 0.4107 0.0825 2.0747 0.6619 0.0537"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"training-custom-models","dir":"Articles","previous_headings":"","what":"7. Training custom models","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"bundled .bson models trained uniform priors covering wide parameter range. specific applications, may want train narrower prior improve accuracy.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"quick-training","dir":"Articles","previous_headings":"7. Training custom models","what":"Quick training","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"","code":"# Quick training for testing (small K, few epochs) paths <- train_begpd(   savepath = tempdir(),   estimator = \"both\",  # train both NPE and NBE   quick = TRUE,        # reduced settings   verbose = TRUE ) # Training messages: #> Sampling parameters and simulating data... #> Training NPE... #> NPE saved to /tmp/.../NPE.bson #> Training NBE... #> NBE saved to /tmp/.../NBE.bson #> Training complete.  # Use the custom-trained model fit_custom <- fitegpd(Y, family = \"begpd\", method = \"neuralbayes\",                       model.path = paths$npe, estimator = \"npe\")"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"full-training","dir":"Articles","previous_headings":"7. Training custom models","what":"Full training","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"production use, train full settings:","code":"paths <- train_begpd(   savepath = \"inst/models\",   estimator = \"both\",   K = 100000,          # training parameter sets   m = 1000:4000,       # sample size range   epochs = 100,        # maximum epochs   stopping_epochs = 10, # early stopping patience   mc.cores = 4,        # parallel simulation cores   seed = 1,   verbose = TRUE )"},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"training-hyperparameters","dir":"Articles","previous_headings":"7. Training custom models","what":"Training hyperparameters","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"training procedure: Samples parameters uniform priors: κ∼U(0.1,10)\\kappa \\sim U(0.1, 10), σ∼U(0.1,3)\\sigma \\sim U(0.1, 3), ξ∼U(0.01,0.5)\\xi \\sim U(0.01, 0.5), θL∼U(0.1,20)\\theta_L \\sim U(0.1, 20), θU∼U(0.1,20)\\theta_U \\sim U(0.1, 20), θω∼U(0.01,0.49)\\theta_\\omega \\sim U(0.01, 0.49) Simulates bivariate data parameter set using rbegpd() Applies variance-stabilizing transformation: z̃=sign(z)log⁡(1+|z|)−1\\tilde{z} = \\mathrm{sign}(z)\\,\\log(1+|z|) - 1 Applies log transformation parameters: θ̃=log⁡(θ)\\tilde{\\theta} = \\log(\\theta) Trains neural network map z̃→θ̃\\tilde{z} \\\\tilde{\\theta}","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"neural-network-architecture","dir":"Articles","previous_headings":"","what":"8. Neural network architecture","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"neural estimator uses DeepSet architecture, naturally suited set-valued inputs (samples varying size). consists : ψ\\psi (encoder): Processes 2-dimensional observation shared Dense layers residual connections LayerNorm ϕ\\phi (aggregator): Aggregates encoded representations using mean pooling, concatenates expert summary statistic (S(Z)=log⁡n−7.7S(Z) = \\log n - 7.7), maps output dimension Expert statistic: log sample size provides network information precision input data NPE, output feeds normalising flow approximates full posterior distribution. NBE, ensemble five point estimators used, final estimate average.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/multivariate-egpd.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Bivariate BEGPD via Neural Bayes Estimation","text":"Alotaibi, N., Sainsbury-Dale, M., Naveau, P., Gaetan, C., Huser, R. (2025). Joint modeling low high extremes using multivariate extended generalized Pareto distribution. arXiv preprint arXiv:2509.05982. https://arxiv.org/abs/2509.05982 Sainsbury-Dale, M., Zammit-Mangion, ., Huser, R. (2024). Likelihood-free parameter estimation neural Bayes estimators. American Statistician, 78(1), 1–14. Naveau, P., Huser, R., Ribereau, P., Hannart, . (2016). Modeling jointly low, moderate, heavy rainfall intensities without threshold selection. Water Resources Research, 52(4), 2897–2911.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Parameter Estimate Coverage Assessment","text":"define helper function , given set true parameters, simulates n_rep datasets, fits egpd(), uses confint() obtain Wald 95% CIs response scale, checks whether true values covered.","code":"library(egpd) sim_param_coverage <- function(sigma, xi, kappa, n = 500, n_rep = 200,                                level = 0.95) {   true_vals <- c(sigma, xi, kappa)    # Matrices to store results: n_rep x 3   covered  <- matrix(NA, nrow = n_rep, ncol = 3)   estimates <- matrix(NA, nrow = n_rep, ncol = 3)   colnames(covered)  <- c(\"sigma\", \"xi\", \"kappa\")   colnames(estimates) <- c(\"sigma\", \"xi\", \"kappa\")    for (i in seq_len(n_rep)) {     y <- rdiscegpd(n, sigma = sigma, xi = xi, kappa = kappa, type = 1)     df <- data.frame(y = y)      fit <- tryCatch(       suppressMessages(egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),            data = df, family = \"degpd\", degpd.args = list(m = 1))),       error = function(e) NULL     )      if (is.null(fit)) next      ci <- tryCatch(       suppressWarnings(confint(fit, method = \"wald\", level = level)),       error = function(e) NULL     )     if (is.null(ci)) next      # Response-scale point estimates (level = 0 collapses CI to MLE)     estimates[i, ] <- confint(fit, method = \"wald\", level = 0)[, 1]      for (k in 1:3) {       if (!any(is.na(ci[k, ])))         covered[i, k] <- (true_vals[k] >= ci[k, 1]) &                           (true_vals[k] <= ci[k, 2])     }   }    # Coverage = fraction of successful fits where CI covers truth   ok <- complete.cases(covered)   cov_rate <- colMeans(covered[ok, , drop = FALSE])    # Relative bias = (estimate - true) / true   ok_est <- complete.cases(estimates)   rel_bias <- sweep(estimates[ok_est, , drop = FALSE], 2, true_vals, \"-\")   rel_bias <- sweep(rel_bias, 2, true_vals, \"/\")    list(coverage = cov_rate, n_ok = sum(ok), n_rep = n_rep,        estimates = estimates[ok_est, , drop = FALSE],        rel_bias = rel_bias,        true_vals = true_vals) }"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"varying-sigma","dir":"Articles","previous_headings":"","what":"Varying sigma","title":"Parameter Estimate Coverage Assessment","text":"fix xi = 0.2 kappa = 2, vary sigma across five values.","code":"set.seed(101) sigma_vals <- c(1, 2, 3, 5, 10) xi_fix <- 0.2 kappa_fix <- 2  res_sigma <- lapply(sigma_vals, function(s) {   sim_param_coverage(sigma = s, xi = xi_fix, kappa = kappa_fix) }) tab_sigma <- do.call(rbind, lapply(seq_along(sigma_vals), function(j) {   r <- res_sigma[[j]]   data.frame(sigma_true = sigma_vals[j],              cov_sigma = round(r$coverage[\"sigma\"], 3),              cov_xi    = round(r$coverage[\"xi\"], 3),              cov_kappa = round(r$coverage[\"kappa\"], 3),              n_ok      = r$n_ok) })) tab_sigma #>        sigma_true cov_sigma cov_xi cov_kappa n_ok #> sigma           1     0.905  0.970     0.894  199 #> sigma1          2     0.950  0.970     0.945  199 #> sigma2          3     0.960  0.965     0.945  200 #> sigma3          5     0.965  0.965     0.945  200 #> sigma4         10     0.980  0.945     0.945  200 se_cov <- sqrt(0.95 * 0.05 / 200)  plot(sigma_vals, tab_sigma$cov_sigma, type = \"b\", pch = 16,      col = \"steelblue\", lwd = 2, ylim = c(0.85, 1),      xlab = expression(sigma[true]), ylab = \"Coverage\",      main = expression(\"Coverage vs \" * sigma[true])) lines(sigma_vals, tab_sigma$cov_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2) lines(sigma_vals, tab_sigma$cov_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2) abline(h = 0.95, lty = 2, col = \"grey40\") rect(min(sigma_vals) - 1, 0.95 - 2 * se_cov,      max(sigma_vals) + 1, 0.95 + 2 * se_cov,      col = adjustcolor(\"grey70\", alpha.f = 0.3), border = NA) legend(\"bottomright\",        legend = c(expression(sigma), expression(xi), expression(kappa)),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\"),        pch = c(16, 17, 15), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"varying-xi","dir":"Articles","previous_headings":"","what":"Varying xi","title":"Parameter Estimate Coverage Assessment","text":"fix sigma = 3 kappa = 2, vary xi.","code":"set.seed(102) xi_vals <- c(0.05, 0.1, 0.2, 0.5, 1.0) sigma_fix <- 3  res_xi <- lapply(xi_vals, function(x) {   sim_param_coverage(sigma = sigma_fix, xi = x, kappa = kappa_fix) }) tab_xi <- do.call(rbind, lapply(seq_along(xi_vals), function(j) {   r <- res_xi[[j]]   data.frame(xi_true   = xi_vals[j],              cov_sigma = round(r$coverage[\"sigma\"], 3),              cov_xi    = round(r$coverage[\"xi\"], 3),              cov_kappa = round(r$coverage[\"kappa\"], 3),              n_ok      = r$n_ok) })) tab_xi #>        xi_true cov_sigma cov_xi cov_kappa n_ok #> sigma     0.05     0.905   0.91     0.940  200 #> sigma1    0.10     0.915   0.94     0.930  200 #> sigma2    0.20     0.945   0.95     0.950  200 #> sigma3    0.50     0.955   0.95     0.970  200 #> sigma4    1.00     0.965   0.95     0.975  199 plot(xi_vals, tab_xi$cov_sigma, type = \"b\", pch = 16,      col = \"steelblue\", lwd = 2, ylim = c(0.85, 1),      xlab = expression(xi[true]), ylab = \"Coverage\",      main = expression(\"Coverage vs \" * xi[true])) lines(xi_vals, tab_xi$cov_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2) lines(xi_vals, tab_xi$cov_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2) abline(h = 0.95, lty = 2, col = \"grey40\") rect(min(xi_vals) - 0.1, 0.95 - 2 * se_cov,      max(xi_vals) + 0.1, 0.95 + 2 * se_cov,      col = adjustcolor(\"grey70\", alpha.f = 0.3), border = NA) legend(\"bottomright\",        legend = c(expression(sigma), expression(xi), expression(kappa)),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\"),        pch = c(16, 17, 15), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"varying-kappa","dir":"Articles","previous_headings":"","what":"Varying kappa","title":"Parameter Estimate Coverage Assessment","text":"fix sigma = 3 xi = 0.2, vary kappa.","code":"set.seed(103) kappa_vals <- c(0.5, 1, 2, 3, 5) xi_fix2 <- 0.2  res_kappa <- lapply(kappa_vals, function(k) {   sim_param_coverage(sigma = sigma_fix, xi = xi_fix2, kappa = k) }) tab_kappa <- do.call(rbind, lapply(seq_along(kappa_vals), function(j) {   r <- res_kappa[[j]]   data.frame(kappa_true = kappa_vals[j],              cov_sigma  = round(r$coverage[\"sigma\"], 3),              cov_xi     = round(r$coverage[\"xi\"], 3),              cov_kappa  = round(r$coverage[\"kappa\"], 3),              n_ok       = r$n_ok) })) tab_kappa #>        kappa_true cov_sigma cov_xi cov_kappa n_ok #> sigma         0.5     0.905  0.950      0.93  200 #> sigma1        1.0     0.955  0.970      0.96  200 #> sigma2        2.0     0.945  0.955      0.94  200 #> sigma3        3.0     0.950  0.975      0.96  199 #> sigma4        5.0     0.960  0.970      0.96  200 plot(kappa_vals, tab_kappa$cov_sigma, type = \"b\", pch = 16,      col = \"steelblue\", lwd = 2, ylim = c(0.85, 1),      xlab = expression(kappa[true]), ylab = \"Coverage\",      main = expression(\"Coverage vs \" * kappa[true])) lines(kappa_vals, tab_kappa$cov_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2) lines(kappa_vals, tab_kappa$cov_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2) abline(h = 0.95, lty = 2, col = \"grey40\") rect(min(kappa_vals) - 0.5, 0.95 - 2 * se_cov,      max(kappa_vals) + 0.5, 0.95 + 2 * se_cov,      col = adjustcolor(\"grey70\", alpha.f = 0.3), border = NA) legend(\"bottomright\",        legend = c(expression(sigma), expression(xi), expression(kappa)),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\"),        pch = c(16, 17, 15), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"bias-and-precision","dir":"Articles","previous_headings":"","what":"Bias and precision","title":"Parameter Estimate Coverage Assessment","text":"Beyond coverage, useful check whether estimator approximately unbiased. boxplots show relative bias (estimate - true) / true parameter across 15 scenarios.","code":"# Combine all relative bias matrices with scenario labels make_bias_df <- function(res_list, varied_name, varied_vals, fixed_label) {   do.call(rbind, lapply(seq_along(varied_vals), function(j) {     rb <- as.data.frame(res_list[[j]]$rel_bias)     rb$scenario <- paste0(varied_name, \" = \", varied_vals[j])     rb$group <- fixed_label     rb   })) }  bias_sigma <- make_bias_df(res_sigma, \"sigma\", sigma_vals, \"Vary sigma\") bias_xi    <- make_bias_df(res_xi, \"xi\", xi_vals, \"Vary xi\") bias_kappa <- make_bias_df(res_kappa, \"kappa\", kappa_vals, \"Vary kappa\") bias_all   <- rbind(bias_sigma, bias_xi, bias_kappa) par(mfrow = c(1, 3), mar = c(7, 4, 3, 1))  boxplot(sigma ~ scenario, data = bias_sigma,         main = expression(\"Relative bias: \" * sigma),         ylab = \"(est - true) / true\", las = 2, col = \"steelblue\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\")  boxplot(xi ~ scenario, data = bias_sigma,         main = expression(\"Relative bias: \" * xi),         ylab = \"\", las = 2, col = \"firebrick\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\")  boxplot(kappa ~ scenario, data = bias_sigma,         main = expression(\"Relative bias: \" * kappa),         ylab = \"\", las = 2, col = \"forestgreen\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\") par(mfrow = c(1, 3), mar = c(7, 4, 3, 1))  boxplot(sigma ~ scenario, data = bias_xi,         main = expression(\"Relative bias: \" * sigma),         ylab = \"(est - true) / true\", las = 2, col = \"steelblue\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\")  boxplot(xi ~ scenario, data = bias_xi,         main = expression(\"Relative bias: \" * xi),         ylab = \"\", las = 2, col = \"firebrick\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\")  boxplot(kappa ~ scenario, data = bias_xi,         main = expression(\"Relative bias: \" * kappa),         ylab = \"\", las = 2, col = \"forestgreen\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\") par(mfrow = c(1, 3), mar = c(7, 4, 3, 1))  boxplot(sigma ~ scenario, data = bias_kappa,         main = expression(\"Relative bias: \" * sigma),         ylab = \"(est - true) / true\", las = 2, col = \"steelblue\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\")  boxplot(xi ~ scenario, data = bias_kappa,         main = expression(\"Relative bias: \" * xi),         ylab = \"\", las = 2, col = \"firebrick\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\")  boxplot(kappa ~ scenario, data = bias_kappa,         main = expression(\"Relative bias: \" * kappa),         ylab = \"\", las = 2, col = \"forestgreen\",         outline = FALSE) abline(h = 0, lty = 2, col = \"grey40\")"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"wald-summary","dir":"Articles","previous_headings":"","what":"Wald Summary","title":"Parameter Estimate Coverage Assessment","text":"Across 15 parameter combinations (5 values sigma, xi, kappa, varied one time), Wald 95% confidence intervals egpd() achieve empirical coverage close nominal 95% level. Key findings: Coverage well-calibrated: across scenarios, coverage rates cluster around 95%, well within Monte Carlo simulation error approximately 1.5 percentage points. Bias small: relative bias boxplots show parameter estimates approximately centred around true values. Small-sample bias visible extreme parameter values (e.g. small xi large kappa) diminishes sample size. Robustness: Wald intervals based observed information matrix (Vp) provide reliable frequentist coverage DEGPD model type 1 across range parameter configurations.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"profile-likelihood-confidence-intervals","dir":"Articles","previous_headings":"","what":"Profile Likelihood Confidence Intervals","title":"Parameter Estimate Coverage Assessment","text":"confint() method egpd objects supports Wald profile likelihood confidence intervals. Profile likelihood CIs invert likelihood ratio test rely normal approximation, can provide better coverage log-likelihood surface asymmetric sample size moderate. single-fit example comparing Wald profile CIs:","code":"set.seed(200) y <- rdiscegpd(500, sigma = 3, xi = 0.2, kappa = 2, type = 1) df <- data.frame(y = y) fit <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),             data = df, family = \"degpd\", degpd.args = list(m = 1))  ci_wald    <- confint(fit, method = \"wald\") ci_profile <- confint(fit, method = \"profile\")  cat(\"Wald CIs (response scale):\\n\") #> Wald CIs (response scale): print(ci_wald) #>           lower     upper #> scale 1.9367855 3.2081659 #> shape 0.1469172 0.3449858 #> kappa 1.9318300 3.1180295 cat(\"\\nProfile CIs (response scale):\\n\") #>  #> Profile CIs (response scale): print(ci_profile) #>           lower     upper #> scale 1.8889002 3.1513029 #> shape 0.1374116 0.3294722 #> kappa 1.9591248 3.1810526"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"wald-vs-profile-coverage","dir":"Articles","previous_headings":"","what":"Wald vs Profile Coverage","title":"Parameter Estimate Coverage Assessment","text":"now compare coverage Wald profile CIs across reduced grid parameter values (3 values per parameter, 100 replications per scenario) since profile likelihood optimisation expensive.","code":"sim_param_coverage_both <- function(sigma, xi, kappa, n = 500, n_rep = 100,                                     level = 0.95) {   true_vals <- c(sigma, xi, kappa)   nms <- c(\"sigma\", \"xi\", \"kappa\")    wald_covered    <- matrix(NA, nrow = n_rep, ncol = 3)   profile_covered <- matrix(NA, nrow = n_rep, ncol = 3)   colnames(wald_covered) <- colnames(profile_covered) <- nms    for (i in seq_len(n_rep)) {     y <- rdiscegpd(n, sigma = sigma, xi = xi, kappa = kappa, type = 1)     df <- data.frame(y = y)      fit <- tryCatch(       suppressMessages(egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),            data = df, family = \"degpd\", degpd.args = list(m = 1))),       error = function(e) NULL     )      if (is.null(fit)) next      ci_w <- tryCatch(suppressWarnings(confint(fit, method = \"wald\", level = level)),                      error = function(e) NULL)     ci_p <- tryCatch(suppressWarnings(confint(fit, method = \"profile\", level = level)),                      error = function(e) NULL)      if (!is.null(ci_w)) {       for (k in 1:3) {         if (!any(is.na(ci_w[k, ])))           wald_covered[i, k] <- (true_vals[k] >= ci_w[k, 1]) &                                  (true_vals[k] <= ci_w[k, 2])       }     }     if (!is.null(ci_p)) {       for (k in 1:3) {         if (!any(is.na(ci_p[k, ])))           profile_covered[i, k] <- (true_vals[k] >= ci_p[k, 1]) &                                     (true_vals[k] <= ci_p[k, 2])       }     }   }    ok_w <- complete.cases(wald_covered)   ok_p <- complete.cases(profile_covered)    list(     wald_coverage    = if (sum(ok_w) > 0) colMeans(wald_covered[ok_w, , drop = FALSE]) else rep(NA, 3),     profile_coverage = if (sum(ok_p) > 0) colMeans(profile_covered[ok_p, , drop = FALSE]) else rep(NA, 3),     n_ok_wald    = sum(ok_w),     n_ok_profile = sum(ok_p),     true_vals    = true_vals   ) }"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"varying-sigma-wald-vs-profile","dir":"Articles","previous_headings":"Wald vs Profile Coverage","what":"Varying sigma (Wald vs Profile)","title":"Parameter Estimate Coverage Assessment","text":"","code":"set.seed(301) sigma_vals_b <- c(1, 3, 10) xi_fix_b <- 0.2 kappa_fix_b <- 2  res_both_sigma <- lapply(sigma_vals_b, function(s) {   sim_param_coverage_both(sigma = s, xi = xi_fix_b, kappa = kappa_fix_b) })"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"varying-xi-wald-vs-profile","dir":"Articles","previous_headings":"Wald vs Profile Coverage","what":"Varying xi (Wald vs Profile)","title":"Parameter Estimate Coverage Assessment","text":"","code":"set.seed(302) xi_vals_b <- c(0.1, 0.2, 0.5)  res_both_xi <- lapply(xi_vals_b, function(x) {   sim_param_coverage_both(sigma = 3, xi = x, kappa = kappa_fix_b) })"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"varying-kappa-wald-vs-profile","dir":"Articles","previous_headings":"Wald vs Profile Coverage","what":"Varying kappa (Wald vs Profile)","title":"Parameter Estimate Coverage Assessment","text":"","code":"set.seed(303) kappa_vals_b <- c(0.5, 2, 5)  res_both_kappa <- lapply(kappa_vals_b, function(k) {   sim_param_coverage_both(sigma = 3, xi = xi_fix_b, kappa = k) })"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"coverage-comparison-tables","dir":"Articles","previous_headings":"Wald vs Profile Coverage","what":"Coverage comparison tables","title":"Parameter Estimate Coverage Assessment","text":"","code":"make_both_table <- function(res_list, varied_name, varied_vals) {   do.call(rbind, lapply(seq_along(varied_vals), function(j) {     r <- res_list[[j]]     data.frame(       param_value = varied_vals[j],       wald_sigma = round(r$wald_coverage[\"sigma\"], 3),       prof_sigma = round(r$profile_coverage[\"sigma\"], 3),       wald_xi    = round(r$wald_coverage[\"xi\"], 3),       prof_xi    = round(r$profile_coverage[\"xi\"], 3),       wald_kappa = round(r$wald_coverage[\"kappa\"], 3),       prof_kappa = round(r$profile_coverage[\"kappa\"], 3)     )   })) }  cat(\"Varying sigma:\\n\") #> Varying sigma: make_both_table(res_both_sigma, \"sigma\", sigma_vals_b) #>        param_value wald_sigma prof_sigma wald_xi prof_xi wald_kappa prof_kappa #> sigma            1       0.95       0.94    0.98    0.95       0.96       0.95 #> sigma1           3       0.97       0.96    0.98    0.96       0.97       0.96 #> sigma2          10       0.93       0.92    0.95    0.95       0.94       0.94  cat(\"\\nVarying xi:\\n\") #>  #> Varying xi: make_both_table(res_both_xi, \"xi\", xi_vals_b) #>        param_value wald_sigma prof_sigma wald_xi prof_xi wald_kappa prof_kappa #> sigma          0.1      0.900      0.910    0.95    0.92      0.970      0.970 #> sigma1         0.2      0.960      0.949    0.99    0.97      0.949      0.949 #> sigma2         0.5      0.929      0.940    0.96    0.95      0.970      0.950  cat(\"\\nVarying kappa:\\n\") #>  #> Varying kappa: make_both_table(res_both_kappa, \"kappa\", kappa_vals_b) #>        param_value wald_sigma prof_sigma wald_xi prof_xi wald_kappa prof_kappa #> sigma          0.5       0.96       0.97    0.99    0.98       0.96       0.97 #> sigma1         2.0       0.97       0.97    0.98    0.95       0.99       1.00 #> sigma2         5.0       0.97       0.96    0.99    0.98       0.94       0.97"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"coverage-comparison-plot","dir":"Articles","previous_headings":"Wald vs Profile Coverage","what":"Coverage comparison plot","title":"Parameter Estimate Coverage Assessment","text":"","code":"se_cov_b <- sqrt(0.95 * 0.05 / 100) par(mfrow = c(1, 3), mar = c(5, 4, 3, 1))  # --- Vary sigma --- tab_bs <- make_both_table(res_both_sigma, \"sigma\", sigma_vals_b) plot(sigma_vals_b, tab_bs$wald_sigma, type = \"b\", pch = 16,      col = \"steelblue\", lwd = 2, ylim = c(0.80, 1),      xlab = expression(sigma[true]), ylab = \"Coverage\",      main = expression(\"Vary \" * sigma)) lines(sigma_vals_b, tab_bs$prof_sigma, type = \"b\", pch = 16,       col = \"steelblue\", lwd = 2, lty = 2) lines(sigma_vals_b, tab_bs$wald_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2) lines(sigma_vals_b, tab_bs$prof_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2, lty = 2) lines(sigma_vals_b, tab_bs$wald_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2) lines(sigma_vals_b, tab_bs$prof_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2, lty = 2) abline(h = 0.95, lty = 3, col = \"grey40\") rect(min(sigma_vals_b) - 1, 0.95 - 2 * se_cov_b,      max(sigma_vals_b) + 1, 0.95 + 2 * se_cov_b,      col = adjustcolor(\"grey70\", alpha.f = 0.3), border = NA)  # --- Vary xi --- tab_bx <- make_both_table(res_both_xi, \"xi\", xi_vals_b) plot(xi_vals_b, tab_bx$wald_sigma, type = \"b\", pch = 16,      col = \"steelblue\", lwd = 2, ylim = c(0.80, 1),      xlab = expression(xi[true]), ylab = \"Coverage\",      main = expression(\"Vary \" * xi)) lines(xi_vals_b, tab_bx$prof_sigma, type = \"b\", pch = 16,       col = \"steelblue\", lwd = 2, lty = 2) lines(xi_vals_b, tab_bx$wald_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2) lines(xi_vals_b, tab_bx$prof_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2, lty = 2) lines(xi_vals_b, tab_bx$wald_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2) lines(xi_vals_b, tab_bx$prof_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2, lty = 2) abline(h = 0.95, lty = 3, col = \"grey40\") rect(min(xi_vals_b) - 0.05, 0.95 - 2 * se_cov_b,      max(xi_vals_b) + 0.05, 0.95 + 2 * se_cov_b,      col = adjustcolor(\"grey70\", alpha.f = 0.3), border = NA)  # --- Vary kappa --- tab_bk <- make_both_table(res_both_kappa, \"kappa\", kappa_vals_b) plot(kappa_vals_b, tab_bk$wald_sigma, type = \"b\", pch = 16,      col = \"steelblue\", lwd = 2, ylim = c(0.80, 1),      xlab = expression(kappa[true]), ylab = \"Coverage\",      main = expression(\"Vary \" * kappa)) lines(kappa_vals_b, tab_bk$prof_sigma, type = \"b\", pch = 16,       col = \"steelblue\", lwd = 2, lty = 2) lines(kappa_vals_b, tab_bk$wald_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2) lines(kappa_vals_b, tab_bk$prof_xi, type = \"b\", pch = 17,       col = \"firebrick\", lwd = 2, lty = 2) lines(kappa_vals_b, tab_bk$wald_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2) lines(kappa_vals_b, tab_bk$prof_kappa, type = \"b\", pch = 15,       col = \"forestgreen\", lwd = 2, lty = 2) abline(h = 0.95, lty = 3, col = \"grey40\") rect(min(kappa_vals_b) - 0.5, 0.95 - 2 * se_cov_b,      max(kappa_vals_b) + 0.5, 0.95 + 2 * se_cov_b,      col = adjustcolor(\"grey70\", alpha.f = 0.3), border = NA)  legend(\"bottomright\",        legend = c(expression(sigma * \" Wald\"), expression(sigma * \" Profile\"),                   expression(xi * \" Wald\"), expression(xi * \" Profile\"),                   expression(kappa * \" Wald\"), expression(kappa * \" Profile\")),        col = rep(c(\"steelblue\", \"firebrick\", \"forestgreen\"), each = 2),        pch = rep(c(16, 17, 15), each = 2), lwd = 2,        lty = rep(c(1, 2), 3), cex = 0.8)"},{"path":"https://sdwfrost.github.io/egpd/articles/parameter-coverage.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Parameter Estimate Coverage Assessment","text":"Across parameter combinations, Wald profile likelihood 95% confidence intervals egpd() achieve empirical coverage close nominal 95% level. Key findings: Wald CIs well-calibrated: across 15 scenarios (5 values sigma, xi, kappa), Wald coverage rates cluster around 95%, well within Monte Carlo simulation error. Profile CIs offer comparable improved coverage: profile likelihood intervals, rely normal approximation, tend match slightly improve Wald coverage, particularly parameters whose log-likelihood surface asymmetric (e.g. small xi extreme kappa). Bias small: relative bias boxplots confirm parameter estimates approximately centred around true values. Practical recommendation: intercept-models, profile likelihood CIs via confint(fit, method = \"profile\") provide useful complement default Wald intervals, especially small moderate sample sizes. models smooth terms covariates, Wald intervals remain primary option.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Predictive Coverage Assessment","text":"","code":"library(egpd) library(gamlss) library(bamlss)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"simulate-data","dir":"Articles","previous_headings":"","what":"1. Simulate data","title":"Predictive Coverage Assessment","text":"simulate 1000 observations discrete EGPD Model 1 known parameters. Using data three fits allows fair comparison.","code":"set.seed(42) n <- 1000 sigma_true <- 3 xi_true    <- 0.15 kappa_true <- 2  y <- rdiscegpd(n, sigma = sigma_true, xi = xi_true,                kappa = kappa_true, type = 1) df <- data.frame(y = y)  cat(\"n =\", n, \"\\n\") #> n = 1000 cat(\"Range:\", range(y), \"\\n\") #> Range: 0 38 cat(\"Mean:\", round(mean(y), 2), \"\\n\") #> Mean: 4.73"},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"egpd","dir":"Articles","previous_headings":"2. Fit models","what":"egpd","title":"Predictive Coverage Assessment","text":"","code":"fit_e <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),               data = df, family = \"degpd\", degpd.args = list(m = 1)) summary(fit_e) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.14        0.1   11.58   <2e-16 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -2.12       0.36   -5.87 2.23e-09 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.63       0.09    7.33 1.17e-13 #>  #> ** Smooth terms **"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"gamlss","dir":"Articles","previous_headings":"2. Fit models","what":"gamlss","title":"Predictive Coverage Assessment","text":"","code":"fit_g <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                 data = df, family = DEGPD1(),                 control = gamlss.control(n.cyc = 200, trace = FALSE))"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"bamlss","dir":"Articles","previous_headings":"2. Fit models","what":"bamlss","title":"Predictive Coverage Assessment","text":"","code":"fit_b <- bamlss(list(y ~ 1, ~ 1, ~ 1),                 data = df, family = degpd_bamlss(m = 1),                 verbose = FALSE)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"parameter-estimates","dir":"Articles","previous_headings":"2. Fit models","what":"Parameter estimates","title":"Predictive Coverage Assessment","text":"","code":"pars_e <- predict(fit_e, type = \"response\")[1, ] mu_g    <- exp(coef(fit_g, what = \"mu\")) sigma_g <- exp(coef(fit_g, what = \"sigma\")) nu_g    <- exp(coef(fit_g, what = \"nu\")) sigma_b <- exp(fit_b$parameters$sigma$p) xi_b    <- exp(fit_b$parameters$xi$p) kappa_b <- exp(fit_b$parameters$kappa$p)  data.frame(   parameter = c(\"sigma\", \"xi\", \"kappa\"),   true      = c(sigma_true, xi_true, kappa_true),   egpd      = round(as.numeric(unlist(pars_e)), 4),   gamlss    = round(c(mu_g, sigma_g, nu_g), 4),   bamlss    = round(c(sigma_b, xi_b, kappa_b), 4),   row.names = NULL ) #>   parameter true   egpd gamlss bamlss #> 1     sigma 3.00 3.1202 3.1009 3.1162 #> 2        xi 0.15 0.1198 0.1221 0.1203 #> 3     kappa 2.00 1.8744 1.8838 1.8763"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"predictive-coverage-at-the-95-level","dir":"Articles","previous_headings":"","what":"3. Predictive coverage at the 95% level","title":"Predictive Coverage Assessment","text":"evaluate plug-prediction (parameters fixed point estimates) parametric prediction (parameters perturbed link scale account estimation uncertainty). approaches achieve empirical coverage close nominal 95% level. parametric method tends produce slightly wider intervals accounts parameter uncertainty.","code":"set.seed(1) nsim <- 3000  # egpd cov_e_pi  <- predictive_coverage(fit_e, y, nsim = nsim, method = \"plug-in\") cov_e_par <- predictive_coverage(fit_e, y, nsim = nsim, method = \"parametric\")  # gamlss cov_g_pi  <- predictive_coverage(fit_g, y, nsim = nsim, method = \"plug-in\") cov_g_par <- predictive_coverage(fit_g, y, nsim = nsim, method = \"parametric\")  # bamlss cov_b_pi  <- predictive_coverage(fit_b, y, nsim = nsim, method = \"plug-in\") cov_b_par <- predictive_coverage(fit_b, y, nsim = nsim, method = \"parametric\")  data.frame(   approach    = rep(c(\"egpd\", \"gamlss\", \"bamlss\"), each = 2),   method      = rep(c(\"plug-in\", \"parametric\"), 3),   coverage    = round(c(cov_e_pi$coverage, cov_e_par$coverage,                         cov_g_pi$coverage, cov_g_par$coverage,                         cov_b_pi$coverage, cov_b_par$coverage), 4),   nominal     = 0.95,   row.names   = NULL ) #>   approach     method coverage nominal #> 1     egpd    plug-in    0.952    0.95 #> 2     egpd parametric    0.944    0.95 #> 3   gamlss    plug-in    0.961    0.95 #> 4   gamlss parametric    0.954    0.95 #> 5   bamlss    plug-in    0.949    0.95 #> 6   bamlss parametric    0.953    0.95"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"calibration-across-multiple-levels","dir":"Articles","previous_headings":"","what":"4. Calibration across multiple levels","title":"Predictive Coverage Assessment","text":"calibration plot checks whether empirical coverage tracks nominal level across range values. perfectly calibrated model falls diagonal.","code":"set.seed(2) levels <- seq(0.50, 0.99, by = 0.05) nsim_cal <- 3000  # Helper to compute coverage at multiple levels multi_coverage <- function(fit, y, levels, nsim, method) {   vapply(levels, function(lv) {     predictive_coverage(fit, y, level = lv, nsim = nsim,                         method = method)$coverage   }, numeric(1)) }  # Plug-in coverage cov_e_levels <- multi_coverage(fit_e, y, levels, nsim_cal, \"plug-in\") cov_g_levels <- multi_coverage(fit_g, y, levels, nsim_cal, \"plug-in\") cov_b_levels <- multi_coverage(fit_b, y, levels, nsim_cal, \"plug-in\")  # Parametric coverage cov_e_par_levels <- multi_coverage(fit_e, y, levels, nsim_cal, \"parametric\") cov_g_par_levels <- multi_coverage(fit_g, y, levels, nsim_cal, \"parametric\") cov_b_par_levels <- multi_coverage(fit_b, y, levels, nsim_cal, \"parametric\")"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"calibration-plot-plug-in-prediction","dir":"Articles","previous_headings":"4. Calibration across multiple levels","what":"Calibration plot: plug-in prediction","title":"Predictive Coverage Assessment","text":"","code":"plot(levels, levels, type = \"l\", lwd = 1, col = \"grey50\", lty = 2,      xlab = \"Nominal level\", ylab = \"Empirical coverage\",      main = \"Calibration plot (plug-in)\", xlim = c(0.5, 1), ylim = c(0.5, 1)) points(levels, cov_e_levels, pch = 16, col = \"steelblue\", cex = 1.2) lines(levels, cov_e_levels, col = \"steelblue\", lwd = 2) points(levels, cov_g_levels, pch = 17, col = \"firebrick\", cex = 1.2) lines(levels, cov_g_levels, col = \"firebrick\", lwd = 2) points(levels, cov_b_levels, pch = 15, col = \"forestgreen\", cex = 1.2) lines(levels, cov_b_levels, col = \"forestgreen\", lwd = 2) legend(\"bottomright\",        legend = c(\"egpd\", \"gamlss\", \"bamlss\", \"Ideal\"),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\", \"grey50\"),        pch = c(16, 17, 15, NA), lty = c(1, 1, 1, 2), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"calibration-plot-parametric-prediction","dir":"Articles","previous_headings":"4. Calibration across multiple levels","what":"Calibration plot: parametric prediction","title":"Predictive Coverage Assessment","text":"plots show three fitting approaches well-calibrated, empirical coverage closely tracking nominal level. small deviations expected discrete data — integer-valued nature response means exact coverage every level achievable.","code":"plot(levels, levels, type = \"l\", lwd = 1, col = \"grey50\", lty = 2,      xlab = \"Nominal level\", ylab = \"Empirical coverage\",      main = \"Calibration plot (parametric)\", xlim = c(0.5, 1), ylim = c(0.5, 1)) points(levels, cov_e_par_levels, pch = 16, col = \"steelblue\", cex = 1.2) lines(levels, cov_e_par_levels, col = \"steelblue\", lwd = 2) points(levels, cov_g_par_levels, pch = 17, col = \"firebrick\", cex = 1.2) lines(levels, cov_g_par_levels, col = \"firebrick\", lwd = 2) points(levels, cov_b_par_levels, pch = 15, col = \"forestgreen\", cex = 1.2) lines(levels, cov_b_par_levels, col = \"forestgreen\", lwd = 2) legend(\"bottomright\",        legend = c(\"egpd\", \"gamlss\", \"bamlss\", \"Ideal\"),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\", \"grey50\"),        pch = c(16, 17, 15, NA), lty = c(1, 1, 1, 2), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"calibration-with-a-covariate-dependent-model","dir":"Articles","previous_headings":"","what":"5. Calibration with a covariate-dependent model","title":"Predictive Coverage Assessment","text":"demonstrate coverage assessment covariates, simulate discrete EGPD data scale parameter varies smoothly covariate x.","code":"set.seed(7) n <- 1000 x <- runif(n, 0, 1) sigma_x <- exp(1 + 2 * x) xi_true  <- 0.3 kappa_true <- 1.5  y_s <- rdiscegpd(n, sigma = sigma_x, xi = xi_true,                  kappa = kappa_true, type = 1) df_s <- data.frame(y = y_s, x = x)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"fit-with-smooth-terms","dir":"Articles","previous_headings":"5. Calibration with a covariate-dependent model","what":"Fit with smooth terms","title":"Predictive Coverage Assessment","text":"","code":"fit_es <- egpd(list(lsigma = y ~ s(x, k = 10), lxi = ~ 1, lkappa = ~ 1),                data = df_s, family = \"degpd\", degpd.args = list(m = 1))  fit_gs <- gamlss(y ~ pb(x), sigma.formula = ~ 1, nu.formula = ~ 1,                  data = df_s, family = DEGPD1(),                  control = gamlss.control(n.cyc = 200, trace = FALSE))  fit_bs <- bamlss(list(y ~ s(x, k = 10), ~ 1, ~ 1),                  data = df_s, family = degpd_bamlss(m = 1),                  verbose = FALSE)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"calibration-across-levels","dir":"Articles","previous_headings":"5. Calibration with a covariate-dependent model","what":"Calibration across levels","title":"Predictive Coverage Assessment","text":"Even covariate-dependent parameters, three fitting approaches produce well-calibrated prediction intervals.","code":"set.seed(3) levels_s <- seq(0.50, 0.99, by = 0.05) nsim_s <- 3000  cov_es <- multi_coverage(fit_es, y_s, levels_s, nsim_s, \"plug-in\") cov_gs <- multi_coverage(fit_gs, y_s, levels_s, nsim_s, \"plug-in\") cov_bs <- multi_coverage(fit_bs, y_s, levels_s, nsim_s, \"plug-in\") plot(levels_s, levels_s, type = \"l\", lwd = 1, col = \"grey50\", lty = 2,      xlab = \"Nominal level\", ylab = \"Empirical coverage\",      main = \"Calibration plot (smooth covariate model)\",      xlim = c(0.5, 1), ylim = c(0.5, 1)) points(levels_s, cov_es, pch = 16, col = \"steelblue\", cex = 1.2) lines(levels_s, cov_es, col = \"steelblue\", lwd = 2) points(levels_s, cov_gs, pch = 17, col = \"firebrick\", cex = 1.2) lines(levels_s, cov_gs, col = \"firebrick\", lwd = 2) points(levels_s, cov_bs, pch = 15, col = \"forestgreen\", cex = 1.2) lines(levels_s, cov_bs, col = \"forestgreen\", lwd = 2) legend(\"bottomright\",        legend = c(\"egpd\", \"gamlss\", \"bamlss\", \"Ideal\"),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\", \"grey50\"),        pch = c(16, 17, 15, NA), lty = c(1, 1, 1, 2), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"out-of-sample-forecast-evaluation","dir":"Articles","previous_headings":"","what":"6. Out-of-sample forecast evaluation","title":"Predictive Coverage Assessment","text":"previous sections assessed -sample coverage: prediction intervals evaluated data used fit model. stringent test --sample (forecast) coverage, hold observations model never seen. relevant metric real forecasting applications. simulate larger covariate-dependent dataset, hold last 200 observations test set, fit training set, evaluate coverage held-data via newdata.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"simulate-traintest-split","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"Simulate train/test split","title":"Predictive Coverage Assessment","text":"","code":"set.seed(10) n_total <- 1200 n_test  <- 200 n_train <- n_total - n_test  x_all <- seq(0, 1, length.out = n_total) sigma_all <- exp(1 + 2 * x_all) xi_true_f  <- 0.3 kappa_true_f <- 1.5  y_all <- rdiscegpd(n_total, sigma = sigma_all, xi = xi_true_f,                    kappa = kappa_true_f, type = 1) df_all <- data.frame(y = y_all, x = x_all)  df_train <- df_all[1:n_train, ] df_test  <- df_all[(n_train + 1):n_total, ] y_test   <- df_test$y  cat(\"Training set: n =\", n_train, \"\\n\") #> Training set: n = 1000 cat(\"Test set:     n =\", n_test, \"\\n\") #> Test set:     n = 200 cat(\"Test x range:\", round(range(df_test$x), 3), \"\\n\") #> Test x range: 0.834 1"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"fit-models-on-training-data-only","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"Fit models on training data only","title":"Predictive Coverage Assessment","text":"","code":"fit_e_tr <- egpd(list(lsigma = y ~ s(x, k = 10), lxi = ~ 1, lkappa = ~ 1),                  data = df_train, family = \"degpd\", degpd.args = list(m = 1))  fit_g_tr <- gamlss(y ~ pb(x), sigma.formula = ~ 1, nu.formula = ~ 1,                    data = df_train, family = DEGPD1(),                    control = gamlss.control(n.cyc = 200, trace = FALSE))  fit_b_tr <- bamlss(list(y ~ s(x, k = 10), ~ 1, ~ 1),                    data = df_train, family = degpd_bamlss(m = 1),                    verbose = FALSE)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"out-of-sample-coverage-at-95","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"Out-of-sample coverage at 95%","title":"Predictive Coverage Assessment","text":"pass newdata = df_test predictions made test-set covariate values, compare held-responses y_test.","code":"set.seed(5) nsim_f <- 3000  fcov_e_pi  <- predictive_coverage(fit_e_tr, y_test, newdata = df_test,                                    nsim = nsim_f, method = \"plug-in\") fcov_e_par <- predictive_coverage(fit_e_tr, y_test, newdata = df_test,                                    nsim = nsim_f, method = \"parametric\")  fcov_g_pi  <- predictive_coverage(fit_g_tr, y_test, newdata = df_test,                                    nsim = nsim_f, method = \"plug-in\") fcov_g_par <- predictive_coverage(fit_g_tr, y_test, newdata = df_test,                                    nsim = nsim_f, method = \"parametric\")  fcov_b_pi  <- predictive_coverage(fit_b_tr, y_test, newdata = df_test,                                    nsim = nsim_f, method = \"plug-in\") fcov_b_par <- predictive_coverage(fit_b_tr, y_test, newdata = df_test,                                    nsim = nsim_f, method = \"parametric\")  data.frame(   approach    = rep(c(\"egpd\", \"gamlss\", \"bamlss\"), each = 2),   method      = rep(c(\"plug-in\", \"parametric\"), 3),   coverage    = round(c(fcov_e_pi$coverage, fcov_e_par$coverage,                         fcov_g_pi$coverage, fcov_g_par$coverage,                         fcov_b_pi$coverage, fcov_b_par$coverage), 4),   nominal     = 0.95,   row.names   = NULL ) #>   approach     method coverage nominal #> 1     egpd    plug-in    0.960    0.95 #> 2     egpd parametric    0.960    0.95 #> 3   gamlss    plug-in    0.945    0.95 #> 4   gamlss parametric    0.950    0.95 #> 5   bamlss    plug-in    0.955    0.95 #> 6   bamlss parametric    0.960    0.95"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"forecast-calibration-across-levels","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"Forecast calibration across levels","title":"Predictive Coverage Assessment","text":"","code":"set.seed(6) levels_f <- seq(0.50, 0.99, by = 0.05) nsim_fc  <- 3000  multi_coverage_oos <- function(fit, y, newdata, levels, nsim, method) {   vapply(levels, function(lv) {     predictive_coverage(fit, y, newdata = newdata, level = lv,                         nsim = nsim, method = method)$coverage   }, numeric(1)) }  # Plug-in fcov_e_lev <- multi_coverage_oos(fit_e_tr, y_test, df_test, levels_f, nsim_fc, \"plug-in\") fcov_g_lev <- multi_coverage_oos(fit_g_tr, y_test, df_test, levels_f, nsim_fc, \"plug-in\") fcov_b_lev <- multi_coverage_oos(fit_b_tr, y_test, df_test, levels_f, nsim_fc, \"plug-in\")  # Parametric fcov_e_par_lev <- multi_coverage_oos(fit_e_tr, y_test, df_test, levels_f, nsim_fc, \"parametric\") fcov_g_par_lev <- multi_coverage_oos(fit_g_tr, y_test, df_test, levels_f, nsim_fc, \"parametric\") fcov_b_par_lev <- multi_coverage_oos(fit_b_tr, y_test, df_test, levels_f, nsim_fc, \"parametric\")"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"forecast-calibration-plot-plug-in","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"Forecast calibration plot: plug-in","title":"Predictive Coverage Assessment","text":"","code":"plot(levels_f, levels_f, type = \"l\", lwd = 1, col = \"grey50\", lty = 2,      xlab = \"Nominal level\", ylab = \"Empirical coverage\",      main = \"Forecast calibration (plug-in)\",      xlim = c(0.5, 1), ylim = c(0.5, 1)) points(levels_f, fcov_e_lev, pch = 16, col = \"steelblue\", cex = 1.2) lines(levels_f, fcov_e_lev, col = \"steelblue\", lwd = 2) points(levels_f, fcov_g_lev, pch = 17, col = \"firebrick\", cex = 1.2) lines(levels_f, fcov_g_lev, col = \"firebrick\", lwd = 2) points(levels_f, fcov_b_lev, pch = 15, col = \"forestgreen\", cex = 1.2) lines(levels_f, fcov_b_lev, col = \"forestgreen\", lwd = 2) legend(\"bottomright\",        legend = c(\"egpd\", \"gamlss\", \"bamlss\", \"Ideal\"),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\", \"grey50\"),        pch = c(16, 17, 15, NA), lty = c(1, 1, 1, 2), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"forecast-calibration-plot-parametric","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"Forecast calibration plot: parametric","title":"Predictive Coverage Assessment","text":"","code":"plot(levels_f, levels_f, type = \"l\", lwd = 1, col = \"grey50\", lty = 2,      xlab = \"Nominal level\", ylab = \"Empirical coverage\",      main = \"Forecast calibration (parametric)\",      xlim = c(0.5, 1), ylim = c(0.5, 1)) points(levels_f, fcov_e_par_lev, pch = 16, col = \"steelblue\", cex = 1.2) lines(levels_f, fcov_e_par_lev, col = \"steelblue\", lwd = 2) points(levels_f, fcov_g_par_lev, pch = 17, col = \"firebrick\", cex = 1.2) lines(levels_f, fcov_g_par_lev, col = \"firebrick\", lwd = 2) points(levels_f, fcov_b_par_lev, pch = 15, col = \"forestgreen\", cex = 1.2) lines(levels_f, fcov_b_par_lev, col = \"forestgreen\", lwd = 2) legend(\"bottomright\",        legend = c(\"egpd\", \"gamlss\", \"bamlss\", \"Ideal\"),        col = c(\"steelblue\", \"firebrick\", \"forestgreen\", \"grey50\"),        pch = c(16, 17, 15, NA), lty = c(1, 1, 1, 2), lwd = 2)"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"forecast-prediction-intervals-vs-observations","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"Forecast prediction intervals vs observations","title":"Predictive Coverage Assessment","text":"useful visual check plot prediction intervals alongside held-observations. Points falling outside interval highlighted.  prediction band widens x, reflecting increasing scale parameter. Held-observations fall outside interval (red) roughly 5% total, matching nominal level.","code":"# Use egpd parametric intervals for illustration cov_plot <- fcov_e_par  outside <- !cov_plot$covered x_test <- df_test$x  plot(x_test, y_test, pch = 20, col = ifelse(outside, \"red\", \"grey50\"),      cex = ifelse(outside, 1.2, 0.8),      xlab = \"x\", ylab = \"y\",      main = sprintf(\"egpd forecast: 95%% prediction interval (coverage = %.1f%%)\",                     100 * cov_plot$coverage)) # Shade the prediction band ord <- order(x_test) polygon(c(x_test[ord], rev(x_test[ord])),         c(cov_plot$L[ord], rev(cov_plot$U[ord])),         col = adjustcolor(\"steelblue\", alpha.f = 0.2), border = NA) lines(x_test[ord], cov_plot$L[ord], col = \"steelblue\", lwd = 1.5) lines(x_test[ord], cov_plot$U[ord], col = \"steelblue\", lwd = 1.5) # Re-draw points on top points(x_test, y_test, pch = 20, col = ifelse(outside, \"red\", \"grey50\"),        cex = ifelse(outside, 1.2, 0.8)) legend(\"topleft\",        legend = c(\"Covered\", \"Outside\", \"95% PI\"),        col = c(\"grey50\", \"red\", \"steelblue\"),        pch = c(20, 20, NA), lty = c(NA, NA, 1), lwd = c(NA, NA, 1.5),        pt.cex = c(0.8, 1.2, NA))"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"in-sample-vs-out-of-sample-comparison","dir":"Articles","previous_headings":"6. Out-of-sample forecast evaluation","what":"In-sample vs out-of-sample comparison","title":"Predictive Coverage Assessment","text":"-sample --sample coverage close nominal 95% level, confirming models generalise well unseen data within covariate range.","code":"set.seed(7) # In-sample coverage on training data cov_in_e <- predictive_coverage(fit_e_tr, df_train$y,                                  nsim = nsim_f, method = \"parametric\") cov_in_g <- predictive_coverage(fit_g_tr, df_train$y,                                  nsim = nsim_f, method = \"parametric\") cov_in_b <- predictive_coverage(fit_b_tr, df_train$y,                                  nsim = nsim_f, method = \"parametric\")  data.frame(   approach    = rep(c(\"egpd\", \"gamlss\", \"bamlss\"), each = 2),   evaluation  = rep(c(\"in-sample\", \"out-of-sample\"), 3),   coverage    = round(c(cov_in_e$coverage, fcov_e_par$coverage,                         cov_in_g$coverage, fcov_g_par$coverage,                         cov_in_b$coverage, fcov_b_par$coverage), 4),   nominal     = 0.95,   row.names   = NULL ) #>   approach    evaluation coverage nominal #> 1     egpd     in-sample    0.935    0.95 #> 2     egpd out-of-sample    0.960    0.95 #> 3   gamlss     in-sample    0.945    0.95 #> 4   gamlss out-of-sample    0.950    0.95 #> 5   bamlss     in-sample    0.944    0.95 #> 6   bamlss out-of-sample    0.960    0.95"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"shortest-vs-equal-tailed-intervals","dir":"Articles","previous_headings":"","what":"7. Shortest vs equal-tailed intervals","title":"Predictive Coverage Assessment","text":"discrete data, equal-tailed intervals may optimal probability mass concentrated integers. use_shortest = TRUE option computes shortest (highest density region) interval instead. shortest interval achieves similar coverage narrower (equal) interval width, making efficient choice discrete data.","code":"set.seed(4)  cov_eq  <- predictive_coverage(fit_e, y, level = 0.95, nsim = 3000,                                 method = \"plug-in\", use_shortest = FALSE) cov_hdr <- predictive_coverage(fit_e, y, level = 0.95, nsim = 3000,                                 method = \"plug-in\", use_shortest = TRUE)  data.frame(   interval_type    = c(\"Equal-tailed\", \"Shortest (HDR)\"),   coverage         = round(c(cov_eq$coverage, cov_hdr$coverage), 4),   mean_width       = round(c(mean(cov_eq$U - cov_eq$L),                               mean(cov_hdr$U - cov_hdr$L)), 2),   row.names        = NULL ) #>    interval_type coverage mean_width #> 1   Equal-tailed    0.948      16.61 #> 2 Shortest (HDR)    0.955      13.85"},{"path":"https://sdwfrost.github.io/egpd/articles/predictive-coverage.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Predictive Coverage Assessment","text":"predictive_coverage() function provides straightforward way assess calibration EGPD-family models fitted via three supported frameworks. Key takeaways: three approaches (egpd, gamlss, bamlss) produce well-calibrated prediction intervals correctly specified data. parametric method accounts estimation uncertainty tends yield slightly wider intervals plug-method. --sample forecast coverage (fitting training set evaluating held-data) closely matches -sample coverage, confirming models generalise well. Prediction interval plots show interval widens regions higher variability, highlight outlying observations. discrete data, shortest (HDR) interval efficient equal-tailed intervals. Calibration plots useful diagnostic: deviations diagonal signal model misspecification inadequate uncertainty quantification.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"continuous-egpd-intercept-only","dir":"Articles","previous_headings":"","what":"1. Continuous EGPD: intercept-only","title":"Simulation Examples","text":"simulate continuous EGPD Model 1 G(u) = u^kappa fit model back. Compare fitted parameters truth response scale: Q-Q plot randomized quantile residuals confirms fit:","code":"library(egpd) set.seed(1)  # True parameters sigma_true <- 2 xi_true    <- 0.2 kappa_true <- 1.5  # Simulate n <- 2000 y <- regpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y, x = rep(1, n))  # Fit fit <- egpd(list(lpsi = y ~ 1, xi = ~ 1, lkappa = ~ 1),             data = df, family = \"egpd\", egpd.args = list(m = 1)) summary(fit) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.68       0.06   10.92   <2e-16 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.22       0.03    7.24 2.25e-13 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.39       0.05    8.39   <2e-16 #>  #> ** Smooth terms ** pars <- predict(fit, type = \"response\")[1, ] truth <- c(scale = sigma_true, shape = xi_true, kappa = kappa_true) cbind(true = truth, fitted = round(unlist(pars), 4)) #>       true fitted #> scale  2.0 1.9751 #> shape  0.2 0.2197 #> kappa  1.5 1.4738 set.seed(1) r <- rqresid(fit) qqnorm(r, main = \"Q-Q Plot (EGPD-1)\", pch = 20, col = \"grey60\") qqline(r, col = \"red\")"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"continuous-egpd-smooth-covariate-effect-on-scale","dir":"Articles","previous_headings":"","what":"2. Continuous EGPD: smooth covariate effect on scale","title":"Simulation Examples","text":"GAM framework allows parameter depend covariates smooth functions. scale parameter varies covariate x via sinusoidal function, shape kappa remain constant. Fit smooth term log-scale parameter: plot method shows estimated smooth effect. true function 0.5 + 1.5 * sin(2*pi*x) log-scale, centered around intercept.  can also extract predicted scale fine grid compare truth.","code":"set.seed(42) n <- 2000 x <- runif(n, 0, 1)  # Scale varies smoothly with x sigma_x <- exp(0.5 + 1.5 * sin(2 * pi * x)) xi_true  <- 0.1 kappa_true <- 1.5  y <- regpd(n, sigma = sigma_x, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y, x = x) fit_smooth <- egpd(list(lpsi = y ~ s(x, k = 15), xi = ~ 1, lkappa = ~ 1),                    data = df, family = \"egpd\", egpd.args = list(m = 1)) summary(fit_smooth) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.56       0.06   10.11   <2e-16 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.08       0.03    2.87  0.00202 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.41       0.04    9.29   <2e-16 #>  #> ** Smooth terms ** #>  #> logscale #>       edf max.df  Chi.sq Pr(>|t|) #> s(x) 9.63     14 2795.83   <2e-16 plot(fit_smooth) xgrid <- data.frame(x = seq(0, 1, length = 200)) pred <- predict(fit_smooth, newdata = xgrid, type = \"response\")  plot(xgrid$x, exp(0.5 + 1.5 * sin(2 * pi * xgrid$x)), type = \"l\",      lwd = 2, col = \"black\", ylim = c(0, 15),      xlab = \"x\", ylab = expression(sigma(x)),      main = \"Recovered smooth scale function\") lines(xgrid$x, pred$scale, col = \"steelblue\", lwd = 2, lty = 2) legend(\"topright\", legend = c(\"True\", \"Fitted\"),        col = c(\"black\", \"steelblue\"), lwd = 2, lty = c(1, 2))"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"discrete-degpd-parameter-recovery","dir":"Articles","previous_headings":"","what":"3. Discrete DEGPD: parameter recovery","title":"Simulation Examples","text":"Simulate Discrete EGPD Model 1 verify parameter recovery. Compare fitted empirical PMFs:  Q-Q plot randomized quantile residuals:","code":"set.seed(2) sigma_true <- 3 xi_true    <- 0.3 kappa_true <- 2.0  n <- 2000 y <- rdiscegpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true,                type = 1) df <- data.frame(y = y, x = rep(1, n))  fit_d <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),               data = df, family = \"degpd\", degpd.args = list(m = 1)) summary(fit_d) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.14       0.08   13.77   <2e-16 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -1.13        0.1  -11.01   <2e-16 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.63       0.07    9.38   <2e-16 #>  #> ** Smooth terms ** pars_d <- predict(fit_d, type = \"response\")[1, ] truth_d <- c(scale = sigma_true, shape = xi_true, kappa = kappa_true) cbind(true = truth_d, fitted = round(unlist(pars_d), 4)) #>       true fitted #> scale  3.0 3.1256 #> shape  0.3 0.3245 #> kappa  2.0 1.8724 xvals <- 0:20 emp_pmf <- tabulate(y + 1, nbins = max(xvals) + 1) / n fit_pmf <- ddiscegpd(xvals, sigma = pars_d$scale[1], xi = pars_d$shape[1],                      kappa = pars_d$kappa[1], type = 1)  plot(xvals, emp_pmf[seq_along(xvals)], type = \"h\", lwd = 3, col = \"grey60\",      main = \"Empirical vs fitted PMF (DEGPD-1)\",      xlab = \"Count\", ylab = \"Probability\") lines(xvals + 0.2, fit_pmf, type = \"h\", lwd = 3, col = \"steelblue\") legend(\"topright\", legend = c(\"Empirical\", \"Fitted\"),        col = c(\"grey60\", \"steelblue\"), lwd = 3) set.seed(1) r_d <- rqresid(fit_d) qqnorm(r_d, main = \"Q-Q Plot (DEGPD-1)\", pch = 20, col = \"grey60\") qqline(r_d, col = \"red\")"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"b--discrete-degpd-model-2-parameter-recovery","dir":"Articles","previous_headings":"","what":"3b. Discrete DEGPD Model 2: parameter recovery","title":"Simulation Examples","text":"Model 2 uses mixture two power transformations: G(u) = p·u^kappa1 + (1-p)·u^kappa2. simulate rdiscegpd() type = 6 recover five parameters. Compare fitted parameters truth response scale. Note reparameterization: kappa2 = kappa1 + exp(ldkappa), model estimates ldkappa (log difference) rather kappa2 directly. Q-Q plot randomized quantile residuals Model 2 fit:","code":"set.seed(22) sigma_true <- 3 xi_true    <- 0.3 kappa1_true <- 1.5 kappa2_true <- 3.0 prob_true   <- 0.6  n <- 2000 y <- rdiscegpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa1_true,                delta = kappa2_true, prob = prob_true, type = 6) df <- data.frame(y = y, x = rep(1, n))  cat(\"Range:\", range(y), \"\\n\") #> Range: 0 150 cat(\"Mean:\", mean(y), \"\\n\") #> Mean: 6.5425 fit_d2 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa1 = ~ 1, ldkappa = ~ 1,                     logitp = ~ 1),                data = df, family = \"degpd\", degpd.args = list(m = 2)) summary(fit_d2) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.23       0.36    0.65    0.259 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.84        0.1   -8.79   <2e-16 #>  #> logkappa1 #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.87       0.26     3.3 0.000492 #>  #> logdkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     2.15        0.6    3.57 0.000179 #>  #> logitp #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)        0       0.28       0    0.499 #>  #> ** Smooth terms ** pars_d2 <- predict(fit_d2, type = \"response\")[1, ] truth_d2 <- c(scale = sigma_true, shape = xi_true, kappa1 = kappa1_true,               kappa2 = kappa2_true, p = prob_true) fitted_d2 <- round(unlist(pars_d2), 4) cbind(true = truth_d2, fitted = fitted_d2) #>        true fitted #> scale   3.0 1.2624 #> shape   0.3 0.4299 #> kappa1  1.5 2.3865 #> kappa2  3.0 8.5558 #> p       0.6 0.4998 set.seed(1) r_d2 <- rqresid(fit_d2) qqnorm(r_d2, main = \"Q-Q Plot (DEGPD-2)\", pch = 20, col = \"grey60\") qqline(r_d2, col = \"red\")"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"c--discrete-degpd-model-5-truncated-normal-parameter-recovery","dir":"Articles","previous_headings":"","what":"3c. Discrete DEGPD Model 5: truncated normal parameter recovery","title":"Simulation Examples","text":"Model 5 uses truncated normal G-transformation. simulate verify parameter recovery.","code":"set.seed(55) sigma_true <- 3 xi_true    <- 0.3 kappa_true <- 2.0  n <- 2000 y <- rdiscegpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true,                type = 2) df <- data.frame(y = y, x = rep(1, n))  cat(\"Range:\", range(y), \"\\n\") #> Range: 0 120 cat(\"Mean:\", mean(y), \"\\n\") #> Mean: 4.934 fit_d5 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                data = df, family = \"degpd\", degpd.args = list(m = 5)) summary(fit_d5) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.13       0.09   13.24   <2e-16 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -1.15       0.12   -9.55   <2e-16 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.52       0.26       2   0.0226 #>  #> ** Smooth terms ** pars_d5 <- predict(fit_d5, type = \"response\")[1, ] truth_d5 <- c(scale = sigma_true, shape = xi_true, kappa = kappa_true) cbind(true = truth_d5, fitted = round(unlist(pars_d5), 4)) #>       true fitted #> scale  3.0 3.0847 #> shape  0.3 0.3169 #> kappa  2.0 1.6820 set.seed(1) r_d5 <- rqresid(fit_d5) qqnorm(r_d5, main = \"Q-Q Plot (DEGPD-5)\", pch = 20, col = \"grey60\") qqline(r_d5, col = \"red\")"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"d--discrete-degpd-model-6-truncated-beta-parameter-recovery","dir":"Articles","previous_headings":"","what":"3d. Discrete DEGPD Model 6: truncated beta parameter recovery","title":"Simulation Examples","text":"Model 6 uses truncated beta G-transformation. simulate verify parameter recovery.","code":"set.seed(66) sigma_true <- 3 xi_true    <- 0.3 kappa_true <- 2.0  n <- 2000 y <- rdiscegpd(n, sigma = sigma_true, xi = xi_true, kappa = kappa_true,                type = 3) df <- data.frame(y = y, x = rep(1, n))  cat(\"Range:\", range(y), \"\\n\") #> Range: 0 97 cat(\"Mean:\", mean(y), \"\\n\") #> Mean: 5.0585 fit_d6 <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                data = df, family = \"degpd\", degpd.args = list(m = 6)) summary(fit_d6) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.01       0.07   15.12   <2e-16 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -1.15        0.1  -11.11   <2e-16 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.85       0.08   11.32   <2e-16 #>  #> ** Smooth terms ** pars_d6 <- predict(fit_d6, type = \"response\")[1, ] truth_d6 <- c(scale = sigma_true, shape = xi_true, kappa = kappa_true) cbind(true = truth_d6, fitted = round(unlist(pars_d6), 4)) #>       true fitted #> scale  3.0 2.7320 #> shape  0.3 0.3178 #> kappa  2.0 2.3486 set.seed(1) r_d6 <- rqresid(fit_d6) #> Warning in qnorm(u): NaNs produced qqnorm(r_d6, main = \"Q-Q Plot (DEGPD-6)\", pch = 20, col = \"grey60\") qqline(r_d6, col = \"red\")"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"discrete-degpd-smooth-covariate-effect","dir":"Articles","previous_headings":"","what":"4. Discrete DEGPD: smooth covariate effect","title":"Simulation Examples","text":"Now simulate discrete data scale varies covariate.  Compare fitted true scale grid:","code":"set.seed(7) n <- 2000 x <- runif(n, 0, 1) sigma_x <- exp(1 + 2 * x) xi_true  <- 0.3 kappa_true <- 1.5  y <- rdiscegpd(n, sigma = sigma_x, xi = xi_true, kappa = kappa_true, type = 1) df <- data.frame(y = y, x = x) fit_ds <- egpd(list(lsigma = y ~ s(x, k = 10), lxi = ~ 1, lkappa = ~ 1),                data = df, family = \"degpd\", degpd.args = list(m = 1)) summary(fit_ds) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.98       0.07    27.9   <2e-16 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -1.11        0.1  -11.41   <2e-16 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.38       0.05    7.16 4.17e-13 #>  #> ** Smooth terms ** #>  #> logscale #>      edf max.df Chi.sq Pr(>|t|) #> s(x) 1.9      9 621.91   <2e-16 plot(fit_ds) xgrid <- data.frame(x = seq(0, 1, length = 200)) pred_ds <- predict(fit_ds, newdata = xgrid, type = \"response\")  plot(xgrid$x, exp(1 + 2 * xgrid$x), type = \"l\", lwd = 2, col = \"black\",      xlab = \"x\", ylab = expression(sigma(x)),      main = \"Recovered smooth scale function (DEGPD-1)\") lines(xgrid$x, pred_ds$scale, col = \"steelblue\", lwd = 2, lty = 2) legend(\"topleft\", legend = c(\"True\", \"Fitted\"),        col = c(\"black\", \"steelblue\"), lwd = 2, lty = c(1, 2))"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"zero-inflated-degpd-estimating-zero-inflation","dir":"Articles","previous_headings":"","what":"5. Zero-inflated DEGPD: estimating zero-inflation","title":"Simulation Examples","text":"Simulate ZIDEGPD known zero-inflation probability verify model recovers . Q-Q plot randomized quantile residuals ZIDEGPD fit:","code":"set.seed(3) sigma_true <- 3 xi_true    <- 0.3 kappa_true <- 1.5 pi_true    <- 0.3  n <- 2000 y <- rzidiscegpd(n, pi = pi_true, sigma = sigma_true, xi = xi_true,                  kappa = kappa_true, type = 1) df <- data.frame(y = y, x = rep(1, n))  cat(\"Proportion of zeros:\", mean(y == 0), \"\\n\") #> Proportion of zeros: 0.398 cat(\"Expected proportion: pi + (1-pi)*P(Y=0) =\",     round(pi_true + (1 - pi_true) * ddiscegpd(0, sigma = sigma_true,           xi = xi_true, kappa = kappa_true, type = 1), 3), \"\\n\") #> Expected proportion: pi + (1-pi)*P(Y=0) = 0.399 fit_zi <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1, logitpi = ~ 1),                data = df, family = \"zidegpd\", zidegpd.args = list(m = 1)) summary(fit_zi) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.12       0.17    6.53 3.22e-11 #>  #> logshape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -1.37       0.21   -6.53 3.22e-11 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.47       0.22    2.17   0.0149 #>  #> logitpi #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.78       0.13   -6.16 3.56e-10 #>  #> ** Smooth terms ** pars_zi <- predict(fit_zi, type = \"response\")[1, ] truth_zi <- c(scale = sigma_true, shape = xi_true, kappa = kappa_true,               pi = pi_true) cbind(true = truth_zi, fitted = round(unlist(pars_zi), 4)) #>       true fitted #> scale  3.0 3.0684 #> shape  0.3 0.2551 #> kappa  1.5 1.5995 #> pi     0.3 0.3141 set.seed(1) r_zi <- rqresid(fit_zi) qqnorm(r_zi, main = \"Q-Q Plot (ZIDEGPD-1)\", pch = 20, col = \"grey60\") qqline(r_zi, col = \"red\")"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"model-selection-degpd-vs-zidegpd","dir":"Articles","previous_headings":"","what":"6. Model selection: DEGPD vs ZIDEGPD","title":"Simulation Examples","text":"key question practice whether zero-inflation needed. fit DEGPD ZIDEGPD zero-inflated data compare AIC. ZIDEGPD model correctly fits better, confirming zero-inflation present data.","code":"fit_nozi <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),                  data = df, family = \"degpd\", degpd.args = list(m = 1))  data.frame(   Model = c(\"DEGPD-1 (no ZI)\", \"ZIDEGPD-1\"),   logLik = c(logLik(fit_nozi), logLik(fit_zi)),   AIC = c(AIC(fit_nozi), AIC(fit_zi)) ) #>             Model    logLik      AIC #> 1 DEGPD-1 (no ZI) -4555.870 9117.741 #> 2       ZIDEGPD-1 -4544.395 9096.789"},{"path":"https://sdwfrost.github.io/egpd/articles/simulation.html","id":"quantile-prediction","dir":"Articles","previous_headings":"","what":"7. Quantile prediction","title":"Simulation Examples","text":"predict method type = \"quantile\" computes quantile estimates fitted model.","code":"probs <- c(0.5, 0.9, 0.95, 0.99)  # Theoretical quantiles from the known distribution true_q <- qzidiscegpd(probs, pi = pi_true, sigma = sigma_true,                        xi = xi_true, kappa = kappa_true, type = 1)  # Fitted quantiles fit_q <- predict(fit_zi, type = \"quantile\", prob = probs)  data.frame(prob = probs,            true = true_q,            fitted = unlist(fit_q[1, ]),            empirical = quantile(y, probs)) #>        prob true fitted empirical #> q:0.5  0.50    1      1      1.00 #> q:0.9  0.90   10      9     10.00 #> q:0.95 0.95   14     14     14.00 #> q:0.99 0.99   30     27     27.01"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Continuous EGPD Models for Temperature Extremes","text":"EGPD generalises classical Generalized Pareto Distribution (GPD) prepending transformation G uniform component GPD. gives extra flexibility body distribution retaining Pareto tail behaviour. well-suited modelling threshold exceedances standard GPD may rigid bulk data. extract summer (June–August) daily maximum temperatures define exceedances 90th percentile.","code":"library(egpd) library(evgam) #>  #> Attaching package: 'evgam' #> The following objects are masked from 'package:egpd': #>  #>     dfbind, pinv, seq_between data(FCtmax)  FCtmax$month <- as.integer(format(FCtmax$date, \"%m\")) FCtmax$year  <- as.integer(format(FCtmax$date, \"%Y\"))  summer <- FCtmax[FCtmax$month %in% 6:8, ] thresh <- quantile(summer$tmax, 0.9) cat(\"90th percentile threshold:\", thresh, \"°C\\n\") #> 90th percentile threshold: 33.9 °C  exc_idx <- summer$tmax > thresh df <- data.frame(   y    = summer$tmax[exc_idx] - thresh,   year = summer$year[exc_idx] ) cat(\"Number of exceedances:\", nrow(df), \"out of\", nrow(summer), \"summer days\\n\") #> Number of exceedances: 395 out of 4593 summer days hist(df$y, breaks = 30, col = \"steelblue\", border = \"white\",      main = \"Summer temperature exceedances (Fort Collins, CO)\",      xlab = \"Exceedance above threshold (°C)\", ylab = \"Frequency\")"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"fitting-egpd-models","dir":"Articles","previous_headings":"","what":"Fitting EGPD models","title":"Continuous EGPD Models for Temperature Extremes","text":"continuous EGPD family egpd() uses three formula components models 1, 3, 5, 6: lpsi: log-scale parameter (sigma) xi: shape parameter (xi) lkappa ldelta: log-G-transformation parameter Model 4 fourth component (lkappa) addition ldelta.","code":""},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"egpd-model-1-power-transformation","dir":"Articles","previous_headings":"Fitting EGPD models","what":"EGPD Model 1: Power transformation","title":"Continuous EGPD Models for Temperature Extremes","text":"Model 1 uses G(u) = u^kappa. kappa = 1, reduces standard GPD. estimated kappa well 1, indicating standard GPD (kappa = 1) underfit body distribution.","code":"fit1 <- egpd(list(lpsi = y ~ 1, xi = ~ 1, lkappa = ~ 1),              data = df, family = \"egpd\", egpd.args = list(m = 1)) summary(fit1) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.56       0.31   -1.81   0.0351 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.16       0.11     1.4   0.0806 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.35        0.3    4.46 4.08e-06 #>  #> ** Smooth terms ** pars1 <- predict(fit1, type = \"response\")[1, ] cat(\"sigma =\", round(pars1$scale, 3),     \" xi =\", round(pars1$shape, 3),     \" kappa =\", round(pars1$kappa, 3), \"\\n\") #> sigma = 0.569  xi = 0.158  kappa = 3.855"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"egpd-model-3-incomplete-beta-transformation","dir":"Articles","previous_headings":"Fitting EGPD models","what":"EGPD Model 3: Incomplete beta transformation","title":"Continuous EGPD Models for Temperature Extremes","text":"Model 3 uses incomplete beta G-transformation parameter delta.","code":"fit3 <- egpd(list(lpsi = y ~ 1, xi = ~ 1, ldelta = ~ 1),              data = df, family = \"egpd\", egpd.args = list(m = 3)) summary(fit3) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.29       0.15    1.89   0.0294 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.17       0.07   -2.47  0.00682 #>  #> logdelta #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)      0.8       0.56    1.43   0.0767 #>  #> ** Smooth terms **"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"egpd-model-4-power-beta-transformation","dir":"Articles","previous_headings":"Fitting EGPD models","what":"EGPD Model 4: Power-beta transformation","title":"Continuous EGPD Models for Temperature Extremes","text":"Model 4 combines transformations parameters delta kappa.","code":"fit4 <- egpd(list(lpsi = y ~ 1, xi = ~ 1, ldelta = ~ 1, lkappa = ~ 1),              data = df, family = \"egpd\", egpd.args = list(m = 4)) summary(fit4) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.17       0.21   -0.81    0.209 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.02       0.09    0.21    0.418 #>  #> logdelta #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.75       0.33    5.26 7.35e-08 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.44       0.21    6.88    3e-12 #>  #> ** Smooth terms **"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"egpd-model-5-truncated-normal-transformation","dir":"Articles","previous_headings":"Fitting EGPD models","what":"EGPD Model 5: Truncated normal transformation","title":"Continuous EGPD Models for Temperature Extremes","text":"Model 5 uses truncated normal G-transformation parameter kappa.","code":"fit5 <- egpd(list(lpsi = y ~ 1, xi = ~ 1, lkappa = ~ 1),              data = df, family = \"egpd\", egpd.args = list(m = 5)) summary(fit5) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.95       0.39   -2.47  0.00669 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.36       0.14    2.66  0.00393 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     3.13       0.57    5.45 2.49e-08 #>  #> ** Smooth terms **"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"egpd-model-6-truncated-beta-transformation","dir":"Articles","previous_headings":"Fitting EGPD models","what":"EGPD Model 6: Truncated beta transformation","title":"Continuous EGPD Models for Temperature Extremes","text":"Model 6 uses truncated beta G-transformation parameter kappa.","code":"fit6 <- egpd(list(lpsi = y ~ 1, xi = ~ 1, lkappa = ~ 1),              data = df, family = \"egpd\", egpd.args = list(m = 6)) summary(fit6) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.33        0.2   -1.63   0.0516 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.12        0.1    1.19    0.117 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.66       0.27    6.15  3.8e-10 #>  #> ** Smooth terms **"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"model-comparison","dir":"Articles","previous_headings":"Fitting EGPD models","what":"Model comparison","title":"Continuous EGPD Models for Temperature Extremes","text":"","code":"aic_table <- data.frame(   Model  = c(\"EGPD-1\", \"EGPD-3\", \"EGPD-4\", \"EGPD-5\", \"EGPD-6\"),   npar   = c(3, 3, 4, 3, 3),   logLik = round(c(logLik(fit1), logLik(fit3), logLik(fit4),                    logLik(fit5), logLik(fit6)), 2),   AIC    = round(c(AIC(fit1), AIC(fit3), AIC(fit4),                    AIC(fit5), AIC(fit6)), 2) ) aic_table #>    Model npar  logLik    AIC #> 1 EGPD-1    3 -478.58 963.16 #> 2 EGPD-3    3 -483.65 973.29 #> 3 EGPD-4    4 -475.05 958.09 #> 4 EGPD-5    3 -482.75 971.51 #> 5 EGPD-6    3 -477.95 961.91"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"goodness-of-fit","dir":"Articles","previous_headings":"","what":"Goodness of fit","title":"Continuous EGPD Models for Temperature Extremes","text":"assess model fit using Q–Q plots randomised quantile residuals. model correct, residuals follow standard normal distribution.  can also compare fitted survivor function empirical one.","code":"set.seed(1) par(mfrow = c(3, 2))  r1 <- rqresid(fit1) qqnorm(r1, main = \"Q-Q Plot (EGPD-1)\", pch = 20, col = \"grey60\") qqline(r1, col = \"red\")  r3 <- rqresid(fit3) qqnorm(r3, main = \"Q-Q Plot (EGPD-3)\", pch = 20, col = \"grey60\") qqline(r3, col = \"red\")  r4 <- rqresid(fit4) qqnorm(r4, main = \"Q-Q Plot (EGPD-4)\", pch = 20, col = \"grey60\") qqline(r4, col = \"red\")  r5 <- rqresid(fit5) qqnorm(r5, main = \"Q-Q Plot (EGPD-5)\", pch = 20, col = \"grey60\") qqline(r5, col = \"red\")  r6 <- rqresid(fit6) qqnorm(r6, main = \"Q-Q Plot (EGPD-6)\", pch = 20, col = \"grey60\") qqline(r6, col = \"red\")  par(mfrow = c(1, 1)) y_sorted <- sort(df$y) n <- length(y_sorted) emp_surv <- 1 - (1:n) / (n + 1)  p1 <- predict(fit1, type = \"response\")[1, ] surv1 <- 1 - pegpd(y_sorted, sigma = p1$scale, xi = p1$shape,                     kappa = p1$kappa, type = 1)  p4 <- predict(fit4, type = \"response\")[1, ] surv4 <- 1 - pegpd(y_sorted, sigma = p4$scale, xi = p4$shape,                     delta = p4$delta, kappa = p4$kappa, type = 5)  plot(y_sorted, emp_surv, log = \"y\", pch = 20, col = \"grey50\",      xlab = \"Exceedance (°C)\", ylab = \"Survival probability\",      main = \"Empirical vs fitted survivor functions\") lines(y_sorted, surv1, col = \"steelblue\", lwd = 2) lines(y_sorted, surv4, col = \"firebrick\", lwd = 2, lty = 2) p5 <- predict(fit5, type = \"response\")[1, ] surv5 <- 1 - pegpd(y_sorted, sigma = p5$scale, xi = p5$shape,                     kappa = p5$kappa, type = 2)  p6 <- predict(fit6, type = \"response\")[1, ] surv6 <- 1 - pegpd(y_sorted, sigma = p6$scale, xi = p6$shape,                     kappa = p6$kappa, type = 3)  lines(y_sorted, surv5, col = \"darkgreen\", lwd = 2, lty = 3) lines(y_sorted, surv6, col = \"purple\", lwd = 2, lty = 4) legend(\"topright\", legend = c(\"Empirical\", \"EGPD-1\", \"EGPD-4\", \"EGPD-5\", \"EGPD-6\"),        col = c(\"grey50\", \"steelblue\", \"firebrick\", \"darkgreen\", \"purple\"),        pch = c(20, NA, NA, NA, NA), lty = c(NA, 1, 2, 3, 4),        lwd = c(NA, 2, 2, 2, 2))"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"modelling-trends-with-covariates","dir":"Articles","previous_headings":"","what":"Modelling trends with covariates","title":"Continuous EGPD Models for Temperature Extremes","text":"GAM framework allows parameters vary smoothly covariates. test whether scale parameter changed 50-year record fitting smooth year.","code":"fit1_yr <- egpd(list(lpsi = y ~ s(year, k = 5), xi = ~ 1, lkappa = ~ 1),                 data = df, family = \"egpd\", egpd.args = list(m = 1)) summary(fit1_yr) #>  #> ** Parametric terms ** #>  #> logscale #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)    -0.54       0.31   -1.75   0.0402 #>  #> shape #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     0.15       0.11    1.31   0.0956 #>  #> logkappa #>             Estimate Std. Error t value Pr(>|t|) #> (Intercept)     1.33        0.3    4.46 4.19e-06 #>  #> ** Smooth terms ** #>  #> logscale #>          edf max.df Chi.sq Pr(>|t|) #> s(year) 1.15      4   0.22    0.768 cat(\"\\nAIC (intercept-only):\", round(AIC(fit1), 2),     \"\\nAIC (year trend):    \", round(AIC(fit1_yr), 2), \"\\n\") #>  #> AIC (intercept-only): 963.16  #> AIC (year trend):     966.82 year_grid <- data.frame(year = 1970:2019) pred_yr <- predict(fit1_yr, newdata = year_grid, type = \"response\")  plot(year_grid$year, pred_yr$scale, type = \"l\", lwd = 2, col = \"steelblue\",      xlab = \"Year\", ylab = expression(hat(sigma)(year)),      main = \"Estimated scale parameter over time\")"},{"path":"https://sdwfrost.github.io/egpd/articles/temperature-extremes.html","id":"quantile-predictions","dir":"Articles","previous_headings":"","what":"Quantile predictions","title":"Continuous EGPD Models for Temperature Extremes","text":"predict method type = \"quantile\" computes quantiles fitted model. quantiles exceedance distribution. obtain return levels original temperature scale, add threshold (33.9 °C) back.","code":"probs <- c(0.5, 0.9, 0.95, 0.99) qpred <- predict(fit1, type = \"quantile\", prob = probs) emp_q <- quantile(df$y, probs)  data.frame(   probability = probs,   empirical   = round(as.numeric(emp_q), 3),   fitted      = round(as.numeric(unlist(qpred[1, ])), 3),   row.names   = NULL ) #>   probability empirical fitted #> 1        0.50       1.1  1.188 #> 2        0.90       2.8  2.772 #> 3        0.95       3.3  3.531 #> 4        0.99       4.4  5.617"},{"path":"https://sdwfrost.github.io/egpd/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Touqeer Ahmad. Author, maintainer. Simon Frost. Author.","code":""},{"path":"https://sdwfrost.github.io/egpd/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ahmad T, Frost S (2026). egpd: Extended Generalized Pareto Distribution GAMs. R package version 0.1.0, https://github.com/sdwfrost/egpd.","code":"@Manual{,   title = {egpd: Extended Generalized Pareto Distribution GAMs},   author = {Touqeer Ahmad and Simon Frost},   year = {2026},   note = {R package version 0.1.0},   url = {https://github.com/sdwfrost/egpd}, }"},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"egpd-extended-generalized-pareto-distribution-gams","dir":"","previous_headings":"","what":"Extended Generalized Pareto Distribution GAMs","title":"Extended Generalized Pareto Distribution GAMs","text":"egpd package fits Extended Generalized Pareto Distribution (EGPD), Discrete EGPD (DEGPD), Zero-Inflated Discrete EGPD (ZIDEGPD) models within GAM (Generalized Additive Model) framework, additional support fitting via gamlss bamlss. fitting infrastructure adapted evgam package Ben Youngman. Models 1–6 supported distribution family. Models 1–4 follow parameterizations Naveau et al. (2016), Models 5–6 follow Gamet & Jalbert (2022). model extends standard GPD composing transformation function G: σ GPD scale, ξ GPD shape, remaining parameters control G-function.","code":""},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Extended Generalized Pareto Distribution GAMs","text":"Install development version GitHub:","code":"# install.packages(\"remotes\") remotes::install_github(\"sdwfrost/egpd\")"},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Extended Generalized Pareto Distribution GAMs","text":"","code":"library(egpd)  # Fit a DEGPD model to insurance complaint counts data(ny_complaints) fit <- egpd(   list(upheld ~ s(year), ~ 1, ~ 1),   data = ny_complaints,   family = \"degpd\",   degpd.args = list(m = 1) ) summary(fit)"},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"bivariate-egpd-begpd","dir":"","previous_headings":"","what":"Bivariate EGPD (BEGPD)","title":"Extended Generalized Pareto Distribution GAMs","text":"package also supports bivariate Bivariate EGPD (BEGPD) fitting via neural Bayes estimation, using pre-trained neural networks. requires Julia (>= 1.11) additional dependencies.","code":""},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"additional-dependencies","dir":"","previous_headings":"Bivariate EGPD (BEGPD)","what":"Additional dependencies","title":"Extended Generalized Pareto Distribution GAMs","text":"install required Julia packages:","code":"# R packages install.packages(\"JuliaConnectoR\") remotes::install_github(\"msainsburydale/NeuralEstimators\") using Pkg Pkg.add([\"NeuralEstimators\", \"Flux\"])"},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"quick-start-bivariate-begpd","dir":"","previous_headings":"Bivariate EGPD (BEGPD)","what":"Quick start (bivariate BEGPD)","title":"Extended Generalized Pareto Distribution GAMs","text":"","code":"library(egpd)  # Simulate bivariate BEGPD data (no Julia needed) Y <- rbegpd(1000, kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2)  # Fit using neural posterior estimation (requires Julia) fit <- fitegpd(Y, family = \"begpd\", method = \"neuralbayes\", estimator = \"npe\") summary(fit) plot(fit)  # Train your own model (optional) paths <- train_begpd(savepath = \"my_models\", quick = TRUE) fit2 <- fitegpd(Y, family = \"begpd\", method = \"neuralbayes\",                 model.path = paths$npe, estimator = \"npe\")"},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"discrete-extensions-experimental","dir":"","previous_headings":"Bivariate EGPD (BEGPD)","what":"Discrete extensions (Experimental)","title":"Extended Generalized Pareto Distribution GAMs","text":"package also provides experimental bivariate discrete EGPD (family=\"bdegpd\") zero-inflated bivariate discrete EGPD (family=\"bzidegpd\") distributions, constructed applying floor() continuous BEGPD samples. use neural Bayes estimation framework:","code":"# Simulate and fit bivariate discrete EGPD Y <- rbdegpd(1000, kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2) fit <- fitegpd(Y, family = \"bdegpd\", method = \"neuralbayes\", estimator = \"npe\")  # Zero-inflated version Y_zi <- rbzidegpd(1000, kappa = 2, sigma = 1, xi = 0.1,                    thL = 5, thU = 5, thw = 0.2, pi0 = 0.3) fit_zi <- fitegpd(Y_zi, family = \"bzidegpd\", method = \"neuralbayes\", estimator = \"npe\")"},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"mdgpd-multivariate-discrete-gpd-experimental","dir":"","previous_headings":"Bivariate EGPD (BEGPD)","what":"MDGPD: Multivariate Discrete GPD (Experimental)","title":"Extended Generalized Pareto Distribution GAMs","text":"package also includes Aka-Kratz-Naveau (2025) Multivariate Discrete Generalized Pareto Distribution (family=\"mdgpd\"), provides theoretically rigorous discrete bivariate GPD threshold stability. construction uses bivariate Poisson generator geometric maximum: details, see Aka, Kratz & Naveau (2025), arXiv:2506.19361. details BEGPD, see Alotaibi, Sainsbury-Dale, Naveau, Gaetan & Huser (2025), arXiv:2509.05982.","code":"# Simulate bivariate MDGPD Y <- rmdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5) fit <- fitegpd(Y, family = \"mdgpd\", method = \"neuralbayes\", estimator = \"npe\")"},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Extended Generalized Pareto Distribution GAMs","text":"Discrete EGPD Models Insurance Complaint Counts Zero-Inflated Discrete EGPD Models Doctor Visit Counts Threshold Exceedance Modeling DEGPD Continuous EGPD Models Temperature Extremes Fitting Continuous Distributions fitegpd Fitting Discrete Distributions fitegpd Bivariate BEGPD via Neural Bayes Estimation Bivariate Discrete EGPD via Neural Bayes Estimation Multivariate Discrete GPD (MDGPD) via Neural Bayes Estimation Simulation Examples Comparing egpd bamlss Fits Comparing egpd gamlss Fits Predictive Coverage Assessment Parameter Estimate Coverage Assessment","code":""},{"path":"https://sdwfrost.github.io/egpd/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Extended Generalized Pareto Distribution GAMs","text":"Alotaibi, N., Sainsbury-Dale, M., Naveau, P., Gaetan, C., Huser, R. (2025). Joint modeling low high extremes using multivariate extended generalized Pareto distribution. arXiv preprint arXiv:2509.05982. https://arxiv.org/abs/2509.05982 Ailliot, P., Gaetan, C., & Naveau, P. (2026). parsimonious tail compliant multiscale statistical model aggregated rainfall. Advances Water Resources, 208, 105216.https://doi.org/10.1016/j.advwatres.2026.105216 Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. Communications Statistics-Simulation Computation, 1-17. https://doi.org/10.1080/03610918.2025.2585398 Ahmad, T. Arshad, . . (2026). New flexible versions extended generalized Pareto model count data. Journal Applied Statistics. https://arxiv.org/abs/2409.18719 Ahmad, T. Hussain, . (2025). Flexible model varying levels zeros outliers count data. arXiv preprint arXiv:2510.27365. https://arxiv.org/abs/2510.27365 Ahmad, T., Gaetan, C., & Naveau, P. (2025). extended generalized Pareto regression model count data. Statistical Modelling, 25(5), 416-431. https://doi.org/10.1177/1471082X241266729 Carrer, N. L., & Gaetan, C. (2022). Distributional regression models Extended Generalized Pareto distributions. arXiv preprint arXiv:2209.04660.https://doi.org/10.48550/arXiv.2209.04660 Gamet, P. Jalbert, J. (2022). flexible extended generalized Pareto distribution tail estimation. Environmetrics, 33(4), e2714.https://doi.org/10.1002/env.2744 Naveau, P., Huser, R., Ribereau, P., Hannart, . (2016). Modeling jointly low, moderate, heavy rainfall intensities without threshold selection. Water Resources Research, 52(4), 2897–2911.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD1.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Continuous EGPD Model 1 — EGPD1","title":"gamlss Family for Continuous EGPD Model 1 — EGPD1","text":"EGPD1() function defines gamlss.family distribution fitting continuous Extended Generalized Pareto Distribution model 1 (power G-transformation: \\(G(u) = u^\\kappa\\)). functions dEGPD1, pEGPD1, qEGPD1,   rEGPD1 define density, distribution function, quantile   function, random generation distribution using gamlss   parameter names.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Continuous EGPD Model 1 — EGPD1","text":"","code":"EGPD1(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\")  dEGPD1(x, mu = 1, sigma = 0.5, nu = 1, log = FALSE) pEGPD1(q, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) qEGPD1(p, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) rEGPD1(n, mu = 1, sigma = 0.5, nu = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Continuous EGPD Model 1 — EGPD1","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma EGPD notation), positive sigma GPD shape parameter (xi EGPD notation), positive nu G-transformation parameter (kappa EGPD notation), positive log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Continuous EGPD Model 1 — EGPD1","text":"EGPD1() returns object class \"gamlss.family\". dEGPD1 gives density, pEGPD1 gives distribution   function, qEGPD1 gives quantile function, rEGPD1   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"gamlss Family for Continuous EGPD Model 1 — EGPD1","text":"gamlss parameters map EGPD parameters :   mu = sigma (GPD scale), sigma = xi (GPD shape),   nu = kappa (G-transformation power). First derivatives computed numerically via central finite differences;   second derivatives use outer product gradients (OPG) approximation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Continuous EGPD Model 1 — EGPD1","text":"Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gamlss Family for Continuous EGPD Model 1 — EGPD1","text":"","code":"if (FALSE) { # \\dontrun{   library(gamlss)   set.seed(1)   y <- rEGPD1(500, mu = 2, sigma = 0.2, nu = 1.5)   fit <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                 family = EGPD1()) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD3.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Continuous EGPD Model 3 — EGPD3","title":"gamlss Family for Continuous EGPD Model 3 — EGPD3","text":"EGPD3() function defines gamlss.family distribution   fitting continuous Extended Generalized Pareto Distribution   model 3 (incomplete beta G-transformation). functions dEGPD3, pEGPD3, qEGPD3,   rEGPD3 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Continuous EGPD Model 3 — EGPD3","text":"","code":"EGPD3(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\")  dEGPD3(x, mu = 1, sigma = 0.5, nu = 1, log = FALSE) pEGPD3(q, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) qEGPD3(p, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) rEGPD3(n, mu = 1, sigma = 0.5, nu = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Continuous EGPD Model 3 — EGPD3","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (delta), positive log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Continuous EGPD Model 3 — EGPD3","text":"EGPD3() returns object class \"gamlss.family\". dEGPD3 gives density, pEGPD3 gives distribution   function, qEGPD3 gives quantile function, rEGPD3   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD3.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Continuous EGPD Model 3 — EGPD3","text":"Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD4.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Continuous EGPD Model 4 — EGPD4","title":"gamlss Family for Continuous EGPD Model 4 — EGPD4","text":"EGPD4() function defines gamlss.family distribution   fitting continuous Extended Generalized Pareto Distribution   model 4 (power-beta G-transformation). 4-parameter family. functions dEGPD4, pEGPD4, qEGPD4,   rEGPD4 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Continuous EGPD Model 4 — EGPD4","text":"","code":"EGPD4(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",       tau.link = \"log\")  dEGPD4(x, mu = 1, sigma = 0.5, nu = 1, tau = 1, log = FALSE) pEGPD4(q, mu = 1, sigma = 0.5, nu = 1, tau = 1, lower.tail = TRUE,        log.p = FALSE) qEGPD4(p, mu = 1, sigma = 0.5, nu = 1, tau = 1, lower.tail = TRUE,        log.p = FALSE) rEGPD4(n, mu = 1, sigma = 0.5, nu = 1, tau = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD4.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Continuous EGPD Model 4 — EGPD4","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"log\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (delta), positive tau G-transformation parameter (kappa), positive log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD4.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Continuous EGPD Model 4 — EGPD4","text":"EGPD4() returns object class \"gamlss.family\". dEGPD4 gives density, pEGPD4 gives distribution   function, qEGPD4 gives quantile function, rEGPD4   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD4.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Continuous EGPD Model 4 — EGPD4","text":"Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD5.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Continuous EGPD Model 5 — EGPD5","title":"gamlss Family for Continuous EGPD Model 5 — EGPD5","text":"EGPD5() function defines gamlss.family distribution   fitting continuous Extended Generalized Pareto Distribution   model 5 (truncated normal G-transformation:   \\(G(u) = (\\Phi(\\sqrt{\\kappa}(u-1)) - \\Phi(-\\sqrt{\\kappa})) / (0.5 - \\Phi(-\\sqrt{\\kappa}))\\)). functions dEGPD5, pEGPD5, qEGPD5,   rEGPD5 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Continuous EGPD Model 5 — EGPD5","text":"","code":"EGPD5(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\")  dEGPD5(x, mu = 1, sigma = 0.5, nu = 1, log = FALSE) pEGPD5(q, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) qEGPD5(p, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) rEGPD5(n, mu = 1, sigma = 0.5, nu = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Continuous EGPD Model 5 — EGPD5","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Continuous EGPD Model 5 — EGPD5","text":"EGPD5() returns object class \"gamlss.family\". dEGPD5 gives density, pEGPD5 gives distribution   function, qEGPD5 gives quantile function, rEGPD5   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD5.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Continuous EGPD Model 5 — EGPD5","text":"Gamet, P. Jalbert, J. (2022). flexible extended generalized Pareto distribution tail estimation. Environmetrics, 33(6), e2744.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD5.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gamlss Family for Continuous EGPD Model 5 — EGPD5","text":"","code":"if (FALSE) { # \\dontrun{   library(gamlss)   set.seed(1)   y <- rEGPD5(500, mu = 2, sigma = 0.2, nu = 1.5)   fit <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                 family = EGPD5()) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD6.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Continuous EGPD Model 6 — EGPD6","title":"gamlss Family for Continuous EGPD Model 6 — EGPD6","text":"EGPD6() function defines gamlss.family distribution   fitting continuous Extended Generalized Pareto Distribution   model 6 (truncated beta G-transformation). functions dEGPD6, pEGPD6, qEGPD6,   rEGPD6 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD6.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Continuous EGPD Model 6 — EGPD6","text":"","code":"EGPD6(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\")  dEGPD6(x, mu = 1, sigma = 0.5, nu = 1, log = FALSE) pEGPD6(q, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) qEGPD6(p, mu = 1, sigma = 0.5, nu = 1, lower.tail = TRUE, log.p = FALSE) rEGPD6(n, mu = 1, sigma = 0.5, nu = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD6.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Continuous EGPD Model 6 — EGPD6","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD6.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Continuous EGPD Model 6 — EGPD6","text":"EGPD6() returns object class \"gamlss.family\". dEGPD6 gives density, pEGPD6 gives distribution   function, qEGPD6 gives quantile function, rEGPD6   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD6.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Continuous EGPD Model 6 — EGPD6","text":"Gamet, P. Jalbert, J. (2022). flexible extended generalized Pareto distribution tail estimation. Environmetrics, 33(6), e2744.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/EGPD6.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gamlss Family for Continuous EGPD Model 6 — EGPD6","text":"","code":"if (FALSE) { # \\dontrun{   library(gamlss)   set.seed(1)   y <- rEGPD6(500, mu = 2, sigma = 0.2, nu = 1.5)   fit <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                 family = EGPD6()) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD1.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Discrete EGPD Model 1 — ZIDEGPD1","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 1 — ZIDEGPD1","text":"ZIDEGPD1() function defines gamlss.family distribution   fitting zero-inflated discrete Extended Generalized Pareto   Distribution model 1 (power G-transformation). functions dZIDEGPD1, pZIDEGPD1, qZIDEGPD1,   rZIDEGPD1 define PMF, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 1 — ZIDEGPD1","text":"","code":"ZIDEGPD1(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",          tau.link = \"logit\")  dZIDEGPD1(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIDEGPD1(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) qZIDEGPD1(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) rZIDEGPD1(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 1 — ZIDEGPD1","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles (non-negative integers) p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 1 — ZIDEGPD1","text":"ZIDEGPD1() returns object class \"gamlss.family\". dZIDEGPD1 gives PMF, pZIDEGPD1 gives distribution   function, qZIDEGPD1 gives quantile function, rZIDEGPD1   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 1 — ZIDEGPD1","text":"Ahmad, T. Arshad, . . (2024). New flexible versions extended generalized Pareto model count data. arXiv preprint arXiv:2409.18719. https://arxiv.org/abs/2409.18719 Ahmad, T. Hussain, . (2025). Flexible model varying levels zeros outliers count data. arXiv preprint arXiv:2510.27365. https://arxiv.org/abs/2510.27365","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 1 — ZIDEGPD1","text":"","code":"if (FALSE) { # \\dontrun{   library(gamlss)   set.seed(1)   y <- rZIDEGPD1(500, mu = 3, sigma = 0.15, nu = 2, tau = 0.25)   fit <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                 tau.formula = ~ 1, family = ZIDEGPD1()) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD3.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Discrete EGPD Model 3 — ZIDEGPD3","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 3 — ZIDEGPD3","text":"ZIDEGPD3() function defines gamlss.family distribution   fitting zero-inflated discrete Extended Generalized Pareto   Distribution model 3 (incomplete beta G-transformation). functions dZIDEGPD3, pZIDEGPD3, qZIDEGPD3,   rZIDEGPD3 define PMF, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 3 — ZIDEGPD3","text":"","code":"ZIDEGPD3(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",          tau.link = \"logit\")  dZIDEGPD3(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIDEGPD3(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) qZIDEGPD3(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) rZIDEGPD3(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 3 — ZIDEGPD3","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles (non-negative integers) p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (delta), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 3 — ZIDEGPD3","text":"ZIDEGPD3() returns object class \"gamlss.family\". dZIDEGPD3 gives PMF, pZIDEGPD3 gives distribution   function, qZIDEGPD3 gives quantile function, rZIDEGPD3   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD3.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 3 — ZIDEGPD3","text":"Ahmad, T. Arshad, . . (2024). New flexible versions extended generalized Pareto model count data. arXiv preprint arXiv:2409.18719. https://arxiv.org/abs/2409.18719 Ahmad, T. Hussain, . (2025). Flexible model varying levels zeros outliers count data. arXiv preprint arXiv:2510.27365. https://arxiv.org/abs/2510.27365","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD5.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Discrete EGPD Model 5 — ZIDEGPD5","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 5 — ZIDEGPD5","text":"ZIDEGPD5() function defines gamlss.family distribution   fitting zero-inflated discrete Extended Generalized Pareto   Distribution model 5 (truncated normal G-transformation). functions dZIDEGPD5, pZIDEGPD5, qZIDEGPD5,   rZIDEGPD5 define PMF, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 5 — ZIDEGPD5","text":"","code":"ZIDEGPD5(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",          tau.link = \"logit\")  dZIDEGPD5(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIDEGPD5(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) qZIDEGPD5(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) rZIDEGPD5(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 5 — ZIDEGPD5","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles (non-negative integers) p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 5 — ZIDEGPD5","text":"ZIDEGPD5() returns object class \"gamlss.family\". dZIDEGPD5 gives PMF, pZIDEGPD5 gives distribution   function, qZIDEGPD5 gives quantile function, rZIDEGPD5   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD5.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 5 — ZIDEGPD5","text":"Gamet, P. Jalbert, J. (2022). flexible extended generalized Pareto distribution tail estimation. Environmetrics, 33(6), e2744. Ahmad, T. Hussain, . (2025). Flexible model varying levels zeros outliers count data. arXiv preprint arXiv:2510.27365. https://arxiv.org/abs/2510.27365","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD5.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 5 — ZIDEGPD5","text":"","code":"if (FALSE) { # \\dontrun{   library(gamlss)   set.seed(1)   y <- rZIDEGPD5(500, mu = 3, sigma = 0.15, nu = 2, tau = 0.25)   fit <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                 tau.formula = ~ 1, family = ZIDEGPD5()) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD6.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Discrete EGPD Model 6 — ZIDEGPD6","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 6 — ZIDEGPD6","text":"ZIDEGPD6() function defines gamlss.family distribution   fitting zero-inflated discrete Extended Generalized Pareto   Distribution model 6 (truncated beta G-transformation). functions dZIDEGPD6, pZIDEGPD6, qZIDEGPD6,   rZIDEGPD6 define PMF, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD6.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 6 — ZIDEGPD6","text":"","code":"ZIDEGPD6(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",          tau.link = \"logit\")  dZIDEGPD6(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIDEGPD6(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) qZIDEGPD6(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,           log.p = FALSE) rZIDEGPD6(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD6.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 6 — ZIDEGPD6","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles (non-negative integers) p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD6.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 6 — ZIDEGPD6","text":"ZIDEGPD6() returns object class \"gamlss.family\". dZIDEGPD6 gives PMF, pZIDEGPD6 gives distribution   function, qZIDEGPD6 gives quantile function, rZIDEGPD6   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD6.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 6 — ZIDEGPD6","text":"Gamet, P. Jalbert, J. (2022). flexible extended generalized Pareto distribution tail estimation. Environmetrics, 33(6), e2744. Ahmad, T. Hussain, . (2025). Flexible model varying levels zeros outliers count data. arXiv preprint arXiv:2510.27365. https://arxiv.org/abs/2510.27365","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/ZIDEGPD6.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gamlss Family for Zero-Inflated Discrete EGPD Model 6 — ZIDEGPD6","text":"","code":"if (FALSE) { # \\dontrun{   library(gamlss)   set.seed(1)   y <- rZIDEGPD6(500, mu = 3, sigma = 0.15, nu = 2, tau = 0.25)   fit <- gamlss(y ~ 1, sigma.formula = ~ 1, nu.formula = ~ 1,                 tau.formula = ~ 1, family = ZIDEGPD6()) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD1.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Continuous EGPD Model 1 — ZIEGPD1","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 1 — ZIEGPD1","text":"ZIEGPD1() function defines gamlss.family distribution   fitting zero-inflated continuous Extended Generalized Pareto   Distribution model 1 (power G-transformation). functions dZIEGPD1, pZIEGPD1, qZIEGPD1,   rZIEGPD1 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 1 — ZIEGPD1","text":"","code":"ZIEGPD1(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",         tau.link = \"logit\")  dZIEGPD1(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIEGPD1(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) qZIEGPD1(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) rZIEGPD1(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 1 — ZIEGPD1","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 1 — ZIEGPD1","text":"ZIEGPD1() returns object class \"gamlss.family\". dZIEGPD1 gives density, pZIEGPD1 gives distribution   function, qZIEGPD1 gives quantile function, rZIEGPD1   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 1 — ZIEGPD1","text":"Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD3.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Continuous EGPD Model 3 — ZIEGPD3","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 3 — ZIEGPD3","text":"ZIEGPD3() function defines gamlss.family distribution   fitting zero-inflated continuous Extended Generalized Pareto   Distribution model 3 (incomplete beta G-transformation). functions dZIEGPD3, pZIEGPD3, qZIEGPD3,   rZIEGPD3 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 3 — ZIEGPD3","text":"","code":"ZIEGPD3(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",         tau.link = \"logit\")  dZIEGPD3(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIEGPD3(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) qZIEGPD3(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) rZIEGPD3(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 3 — ZIEGPD3","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (delta), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 3 — ZIEGPD3","text":"ZIEGPD3() returns object class \"gamlss.family\". dZIEGPD3 gives density, pZIEGPD3 gives distribution   function, qZIEGPD3 gives quantile function, rZIEGPD3   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD3.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 3 — ZIEGPD3","text":"Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD5.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Continuous EGPD Model 5 — ZIEGPD5","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 5 — ZIEGPD5","text":"ZIEGPD5() function defines gamlss.family distribution   fitting zero-inflated continuous Extended Generalized Pareto   Distribution model 5 (truncated normal G-transformation). functions dZIEGPD5, pZIEGPD5, qZIEGPD5,   rZIEGPD5 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 5 — ZIEGPD5","text":"","code":"ZIEGPD5(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",         tau.link = \"logit\")  dZIEGPD5(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIEGPD5(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) qZIEGPD5(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) rZIEGPD5(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 5 — ZIEGPD5","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 5 — ZIEGPD5","text":"ZIEGPD5() returns object class \"gamlss.family\". dZIEGPD5 gives density, pZIEGPD5 gives distribution   function, qZIEGPD5 gives quantile function, rZIEGPD5   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD5.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 5 — ZIEGPD5","text":"Gamet, P. Jalbert, J. (2022). flexible extended generalized Pareto distribution tail estimation. Environmetrics, 33(6), e2744. Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD6.html","id":null,"dir":"Reference","previous_headings":"","what":"gamlss Family for Zero-Inflated Continuous EGPD Model 6 — ZIEGPD6","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 6 — ZIEGPD6","text":"ZIEGPD6() function defines gamlss.family distribution   fitting zero-inflated continuous Extended Generalized Pareto   Distribution model 6 (truncated beta G-transformation). functions dZIEGPD6, pZIEGPD6, qZIEGPD6,   rZIEGPD6 define density, distribution function, quantile   function, random generation.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD6.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 6 — ZIEGPD6","text":"","code":"ZIEGPD6(mu.link = \"log\", sigma.link = \"log\", nu.link = \"log\",         tau.link = \"logit\")  dZIEGPD6(x, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, log = FALSE) pZIEGPD6(q, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) qZIEGPD6(p, mu = 1, sigma = 0.5, nu = 1, tau = 0.1, lower.tail = TRUE,          log.p = FALSE) rZIEGPD6(n, mu = 1, sigma = 0.5, nu = 1, tau = 0.1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD6.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 6 — ZIEGPD6","text":"mu.link link function mu, default \"log\" sigma.link link function sigma, default \"log\" nu.link link function nu, default \"log\" tau.link link function tau, default \"logit\" x, q vector quantiles p vector probabilities n number observations mu GPD scale parameter (sigma), positive sigma GPD shape parameter (xi), positive nu G-transformation parameter (kappa), positive tau zero-inflation probability (pi), (0,1) log, log.p logical; TRUE, probabilities/densities given log lower.tail logical; TRUE (default), probabilities P(X <= x)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD6.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 6 — ZIEGPD6","text":"ZIEGPD6() returns object class \"gamlss.family\". dZIEGPD6 gives density, pZIEGPD6 gives distribution   function, qZIEGPD6 gives quantile function, rZIEGPD6   generates random deviates.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ZIEGPD6.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"gamlss Family for Zero-Inflated Continuous EGPD Model 6 — ZIEGPD6","text":"Gamet, P. Jalbert, J. (2022). flexible extended generalized Pareto distribution tail estimation. Environmetrics, 33(6), e2744. Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/confint.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Confidence intervals for egpd model parameters — confint.egpd","title":"Confidence intervals for egpd model parameters — confint.egpd","text":"Confidence intervals egpd model parameters","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/confint.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Confidence intervals for egpd model parameters — confint.egpd","text":"","code":"# S3 method for class 'egpd' confint(object, parm = NULL, level = 0.95, method = c(\"wald\", \"profile\"), ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/confint.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Confidence intervals for egpd model parameters — confint.egpd","text":"object fitted egpd object. parm parameters compute CIs .  NULL (default) selects intercept distributional parameter.  Can also character vector stripped parameter names (e.g. \"scale\", \"shape\") integer vector coefficient indices. level Confidence level (default 0.95). method Either \"wald\" (default) \"profile\".  Profile likelihood CIs available intercept-models (smooth terms covariates beyond intercept). ... used.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/confint.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Confidence intervals for egpd model parameters — confint.egpd","text":"matrix columns \"lower\" \"upper\",   response (natural) scale.  Rows named parameter.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/d.G.html","id":null,"dir":"Reference","previous_headings":"","what":"Transformation density for EGPD — d.G","title":"Transformation density for EGPD — d.G","text":"Transformation density EGPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/d.G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transformation density for EGPD — d.G","text":"","code":"d.G(u, type = 1, prob = NA, kappa = NA, delta = NA, log = FALSE)"},{"path":"https://sdwfrost.github.io/egpd/reference/d.G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transformation density for EGPD — d.G","text":"u values (0,1) type integer 1-6 specifying transformation type prob mixing probability (type 6) kappa shape parameter delta shape parameter (types 4-6) log logical: return log-density?","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/d.G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transformation density for EGPD — d.G","text":"Transformation density values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dcpdegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Density (PMF) of Compound Poisson-Discrete EGPD — dcpdegpd","title":"Density (PMF) of Compound Poisson-Discrete EGPD — dcpdegpd","text":"Computes probability mass function Compound Poisson-Discrete EGPD distribution using Panjer recursion exact discrete EGPD severity PMF (discretization step).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dcpdegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density (PMF) of Compound Poisson-Discrete EGPD — dcpdegpd","text":"","code":"dcpdegpd(   x,   lambda,   prob = NA,   kappa = NA,   delta = NA,   sigma,   xi,   type = 1,   K = NULL,   log = FALSE )"},{"path":"https://sdwfrost.github.io/egpd/reference/dcpdegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density (PMF) of Compound Poisson-Discrete EGPD — dcpdegpd","text":"x numeric vector non-negative integer quantiles lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type K grid size Panjer recursion (default: max(max(x), 100) + 50) log logical; TRUE, return log-probabilities","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dcpdegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density (PMF) of Compound Poisson-Discrete EGPD — dcpdegpd","text":"numeric vector (log-)probabilities","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dcpdegpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Density (PMF) of Compound Poisson-Discrete EGPD — dcpdegpd","text":"model \\(S = X_1 + \\cdots + X_N\\) \\(N \\sim \\mathrm{Poisson}(\\lambda)\\) \\(X_i \\sim \\mathrm{Discrete\\mbox{-}EGPD}(\\sigma, \\xi, \\kappa, \\ldots)\\). Since severity already integer-valued, Panjer recursion produces exact compound distribution discretization error.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/dcpegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Density (PMF) of Compound Poisson-EGPD — dcpegpd","title":"Density (PMF) of Compound Poisson-EGPD — dcpegpd","text":"Computes probability mass function Compound Poisson-EGPD distribution using Panjer recursion discretized EGPD severity.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dcpegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density (PMF) of Compound Poisson-EGPD — dcpegpd","text":"","code":"dcpegpd(   x,   lambda,   prob = NA,   kappa = NA,   delta = NA,   sigma,   xi,   type = 1,   h = 0.2,   K = NULL,   log = FALSE )"},{"path":"https://sdwfrost.github.io/egpd/reference/dcpegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density (PMF) of Compound Poisson-EGPD — dcpegpd","text":"x numeric vector quantiles lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type h bin width discretization (default 0.2) K number bins (default: ceiling(max(x)/h) + 50) log logical; TRUE, return log-probabilities","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dcpegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density (PMF) of Compound Poisson-EGPD — dcpegpd","text":"numeric vector (log-)probabilities","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ddiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Discrete Extended GPD — ddiscegpd","title":"Density of the Discrete Extended GPD — ddiscegpd","text":"Density Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ddiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Discrete Extended GPD — ddiscegpd","text":"","code":"ddiscegpd(x, prob = NA, kappa = NA, delta = NA, sigma = NA, xi = NA, type = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/ddiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Discrete Extended GPD — ddiscegpd","text":"x non-negative integer values prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ddiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Discrete Extended GPD — ddiscegpd","text":"PMF values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_bamlss.html","id":null,"dir":"Reference","previous_headings":"","what":"bamlss family for discrete EGPD (DEGPD) — degpd_bamlss","title":"bamlss family for discrete EGPD (DEGPD) — degpd_bamlss","text":"Creates family.bamlss object fitting discrete Extended Generalized Pareto Distribution models bamlss().","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_bamlss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bamlss family for discrete EGPD (DEGPD) — degpd_bamlss","text":"","code":"degpd_bamlss(m = 1, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_bamlss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bamlss family for discrete EGPD (DEGPD) — degpd_bamlss","text":"m integer 1–4 selecting G transformation (see egpd_bamlss details) ... arguments passed link specification","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_bamlss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bamlss family for discrete EGPD (DEGPD) — degpd_bamlss","text":"object class family.bamlss","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Extended GPD — degpd_density","title":"Density of the Extended GPD — degpd_density","text":"Density Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Extended GPD — degpd_density","text":"","code":"degpd_density(   x,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1,   log = FALSE )"},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Extended GPD — degpd_density","text":"x values prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type log logical: return log-density?","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/degpd_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Extended GPD — degpd_density","text":"Density values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dfbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind a list of data frames — dfbind","title":"Bind a list of data frames — dfbind","text":"Bind list data frames","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dfbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind a list of data frames — dfbind","text":"","code":"dfbind(x)"},{"path":"https://sdwfrost.github.io/egpd/reference/dfbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind a list of data frames — dfbind","text":"x list data frames","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dfbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind a list of data frames — dfbind","text":"data frame","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/docvisits.html","id":null,"dir":"Reference","previous_headings":"","what":"Doctor Visits — docvisits","title":"Doctor Visits — docvisits","text":"Number doctor visits 1812 individuals German Socio-Economic Panel (GSOEP). Originally distributed zic package.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/docvisits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Doctor Visits — docvisits","text":"","code":"docvisits"},{"path":"https://sdwfrost.github.io/egpd/reference/docvisits.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Doctor Visits — docvisits","text":"data frame 1812 rows 1 variable: visits Number doctor visits (non-negative integer).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/docvisits.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Doctor Visits — docvisits","text":"Winkelmann, R. (2004). Health care reform number doctor   visits – econometric analysis. Journal Applied Econometrics,   19(4), 455–472.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dzidiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Zero-Inflated Discrete Extended GPD — dzidiscegpd","title":"Density of the Zero-Inflated Discrete Extended GPD — dzidiscegpd","text":"Density Zero-Inflated Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dzidiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Zero-Inflated Discrete Extended GPD — dzidiscegpd","text":"","code":"dzidiscegpd(   x,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1 )"},{"path":"https://sdwfrost.github.io/egpd/reference/dzidiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Zero-Inflated Discrete Extended GPD — dzidiscegpd","text":"x non-negative integer values pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dzidiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Zero-Inflated Discrete Extended GPD — dzidiscegpd","text":"PMF values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dziegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of the Zero-Inflated Extended GPD — dziegpd","title":"Density of the Zero-Inflated Extended GPD — dziegpd","text":"Continuous zero-inflated EGPD density: \\(h(x) = \\pi (x=0) + (1-\\pi) f_{EGPD}(x)\\) \\(x \\ge 0\\).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dziegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of the Zero-Inflated Extended GPD — dziegpd","text":"","code":"dziegpd(   x,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1,   log = FALSE )"},{"path":"https://sdwfrost.github.io/egpd/reference/dziegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of the Zero-Inflated Extended GPD — dziegpd","text":"x non-negative values pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type log logical: return log-density?","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/dziegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of the Zero-Inflated Extended GPD — dziegpd","text":"Density values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd-package.html","id":null,"dir":"Reference","previous_headings":"","what":"egpd: Extended Generalized Pareto Distribution GAMs — egpd-package","title":"egpd: Extended Generalized Pareto Distribution GAMs — egpd-package","text":"egpd package fits Extended Generalized Pareto Distribution (EGPD), Discrete EGPD (DEGPD), Zero-Inflated EGPD (ZIEGPD), Zero-Inflated Discrete EGPD (ZIDEGPD) models within GAM framework, additional support fitting via gamlss bamlss. fitting infrastructure adapted evgam package Ben Youngman. P-value testing code adapted mgcv package Simon Wood.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd-package.html","id":"main-function","dir":"Reference","previous_headings":"","what":"Main function","title":"egpd: Extended Generalized Pareto Distribution GAMs — egpd-package","text":"main function egpd.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"egpd: Extended Generalized Pareto Distribution GAMs — egpd-package","text":"Abbas, ., Ahmad, T. Ahmad, . (2025). Modeling zero-inflated precipitation extremes. arXiv preprint arXiv:2504.11058. https://arxiv.org/abs/2504.11058 Ahmad, T. Arshad, . . (2024). New flexible versions extended generalized Pareto model count data. arXiv preprint arXiv:2409.18719. https://arxiv.org/abs/2409.18719 Ahmad, T. Hussain, . (2025). Flexible model varying levels zeros outliers count data. arXiv preprint arXiv:2510.27365. https://arxiv.org/abs/2510.27365","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/egpd-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"egpd: Extended Generalized Pareto Distribution GAMs — egpd-package","text":"Maintainer: Touqeer Ahmad touqeer.ahmad8960@gmail.com Authors: Simon Frost sdwfrost@gmail.com","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Extended Generalized Pareto Distribution GAMs — egpd","title":"Fit Extended Generalized Pareto Distribution GAMs — egpd","text":"Fit Extended Generalized Pareto Distribution GAMs","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Extended Generalized Pareto Distribution GAMs — egpd","text":"","code":"egpd(   formula,   data,   family = \"egpd\",   correctV = TRUE,   rho0 = 0,   inits = NULL,   outer = \"bfgs\",   control = NULL,   removeData = FALSE,   trace = 0,   knots = NULL,   maxdata = 1e+20,   maxspline = 1e+20,   compact = FALSE,   egpd.args = list(),   degpd.args = list(),   zidegpd.args = list(),   sandwich.args = list(),   custom.fns = list(),   sp = NULL,   gamma = 1 )"},{"path":"https://sdwfrost.github.io/egpd/reference/egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Extended Generalized Pareto Distribution GAMs — egpd","text":"formula formula list formulae data data frame family character string: \"egpd\", \"degpd\", \"zidegpd\" correctV logical: variance-covariance matrix account smoothing parameter uncertainty? Defaults TRUE rho0 initial log smoothing parameters inits initial parameter values outer outer optimization method: \"bfgs\" (default), \"newton\", \"fd\", \"fixed\" control list control parameters removeData logical: data removed returned object? Defaults FALSE trace integer controlling output verbosity knots list knot values smooth terms maxdata maximum number data rows maxspline maximum number rows spline basis construction compact logical: use compact representation? Defaults FALSE egpd.args list arguments EGPD family (e.g., m=1) degpd.args list arguments DEGPD family (e.g., m=1) zidegpd.args list arguments ZIDEGPD family (e.g., m=1) sandwich.args list sandwich correction arguments custom.fns list custom likelihood functions sp fixed smoothing parameters (supplied, outer optimization skipped) gamma gamma multiplier likelihood","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Extended Generalized Pareto Distribution GAMs — egpd","text":"object class egpd","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd_bamlss.html","id":null,"dir":"Reference","previous_headings":"","what":"bamlss family for continuous EGPD — egpd_bamlss","title":"bamlss family for continuous EGPD — egpd_bamlss","text":"Creates family.bamlss object fitting continuous Extended Generalized Pareto Distribution models bamlss().","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd_bamlss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bamlss family for continuous EGPD — egpd_bamlss","text":"","code":"egpd_bamlss(m = 1, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/egpd_bamlss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bamlss family for continuous EGPD — egpd_bamlss","text":"m integer 1–4 selecting G transformation: 1 Power: \\(G(u) = u^\\kappa\\) 2 Mixture: \\(G(u) = p u^{\\kappa} + (1-p) u^{\\delta}\\) 3 Incomplete beta 4 Power-beta ... arguments passed link specification","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/egpd_bamlss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bamlss family for continuous EGPD — egpd_bamlss","text":"object class family.bamlss","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/fitegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit EGPD distribution to data — fitegpd","title":"Fit EGPD distribution to data — fitegpd","text":"Maximum likelihood, Bernstein polynomial, neural Bayes fitting EGPD, discrete EGPD, zero-inflated EGPD, zero-inflated discrete EGPD, bivariate multivariate EGPD distributions.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/fitegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit EGPD distribution to data — fitegpd","text":"","code":"fitegpd(   x,   type = 1,   family = c(\"egpd\", \"degpd\", \"ziegpd\", \"zidegpd\", \"cpegpd\", \"cpdegpd\", \"begpd\",     \"bdegpd\", \"bzidegpd\", \"mdgpd\", \"zimdgpd\"),   method = c(\"mle\", \"bernstein\", \"neuralbayes\"),   start = NULL,   fix.arg = NULL,   optim.method = \"Nelder-Mead\",   hessian = TRUE,   bernstein.m = 8,   cpegpd.h = 0.2,   model.path = NULL,   estimator = c(\"npe\", \"nbe\"),   nsamples = 1000L,   ... )"},{"path":"https://sdwfrost.github.io/egpd/reference/fitegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit EGPD distribution to data — fitegpd","text":"x numeric vector observations (univariate families), n--d numeric matrix/data.frame (multivariate families; d=2 BEGPD, d >= 2 MDGPD). type integer 1-6 specifying G-transformation type (univariate ). family character: \"egpd\", \"degpd\", \"ziegpd\", \"zidegpd\", \"cpegpd\", \"cpdegpd\", \"begpd\" (bivariate EGPD), \"bdegpd\" (\\[Experimental\\] bivariate discrete EGPD), \"bzidegpd\" (\\[Experimental\\] zero-inflated bivariate discrete EGPD), \"mdgpd\" (\\[Experimental\\] multivariate MDGPD via Aka-Kratz-Naveau construction, d >= 2), \"zimdgpd\" (\\[Experimental\\] zero-inflated multivariate MDGPD, d >= 2). method character: \"mle\", \"bernstein\", \"neuralbayes\". \"neuralbayes\" required bivariate families requires Julia dependencies. start named list starting values, NULL automatic (used method=\"neuralbayes\"). fix.arg named list fixed parameters (used method=\"neuralbayes\"). optim.method optimization method passed optim hessian logical: compute standard errors via Hessian? bernstein.m integer: Bernstein polynomial degree (method=\"bernstein\" ) cpegpd.h numeric: discretization step cpegpd family. model.path character: path pre-trained .bson model file (method=\"neuralbayes\" ). NULL, uses bundled model. estimator character: \"npe\" Neural Posterior Estimation \"nbe\" Neural Bayesian Estimation (method=\"neuralbayes\" ). nsamples integer: number posterior samples NPE (method=\"neuralbayes\" estimator=\"npe\" ). ... additional arguments passed optim","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/fitegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit EGPD distribution to data — fitegpd","text":"object class \"fitegpd\" components: estimate named vector parameter estimates sd named vector standard errors (NA Hessian computed) vcov variance-covariance matrix natural scale loglik maximized log-likelihood aic Akaike information criterion bic Bayesian information criterion n number observations npar number estimated parameters data input data vector type G-transformation type family distribution family method fitting method fix.arg list fixed arguments convergence convergence code optim (0 = success) optim full optim output call matched call bernstein.m Bernstein degree (NULL method=\"mle\") bernstein.weights Bernstein weights (NULL method=\"mle\") family=\"begpd\", additional fields: estimator_type \"npe\" \"nbe\" model.path path .bson model used posterior_samples 6 x nsamples matrix posterior draws (NPE) NULL (NBE) nsamples number posterior samples (NPE) NULL (NBE)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/fitegpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit EGPD distribution to data — fitegpd","text":"","code":"if (FALSE) { # \\dontrun{ # Univariate fitting x <- regpd(500, sigma = 2, xi = 0.1, kappa = 1.5, type = 1) fit <- fitegpd(x, type = 1) summary(fit) plot(fit)  # Bivariate BEGPD (requires Julia) Y <- rbegpd(1000, kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2) fit_biv <- fitegpd(Y, family = \"begpd\", method = \"neuralbayes\") summary(fit_biv) plot(fit_biv) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/fitted.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Model Fitted Values — fitted.egpd","title":"Extract Model Fitted Values — fitted.egpd","text":"Extract Model Fitted Values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/fitted.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Model Fitted Values — fitted.egpd","text":"","code":"# S3 method for class 'egpd' fitted(object, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/fitted.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Model Fitted Values — fitted.egpd","text":"object fitted egpd object ... used","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/fitted.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Model Fitted Values — fitted.egpd","text":"Fitted values extracted object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/logLik.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-likelihood from a fitted egpd object — logLik.egpd","title":"Log-likelihood from a fitted egpd object — logLik.egpd","text":"Log-likelihood fitted egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/logLik.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-likelihood from a fitted egpd object — logLik.egpd","text":"","code":"# S3 method for class 'egpd' logLik(object, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/logLik.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-likelihood from a fitted egpd object — logLik.egpd","text":"object fitted egpd object ... used","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/logLik.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-likelihood from a fitted egpd object — logLik.egpd","text":"logLik object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/nobs.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of observations — nobs.egpd","title":"Number of observations — nobs.egpd","text":"Number observations","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/nobs.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of observations — nobs.egpd","text":"","code":"# S3 method for class 'egpd' nobs(object, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/nobs.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of observations — nobs.egpd","text":"object egpd object ... used","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/nobs.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of observations — nobs.egpd","text":"integer","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/nsw_offenses.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaming and Betting Offenses in New South Wales — nsw_offenses","title":"Gaming and Betting Offenses in New South Wales — nsw_offenses","text":"Counts gaming betting offenses recorded 342 locations New South Wales, Australia.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/nsw_offenses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaming and Betting Offenses in New South Wales — nsw_offenses","text":"","code":"nsw_offenses"},{"path":"https://sdwfrost.github.io/egpd/reference/nsw_offenses.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Gaming and Betting Offenses in New South Wales — nsw_offenses","text":"data frame 342 rows 1 variable: offenses Number gaming betting offenses (non-negative integer).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/nsw_offenses.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Gaming and Betting Offenses in New South Wales — nsw_offenses","text":"Australian Bureau Statistics, New South Wales crime data.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ny_complaints.html","id":null,"dir":"Reference","previous_headings":"","what":"New York Auto Insurance Complaint Rankings — ny_complaints","title":"New York Auto Insurance Complaint Rankings — ny_complaints","text":"Automobile insurance company complaint data New York State Department Financial Services, covering filing years 2009–2020. row represents one insurer one filing year.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ny_complaints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"New York Auto Insurance Complaint Rankings — ny_complaints","text":"","code":"ny_complaints"},{"path":"https://sdwfrost.github.io/egpd/reference/ny_complaints.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"New York Auto Insurance Complaint Rankings — ny_complaints","text":"data frame 1942 rows 4 variables: year Filing year (2009–2020). upheld Number upheld complaints insurer. total Total complaints filed insurer. premiums Premiums written (millions USD).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ny_complaints.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"New York Auto Insurance Complaint Rankings — ny_complaints","text":"New York State Department Financial Services,   Automobile Insurance Company Complaint Rankings, Beginning 2009.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/p.G.html","id":null,"dir":"Reference","previous_headings":"","what":"Transformation CDF for EGPD — p.G","title":"Transformation CDF for EGPD — p.G","text":"Transformation CDF EGPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/p.G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transformation CDF for EGPD — p.G","text":"","code":"p.G(u, type = 1, prob, kappa, delta)"},{"path":"https://sdwfrost.github.io/egpd/reference/p.G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transformation CDF for EGPD — p.G","text":"u values (0,1) type integer 1-6 specifying transformation type prob mixing probability (type 6) kappa shape parameter delta shape parameter (types 4-6)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/p.G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transformation CDF for EGPD — p.G","text":"Transformed probabilities","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pcpdegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Distribution function of Compound Poisson-Discrete EGPD — pcpdegpd","title":"Distribution function of Compound Poisson-Discrete EGPD — pcpdegpd","text":"Distribution function Compound Poisson-Discrete EGPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pcpdegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distribution function of Compound Poisson-Discrete EGPD — pcpdegpd","text":"","code":"pcpdegpd(   q,   lambda,   prob = NA,   kappa = NA,   delta = NA,   sigma,   xi,   type = 1,   K = NULL )"},{"path":"https://sdwfrost.github.io/egpd/reference/pcpdegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distribution function of Compound Poisson-Discrete EGPD — pcpdegpd","text":"q numeric vector quantiles lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type K grid size Panjer recursion (default: max(max(x), 100) + 50)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pcpdegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distribution function of Compound Poisson-Discrete EGPD — pcpdegpd","text":"numeric vector cumulative probabilities","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/pcpegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Distribution function of Compound Poisson-EGPD — pcpegpd","title":"Distribution function of Compound Poisson-EGPD — pcpegpd","text":"Distribution function Compound Poisson-EGPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pcpegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distribution function of Compound Poisson-EGPD — pcpegpd","text":"","code":"pcpegpd(   q,   lambda,   prob = NA,   kappa = NA,   delta = NA,   sigma,   xi,   type = 1,   h = 0.2,   K = NULL )"},{"path":"https://sdwfrost.github.io/egpd/reference/pcpegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distribution function of Compound Poisson-EGPD — pcpegpd","text":"q numeric vector quantiles lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type h bin width discretization (default 0.2) K number bins (default: ceiling(max(x)/h) + 50)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pcpegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distribution function of Compound Poisson-EGPD — pcpegpd","text":"numeric vector cumulative probabilities","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pdiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF of the Discrete Extended GPD — pdiscegpd","title":"CDF of the Discrete Extended GPD — pdiscegpd","text":"CDF Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pdiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF of the Discrete Extended GPD — pdiscegpd","text":"","code":"pdiscegpd(q, prob = NA, kappa = NA, delta = NA, sigma = NA, xi = NA, type = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/pdiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF of the Discrete Extended GPD — pdiscegpd","text":"q non-negative integer quantiles prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pdiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF of the Discrete Extended GPD — pdiscegpd","text":"CDF values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF of the Extended GPD — pegpd","title":"CDF of the Extended GPD — pegpd","text":"CDF Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF of the Extended GPD — pegpd","text":"","code":"pegpd(q, prob = NA, kappa = NA, delta = NA, sigma = NA, xi = NA, type = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/pegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF of the Extended GPD — pegpd","text":"q quantiles prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF of the Extended GPD — pegpd","text":"CDF values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pinv.html","id":null,"dir":"Reference","previous_headings":"","what":"Moore-Penrose pseudo-inverse of a matrix — pinv","title":"Moore-Penrose pseudo-inverse of a matrix — pinv","text":"Moore-Penrose pseudo-inverse matrix","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pinv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moore-Penrose pseudo-inverse of a matrix — pinv","text":"","code":"pinv(x, tol = -1)  ginv.egpd(x, tol = sqrt(.Machine$double.eps))"},{"path":"https://sdwfrost.github.io/egpd/reference/pinv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moore-Penrose pseudo-inverse of a matrix — pinv","text":"x matrix tol scalar tolerance","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pinv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moore-Penrose pseudo-inverse of a matrix — pinv","text":"matrix","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/plot.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a fitted egpd object — plot.egpd","title":"Plot a fitted egpd object — plot.egpd","text":"Plot fitted egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/plot.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a fitted egpd object — plot.egpd","text":"","code":"# S3 method for class 'egpd' plot(x, onepage = TRUE, which = NULL, main, ask = !onepage, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/plot.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a fitted egpd object — plot.egpd","text":"x fitted egpd object onepage logical: plots one page? Defaults TRUE vector integers identifying smooths plot main character string vector plot titles ask logical: ask show next plots? ... extra arguments pass mgcv::plot.gam","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/plot.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a fitted egpd object — plot.egpd","text":"Plots representing smooth terms","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/plot.fitegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot diagnostics for a fitegpd object — plot.fitegpd","title":"Plot diagnostics for a fitegpd object — plot.fitegpd","text":"Produces 4-panel diagnostic plot. univariate fits: histogram fitted density, empirical vs fitted CDF, Q-Q plot, P-P plot. bivariate BEGPD fits: observed scatter, simulated scatter, radial Q-Q plot, posterior marginals parameter bar chart.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/plot.fitegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot diagnostics for a fitegpd object — plot.fitegpd","text":"","code":"# S3 method for class 'fitegpd' plot(x, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/plot.fitegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot diagnostics for a fitegpd object — plot.fitegpd","text":"x fitegpd object ... additional graphical parameters","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predict.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictions from a fitted egpd object — predict.egpd","title":"Predictions from a fitted egpd object — predict.egpd","text":"Predictions fitted egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predict.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictions from a fitted egpd object — predict.egpd","text":"","code":"# S3 method for class 'egpd' predict(   object,   newdata,   type = \"link\",   prob = NULL,   se.fit = FALSE,   marginal = TRUE,   trace = 0,   ... )"},{"path":"https://sdwfrost.github.io/egpd/reference/predict.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictions from a fitted egpd object — predict.egpd","text":"object fitted egpd object newdata data frame type character string: \"link\", \"response\", \"lpmatrix\", \"quantile\" prob scalar vector probabilities quantile estimation se.fit logical: standard errors returned? Defaults FALSE marginal logical: uncertainty integrate smoothing parameter uncertainty? Defaults TRUE trace integer controlling output verbosity ... unused","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predict.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictions from a fitted egpd object — predict.egpd","text":"data frame, list, design matrix depending type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predictive_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive coverage for EGPD models — predictive_coverage","title":"Predictive coverage for EGPD models — predictive_coverage","text":"Compute simulation-based prediction intervals empirical coverage fitted EGPD-family models.  Methods provided objects class \"egpd\", \"gamlss\", \"bamlss\".","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predictive_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive coverage for EGPD models — predictive_coverage","text":"","code":"predictive_coverage(fit, ...)  # S3 method for class 'egpd' predictive_coverage(   fit,   y,   newdata = NULL,   level = 0.95,   nsim = 2000,   method = c(\"parametric\", \"plug-in\"),   use_shortest = FALSE,   ... )  # S3 method for class 'gamlss' predictive_coverage(   fit,   y,   newdata = NULL,   level = 0.95,   nsim = 2000,   method = c(\"parametric\", \"plug-in\"),   use_shortest = FALSE,   data_fit = NULL,   ... )  # S3 method for class 'bamlss' predictive_coverage(   fit,   y,   newdata = NULL,   level = 0.95,   nsim = 2000,   method = c(\"parametric\", \"plug-in\"),   use_shortest = FALSE,   ... )"},{"path":"https://sdwfrost.github.io/egpd/reference/predictive_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive coverage for EGPD models — predictive_coverage","text":"fit fitted model object (class \"egpd\", \"gamlss\", \"bamlss\") ... additional arguments (currently unused) y numeric vector observed responses evaluate coverage newdata optional data frame covariate values compute predictions.  NULL (default), -sample predictions used. level nominal coverage level (default 0.95) nsim number parameter/response simulation draws (default 2000) method \"parametric\" (default) parameter uncertainty, \"plug-\" fixed-parameter prediction use_shortest logical: use shortest (HDR) interval discrete families instead equal-tailed?  Default FALSE. data_fit (gamlss method ) optional data frame passed data predictAll(); needed original fitting data recovered fit object.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predictive_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive coverage for EGPD models — predictive_coverage","text":"list components: family character string identifying distribution family method method used (\"parametric\" \"plug-\") level nominal coverage level coverage empirical coverage (proportion y falling within prediction interval) covered logical vector indicating observations covered L lower prediction interval bounds U upper prediction interval bounds","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predictive_coverage.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predictive coverage for EGPD models — predictive_coverage","text":"algorithm three steps: Parameter draws. method = \"plug-\" Fitted parameters held         fixed point estimates. method = \"parametric\" Parameters perturbed         link scale using normal noise (scaled standard         errors) back-transformed.  egpd fits         multivariate-normal draw joint         coefficient posterior; gamlss fits         perturbation independent across parameters. Response simulation.     nsim responses drawn observation     fitted distribution (using appropriate r* function     egpd package). Intervals coverage.     Equal-tailed quantile intervals computed simulated     responses.  discrete families, use_shortest = TRUE     gives shortest (highest-density-region) interval instead.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/predictive_coverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive coverage for EGPD models — predictive_coverage","text":"","code":"if (FALSE) { # \\dontrun{ y <- rdiscegpd(500, sigma = 3, xi = 0.15, kappa = 2, type = 1) df <- data.frame(y = y)  # egpd fit fit_e <- egpd(list(lsigma = y ~ 1, lxi = ~ 1, lkappa = ~ 1),               data = df, family = \"degpd\", degpd.args = list(m = 1)) predictive_coverage(fit_e, y) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/print.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a fitted egpd object — print.egpd","title":"Print a fitted egpd object — print.egpd","text":"Print fitted egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/print.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a fitted egpd object — print.egpd","text":"","code":"# S3 method for class 'egpd' print(x, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/print.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a fitted egpd object — print.egpd","text":"x fitted egpd object ... used","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/print.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print a fitted egpd object — print.egpd","text":"call object (invisibly)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pzidiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF of the Zero-Inflated Discrete Extended GPD — pzidiscegpd","title":"CDF of the Zero-Inflated Discrete Extended GPD — pzidiscegpd","text":"CDF Zero-Inflated Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pzidiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF of the Zero-Inflated Discrete Extended GPD — pzidiscegpd","text":"","code":"pzidiscegpd(   q,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1 )"},{"path":"https://sdwfrost.github.io/egpd/reference/pzidiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF of the Zero-Inflated Discrete Extended GPD — pzidiscegpd","text":"q non-negative integer quantiles pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pzidiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF of the Zero-Inflated Discrete Extended GPD — pzidiscegpd","text":"CDF values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pziegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF of the Zero-Inflated Extended GPD — pziegpd","title":"CDF of the Zero-Inflated Extended GPD — pziegpd","text":"CDF Zero-Inflated Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pziegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF of the Zero-Inflated Extended GPD — pziegpd","text":"","code":"pziegpd(   q,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1 )"},{"path":"https://sdwfrost.github.io/egpd/reference/pziegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF of the Zero-Inflated Extended GPD — pziegpd","text":"q quantiles pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/pziegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF of the Zero-Inflated Extended GPD — pziegpd","text":"CDF values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/q.G.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse transformation (quantile) for EGPD — q.G","title":"Inverse transformation (quantile) for EGPD — q.G","text":"Inverse transformation (quantile) EGPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/q.G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse transformation (quantile) for EGPD — q.G","text":"","code":"q.G(u, type = 1, prob = NA, kappa = NA, delta = NA)"},{"path":"https://sdwfrost.github.io/egpd/reference/q.G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse transformation (quantile) for EGPD — q.G","text":"u values (0,1) type integer 1-6 prob mixing probability (type 6) kappa shape parameter delta shape parameter (types 4-6)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/q.G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverse transformation (quantile) for EGPD — q.G","text":"Inverse-transformed values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qcpdegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile function of Compound Poisson-Discrete EGPD — qcpdegpd","title":"Quantile function of Compound Poisson-Discrete EGPD — qcpdegpd","text":"Quantile function Compound Poisson-Discrete EGPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qcpdegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile function of Compound Poisson-Discrete EGPD — qcpdegpd","text":"","code":"qcpdegpd(   p,   lambda,   prob = NA,   kappa = NA,   delta = NA,   sigma,   xi,   type = 1,   K = NULL )"},{"path":"https://sdwfrost.github.io/egpd/reference/qcpdegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile function of Compound Poisson-Discrete EGPD — qcpdegpd","text":"p numeric vector probabilities lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type K grid size Panjer recursion (default: max(max(x), 100) + 50)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qcpdegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile function of Compound Poisson-Discrete EGPD — qcpdegpd","text":"numeric vector quantiles (non-negative integers)","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/qcpegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile function of Compound Poisson-EGPD — qcpegpd","title":"Quantile function of Compound Poisson-EGPD — qcpegpd","text":"Quantile function Compound Poisson-EGPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qcpegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile function of Compound Poisson-EGPD — qcpegpd","text":"","code":"qcpegpd(   p,   lambda,   prob = NA,   kappa = NA,   delta = NA,   sigma,   xi,   type = 1,   h = 0.2,   K = NULL )"},{"path":"https://sdwfrost.github.io/egpd/reference/qcpegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile function of Compound Poisson-EGPD — qcpegpd","text":"p numeric vector probabilities lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type h bin width discretization (default 0.2) K number bins (default: ceiling(max(x)/h) + 50)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qcpegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile function of Compound Poisson-EGPD — qcpegpd","text":"numeric vector quantiles","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qdiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile function of the Discrete Extended GPD — qdiscegpd","title":"Quantile function of the Discrete Extended GPD — qdiscegpd","text":"Quantile function Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qdiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile function of the Discrete Extended GPD — qdiscegpd","text":"","code":"qdiscegpd(p, prob = NA, kappa = NA, delta = NA, sigma = NA, xi = NA, type = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/qdiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile function of the Discrete Extended GPD — qdiscegpd","text":"p probabilities prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qdiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile function of the Discrete Extended GPD — qdiscegpd","text":"Quantile values (non-negative integers)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile function of the Extended GPD — qegpd","title":"Quantile function of the Extended GPD — qegpd","text":"Quantile function Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile function of the Extended GPD — qegpd","text":"","code":"qegpd(p, prob = NA, kappa = NA, delta = NA, sigma = NA, xi = NA, type = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/qegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile function of the Extended GPD — qegpd","text":"p probabilities prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile function of the Extended GPD — qegpd","text":"Quantile values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qzidiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile function of the Zero-Inflated Discrete Extended GPD — qzidiscegpd","title":"Quantile function of the Zero-Inflated Discrete Extended GPD — qzidiscegpd","text":"Quantile function Zero-Inflated Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qzidiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile function of the Zero-Inflated Discrete Extended GPD — qzidiscegpd","text":"","code":"qzidiscegpd(   p,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1 )"},{"path":"https://sdwfrost.github.io/egpd/reference/qzidiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile function of the Zero-Inflated Discrete Extended GPD — qzidiscegpd","text":"p probabilities pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qzidiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile function of the Zero-Inflated Discrete Extended GPD — qzidiscegpd","text":"Quantile values (non-negative integers)","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qziegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile function of the Zero-Inflated Extended GPD — qziegpd","title":"Quantile function of the Zero-Inflated Extended GPD — qziegpd","text":"Quantile function Zero-Inflated Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qziegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile function of the Zero-Inflated Extended GPD — qziegpd","text":"","code":"qziegpd(   p,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1 )"},{"path":"https://sdwfrost.github.io/egpd/reference/qziegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile function of the Zero-Inflated Extended GPD — qziegpd","text":"p probabilities pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/qziegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile function of the Zero-Inflated Extended GPD — qziegpd","text":"Quantile values","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/r.G.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from transformation G — r.G","title":"Random generation from transformation G — r.G","text":"Random generation transformation G","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/r.G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from transformation G — r.G","text":"","code":"r.G(   n,   prob = NA,   kappa = NA,   delta = NA,   type = 1,   unifsamp = NULL,   direct = FALSE )"},{"path":"https://sdwfrost.github.io/egpd/reference/r.G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from transformation G — r.G","text":"n number samples prob mixing probability (type 6) kappa shape parameter delta shape parameter (types 4-6) type integer 1-6 unifsamp optional uniform samples direct logical type 6","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/r.G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from transformation G — r.G","text":"Random samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbdegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"\\[Experimental\\] Random generation from the bivariate discrete EGPD — rbdegpd","title":"\\[Experimental\\] Random generation from the bivariate discrete EGPD — rbdegpd","text":"Generates random samples Bivariate Discrete Extended Generalized Pareto Distribution (BDEGPD) applying floor() continuous bivariate BEGPD samples. function pure R require Julia.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbdegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"\\[Experimental\\] Random generation from the bivariate discrete EGPD — rbdegpd","text":"","code":"rbdegpd(n, kappa, sigma, xi, thL, thU, thw)"},{"path":"https://sdwfrost.github.io/egpd/reference/rbdegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"\\[Experimental\\] Random generation from the bivariate discrete EGPD — rbdegpd","text":"n integer; number observations generate. kappa positive numeric; EGPD shape parameter (power transform). sigma positive numeric; GPD scale parameter. xi positive numeric; GPD shape parameter. thL positive numeric; lower tail dependence parameter (beta shape). thU positive numeric; upper tail dependence parameter (beta shape). thw numeric (0, 0.5); weight mixing parameter.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbdegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"\\[Experimental\\] Random generation from the bivariate discrete EGPD — rbdegpd","text":"n 2 integer matrix columns Y1 Y2.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbdegpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"\\[Experimental\\] Random generation from the bivariate discrete EGPD — rbdegpd","text":"BDEGPD constructs bivariate discrete observations generating continuous BEGPD samples via rbegpd applying floor() obtain non-negative integers. function experimental interface may change.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/rbdegpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"\\[Experimental\\] Random generation from the bivariate discrete EGPD — rbdegpd","text":"","code":"Y <- rbdegpd(1000, kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2) table(Y[,1]) #>  #>   0   1   2   3   4   5   6  #> 705 216  51  18   7   2   1"},{"path":"https://sdwfrost.github.io/egpd/reference/rbegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from the bivariate BEGPD — rbegpd","title":"Random generation from the bivariate BEGPD — rbegpd","text":"Generates random samples bivariate Multivariate Extended Generalized Pareto Distribution (BEGPD). function pure R require Julia.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from the bivariate BEGPD — rbegpd","text":"","code":"rbegpd(n, kappa, sigma, xi, thL, thU, thw)"},{"path":"https://sdwfrost.github.io/egpd/reference/rbegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from the bivariate BEGPD — rbegpd","text":"n integer; number observations generate. kappa positive numeric; EGPD shape parameter (power transform). sigma positive numeric; GPD scale parameter. xi positive numeric; GPD shape parameter. thL positive numeric; lower tail dependence parameter (beta shape). thU positive numeric; upper tail dependence parameter (beta shape). thw numeric (0, 0.5); weight mixing parameter.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from the bivariate BEGPD — rbegpd","text":"n 2 numeric matrix columns Y1 Y2.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbegpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random generation from the bivariate BEGPD — rbegpd","text":"BEGPD constructs bivariate observations : Generating radial component \\(R\\) power-transformed GPD. Generating lower upper dependence components symmetric         Beta distributions parameters thL thU. Mixing components using weight function based thw.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbegpd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Random generation from the bivariate BEGPD — rbegpd","text":"Alotaibi, N., Sainsbury-Dale, M., Naveau, P., Gaetan, C., Huser, R. (2025). Joint modeling low high extremes using multivariate extended generalized Pareto distribution. arXiv preprint arXiv:2509.05982.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbegpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random generation from the bivariate BEGPD — rbegpd","text":"","code":"Y <- rbegpd(1000, kappa = 2, sigma = 1, xi = 0.1, thL = 5, thU = 5, thw = 0.2) plot(Y[,1], Y[,2], pch = \".\", main = \"Bivariate BEGPD sample\")"},{"path":"https://sdwfrost.github.io/egpd/reference/rbzidegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"\\[Experimental\\] Random generation from the zero-inflated bivariate discrete EGPD — rbzidegpd","title":"\\[Experimental\\] Random generation from the zero-inflated bivariate discrete EGPD — rbzidegpd","text":"Generates random samples Zero-Inflated Bivariate Discrete Extended Generalized Pareto Distribution (BZIDEGPD). probability pi0, row set (0, 0); otherwise, drawn rbdegpd.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbzidegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"\\[Experimental\\] Random generation from the zero-inflated bivariate discrete EGPD — rbzidegpd","text":"","code":"rbzidegpd(n, kappa, sigma, xi, thL, thU, thw, pi0)"},{"path":"https://sdwfrost.github.io/egpd/reference/rbzidegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"\\[Experimental\\] Random generation from the zero-inflated bivariate discrete EGPD — rbzidegpd","text":"n integer; number observations generate. kappa positive numeric; EGPD shape parameter (power transform). sigma positive numeric; GPD scale parameter. xi positive numeric; GPD shape parameter. thL positive numeric; lower tail dependence parameter (beta shape). thU positive numeric; upper tail dependence parameter (beta shape). thw numeric (0, 0.5); weight mixing parameter. pi0 numeric (0, 1); joint zero-inflation probability.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbzidegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"\\[Experimental\\] Random generation from the zero-inflated bivariate discrete EGPD — rbzidegpd","text":"n 2 integer matrix columns Y1 Y2.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rbzidegpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"\\[Experimental\\] Random generation from the zero-inflated bivariate discrete EGPD — rbzidegpd","text":"function experimental interface may change.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/rbzidegpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"\\[Experimental\\] Random generation from the zero-inflated bivariate discrete EGPD — rbzidegpd","text":"","code":"Y <- rbzidegpd(1000, kappa = 2, sigma = 1, xi = 0.1,                thL = 5, thU = 5, thw = 0.2, pi0 = 0.3) mean(Y[,1] == 0 & Y[,2] == 0)  # approximately 0.3 #> [1] 0.713"},{"path":"https://sdwfrost.github.io/egpd/reference/rcpdegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from Compound Poisson-Discrete EGPD — rcpdegpd","title":"Random generation from Compound Poisson-Discrete EGPD — rcpdegpd","text":"Direct simulation: draw \\(N \\sim \\mathrm{Poisson}(\\lambda)\\), sum \\(N\\) ..d. Discrete-EGPD draws.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rcpdegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from Compound Poisson-Discrete EGPD — rcpdegpd","text":"","code":"rcpdegpd(n, lambda, prob = NA, kappa = NA, delta = NA, sigma, xi, type = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/rcpdegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from Compound Poisson-Discrete EGPD — rcpdegpd","text":"n number observations lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rcpdegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from Compound Poisson-Discrete EGPD — rcpdegpd","text":"integer vector length n","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/rcpegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from Compound Poisson-EGPD — rcpegpd","title":"Random generation from Compound Poisson-EGPD — rcpegpd","text":"Direct simulation: draw N ~ Poisson(lambda), sum N iid EGPD draws.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rcpegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from Compound Poisson-EGPD — rcpegpd","text":"","code":"rcpegpd(n, lambda, prob = NA, kappa = NA, delta = NA, sigma, xi, type = 1)"},{"path":"https://sdwfrost.github.io/egpd/reference/rcpegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from Compound Poisson-EGPD — rcpegpd","text":"n number observations lambda Poisson rate parameter (> 0) prob G-transformation parameter (type 6 ) kappa G-transformation parameter delta G-transformation parameter sigma GPD scale parameter (> 0) xi GPD shape parameter type integer 1-6 specifying G-transformation type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rcpegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from Compound Poisson-EGPD — rcpegpd","text":"numeric vector length n","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rdiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from the Discrete Extended GPD — rdiscegpd","title":"Random generation from the Discrete Extended GPD — rdiscegpd","text":"Random generation Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rdiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from the Discrete Extended GPD — rdiscegpd","text":"","code":"rdiscegpd(   n,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1,   unifsamp = NULL )"},{"path":"https://sdwfrost.github.io/egpd/reference/rdiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from the Discrete Extended GPD — rdiscegpd","text":"n number samples prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type unifsamp optional uniform samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rdiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from the Discrete Extended GPD — rdiscegpd","text":"Random non-negative integer samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/regpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from the Extended GPD — regpd","title":"Random generation from the Extended GPD — regpd","text":"Random generation Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/regpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from the Extended GPD — regpd","text":"","code":"regpd(   n,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1,   unifsamp = NULL )"},{"path":"https://sdwfrost.github.io/egpd/reference/regpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from the Extended GPD — regpd","text":"n number samples prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type unifsamp optional uniform samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/regpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from the Extended GPD — regpd","text":"Random samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rmdgpd.html","id":null,"dir":"Reference","previous_headings":"","what":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","title":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","text":"Generates random samples d-dimensional Multivariate Discrete Generalized Pareto Distribution (MDGPD) Aka, Kratz & Naveau (2025). Uses generator-based construction equicorrelated Poisson generator geometric maximum component. function pure R require Julia.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rmdgpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","text":"","code":"rmdgpd(n, sigma, xi, lambda, rho, d = 2L)"},{"path":"https://sdwfrost.github.io/egpd/reference/rmdgpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","text":"n integer; number observations generate. sigma positive numeric; GPD scale parameter (common across dimensions). xi non-negative numeric; GPD shape parameter. xi = 0 marginals reduce scaled geometric. lambda positive numeric; Poisson rate generator components. Controls spread dependence structure. rho numeric \\[0, 1); equicorrelation d-dimensional Poisson generator. Higher values give stronger positive dependence: rho -> 1 gives near-perfect dependence, rho = 0 gives weakest dependence given lambda. d integer >= 2; dimension multivariate distribution (default 2L).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rmdgpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","text":"n d integer matrix columns   Y1, Y2, ..., Yd.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rmdgpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","text":"construction follows Aka, Kratz & Naveau (2025), generalised dimension d: Generate d-dimensional equicorrelated Poisson generator     \\(T_j = X_j + Z\\) \\(Z \\sim Poisson(\\rho\\lambda)\\) (common)     \\(X_j \\sim Poisson((1-\\rho)\\lambda)\\) (independent),     \\(j = 1, \\ldots, d\\). component \\(\\), compute spectral difference     \\(\\Delta_i = T_i - \\max_{j \\neq } T_j\\). Generate \\(G \\sim Geometric(1 - e^{-1})\\), independently. Standard MDGPD: \\(N_i = G + \\min(\\Delta_i, 0)\\). Non-standard transform discrete GPD marginals:     \\(M_i = \\lfloor \\sigma (e^{\\xi \\max(N_i, 0)} - 1) / \\xi \\rfloor\\). parameter rho controls dependence strength: rho close 1, components tend equal. parameter lambda controls spread spectral differences. d = 2, spectral difference reduces \\(\\Delta = T_1 - T_2\\) construction matches bivariate case original paper. function experimental interface may change.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rmdgpd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","text":"Aka, S., Kratz, M., Naveau, P. (2025). Multivariate discrete generalized Pareto distributions: theory, simulation, applications dry spells. arXiv preprint arXiv:2506.19361.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/rmdgpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"\\[Experimental\\] Random generation from the multivariate MDGPD — rmdgpd","text":"","code":"# Bivariate (default) Y2 <- rmdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5) plot(jitter(Y2[,1]), jitter(Y2[,2]), pch = \".\", main = \"Bivariate MDGPD\")   # Trivariate Y3 <- rmdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5, d = 3) pairs(Y3 + runif(length(Y3), -0.3, 0.3), pch = \".\", main = \"Trivariate MDGPD\")"},{"path":"https://sdwfrost.github.io/egpd/reference/rqresid.html","id":null,"dir":"Reference","previous_headings":"","what":"Randomized Quantile Residuals — rqresid","title":"Randomized Quantile Residuals — rqresid","text":"Computes randomized quantile residuals (Dunn & Smyth, 1996)   discrete continuous EGPD models. discrete models, uniform   random variate drawn lower upper CDF bounds   observation transformed normal scale via   qnorm. continuous models, CDF value transformed   directly.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rqresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Randomized Quantile Residuals — rqresid","text":"","code":"rqresid(object, ...)  # S3 method for class 'egpd' rqresid(object, seed = NULL, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/rqresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Randomized Quantile Residuals — rqresid","text":"object fitted egpd object seed optional random seed reproducibility ... unused","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rqresid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Randomized Quantile Residuals — rqresid","text":"numeric vector randomized quantile residuals   standard normal scale. Values infinite replaced   NA.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rqresid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Randomized Quantile Residuals — rqresid","text":"well-specified model residuals approximately   standard normal. generic rqresid dispatches   rqresid.egpd method objects class \"egpd\". method supports EGPD families (\"egpd\", \"degpd\",   \"zidegpd\") model types (1–6).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rqresid.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Randomized Quantile Residuals — rqresid","text":"Dunn, P. K. Smyth, G. K. (1996). Randomized quantile residuals. Journal Computational Graphical Statistics, 5(3), 236–244.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/rqresid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Randomized Quantile Residuals — rqresid","text":"","code":"if (FALSE) { # \\dontrun{   set.seed(42)   dat <- data.frame(y = regpd(200, sigma = 1, xi = 0.2, kappa = 2, type = 1))   fit <- egpd(y ~ 1, data = dat, family = \"egpd\", egpd = list(m = 1))   r <- rqresid(fit, seed = 1)   qqnorm(r); qqline(r) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/rzidiscegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from the Zero-Inflated Discrete Extended GPD — rzidiscegpd","title":"Random generation from the Zero-Inflated Discrete Extended GPD — rzidiscegpd","text":"Random generation Zero-Inflated Discrete Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rzidiscegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from the Zero-Inflated Discrete Extended GPD — rzidiscegpd","text":"","code":"rzidiscegpd(   n,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1,   unifsamp = NULL )"},{"path":"https://sdwfrost.github.io/egpd/reference/rzidiscegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from the Zero-Inflated Discrete Extended GPD — rzidiscegpd","text":"n number samples pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type unifsamp optional uniform samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rzidiscegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from the Zero-Inflated Discrete Extended GPD — rzidiscegpd","text":"Random non-negative integer samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rziegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Random generation from the Zero-Inflated Extended GPD — rziegpd","title":"Random generation from the Zero-Inflated Extended GPD — rziegpd","text":"Random generation Zero-Inflated Extended GPD","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rziegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random generation from the Zero-Inflated Extended GPD — rziegpd","text":"","code":"rziegpd(   n,   pi = NA,   prob = NA,   kappa = NA,   delta = NA,   sigma = NA,   xi = NA,   type = 1 )"},{"path":"https://sdwfrost.github.io/egpd/reference/rziegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random generation from the Zero-Inflated Extended GPD — rziegpd","text":"n number samples pi zero-inflation probability prob mixing probability (type 6) kappa shape parameter G transformation delta shape parameter G transformation (types 4-6) sigma GPD scale parameter xi GPD shape parameter type integer 1-6 specifying G type","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rziegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random generation from the Zero-Inflated Extended GPD — rziegpd","text":"Random non-negative samples","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rzimdgpd.html","id":null,"dir":"Reference","previous_headings":"","what":"\\[Experimental\\] Random generation from the zero-inflated MDGPD — rzimdgpd","title":"\\[Experimental\\] Random generation from the zero-inflated MDGPD — rzimdgpd","text":"Generates random samples Zero-Inflated MDGPD (ZIMDGPD). probability pi0, row set zeros; otherwise, drawn rmdgpd.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rzimdgpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"\\[Experimental\\] Random generation from the zero-inflated MDGPD — rzimdgpd","text":"","code":"rzimdgpd(n, sigma, xi, lambda, rho, pi0, d = 2L)"},{"path":"https://sdwfrost.github.io/egpd/reference/rzimdgpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"\\[Experimental\\] Random generation from the zero-inflated MDGPD — rzimdgpd","text":"n integer; number observations generate. sigma positive numeric; GPD scale parameter (common across dimensions). xi non-negative numeric; GPD shape parameter. xi = 0 marginals reduce scaled geometric. lambda positive numeric; Poisson rate generator components. Controls spread dependence structure. rho numeric \\[0, 1); equicorrelation d-dimensional Poisson generator. Higher values give stronger positive dependence: rho -> 1 gives near-perfect dependence, rho = 0 gives weakest dependence given lambda. pi0 numeric (0, 1); joint zero-inflation probability. d integer >= 2; dimension multivariate distribution (default 2L).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rzimdgpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"\\[Experimental\\] Random generation from the zero-inflated MDGPD — rzimdgpd","text":"n d integer matrix columns   Y1, Y2, ..., Yd.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/rzimdgpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"\\[Experimental\\] Random generation from the zero-inflated MDGPD — rzimdgpd","text":"function experimental interface may change.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/rzimdgpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"\\[Experimental\\] Random generation from the zero-inflated MDGPD — rzimdgpd","text":"","code":"Y <- rzimdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5, pi0 = 0.3) mean(rowSums(Y) == 0)  # approximately 0.3 + natural zeros #> [1] 0.72  # Trivariate Y3 <- rzimdgpd(1000, sigma = 2, xi = 0.2, lambda = 1, rho = 0.5, pi0 = 0.3, d = 3)"},{"path":"https://sdwfrost.github.io/egpd/reference/seq_between.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a sequence between a range — seq_between","title":"Generate a sequence between a range — seq_between","text":"Generate sequence range","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/seq_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a sequence between a range — seq_between","text":"","code":"seq_between(x, length = NULL)"},{"path":"https://sdwfrost.github.io/egpd/reference/seq_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a sequence between a range — seq_between","text":"x 2-vector length integer","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/seq_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a sequence between a range — seq_between","text":"vector","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/simulate.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulations from a fitted egpd object — simulate.egpd","title":"Simulations from a fitted egpd object — simulate.egpd","text":"Simulations fitted egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/simulate.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulations from a fitted egpd object — simulate.egpd","text":"","code":"# S3 method for class 'egpd' simulate(   object,   nsim = 1000,   seed = NULL,   newdata,   type = \"link\",   probs = NULL,   threshold = 0,   marginal = TRUE,   ... )"},{"path":"https://sdwfrost.github.io/egpd/reference/simulate.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulations from a fitted egpd object — simulate.egpd","text":"object fitted egpd object nsim integer giving number simulations seed integer giving seed simulations newdata data frame type character string: \"link\" \"response\" probs scalar vector probabilities threshold scalar added simulations marginal logical: uncertainty integrate smoothing parameter uncertainty? ... additional arguments","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/simulate.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulations from a fitted egpd object — simulate.egpd","text":"Simulations parameters","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/summary.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for a fitted egpd object — summary.egpd","title":"Summary method for a fitted egpd object — summary.egpd","text":"Summary method fitted egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/summary.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for a fitted egpd object — summary.egpd","text":"","code":"# S3 method for class 'egpd' summary(object, ...)  # S3 method for class 'summary.egpd' print(x, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/summary.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for a fitted egpd object — summary.egpd","text":"object fitted egpd object ... used x summary.egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/summary.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for a fitted egpd object — summary.egpd","text":"summary.egpd object","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_bdegpd.html","id":null,"dir":"Reference","previous_headings":"","what":"\\[Experimental\\] Train a neural estimator for bivariate discrete EGPD — train_bdegpd","title":"\\[Experimental\\] Train a neural estimator for bivariate discrete EGPD — train_bdegpd","text":"Trains Neural Posterior Estimator (NPE) /Neural Bayesian Estimator (NBE) networks bivariate discrete EGPD inference (BDEGPD BZIDEGPD). Requires Julia (>= 1.11) NeuralEstimators.jl Flux.jl installed, plus R packages JuliaConnectoR NeuralEstimators.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_bdegpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"\\[Experimental\\] Train a neural estimator for bivariate discrete EGPD — train_bdegpd","text":"","code":"train_bdegpd(   savepath = \"inst/models\",   family = c(\"bdegpd\", \"bzidegpd\"),   estimator = c(\"both\", \"npe\", \"nbe\"),   K = NULL,   m = NULL,   epochs = NULL,   stopping_epochs = 10,   quick = FALSE,   mc.cores = parallel::detectCores() - 1L,   seed = 1L,   verbose = TRUE )"},{"path":"https://sdwfrost.github.io/egpd/reference/train_bdegpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"\\[Experimental\\] Train a neural estimator for bivariate discrete EGPD — train_bdegpd","text":"savepath character; directory save trained model files (.bson). Created exist. family character; \"bdegpd\" (6 parameters) \"bzidegpd\" (7 parameters, adds pi0). estimator character; estimator(s) train: \"\" (default), \"npe\", \"nbe\". K integer; number training parameter sets sample prior. m integer vector; range sample sizes simulated datasets. epochs integer; maximum number training epochs. stopping_epochs integer; early stopping patience. quick logical; TRUE, uses reduced training settings. mc.cores integer; number parallel cores data simulation. seed integer NULL; random seed reproducibility. verbose logical; TRUE, print progress messages.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_bdegpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"\\[Experimental\\] Train a neural estimator for bivariate discrete EGPD — train_bdegpd","text":"named list file paths saved .bson model files (invisible).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_bdegpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"\\[Experimental\\] Train a neural estimator for bivariate discrete EGPD — train_bdegpd","text":"function experimental interface may change. training procedure mirrors train_begpd uses rbdegpd rbzidegpd data simulation. BZIDEGPD, seventh parameter (pi0) uses logit transform.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/train_bdegpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"\\[Experimental\\] Train a neural estimator for bivariate discrete EGPD — train_bdegpd","text":"","code":"if (FALSE) { # \\dontrun{ paths <- train_bdegpd(savepath = tempdir(), family = \"bdegpd\", quick = TRUE) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/train_begpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Train a neural estimator for bivariate BEGPD — train_begpd","title":"Train a neural estimator for bivariate BEGPD — train_begpd","text":"Trains Neural Posterior Estimator (NPE) /Neural Bayesian Estimator (NBE) networks bivariate BEGPD inference. Requires Julia (>= 1.11) NeuralEstimators.jl Flux.jl installed, plus R packages JuliaConnectoR NeuralEstimators.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_begpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Train a neural estimator for bivariate BEGPD — train_begpd","text":"","code":"train_begpd(   savepath = \"inst/models\",   estimator = c(\"both\", \"npe\", \"nbe\"),   K = NULL,   m = NULL,   epochs = NULL,   stopping_epochs = 10,   quick = FALSE,   mc.cores = parallel::detectCores() - 1L,   seed = 1L,   verbose = TRUE )"},{"path":"https://sdwfrost.github.io/egpd/reference/train_begpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Train a neural estimator for bivariate BEGPD — train_begpd","text":"savepath character; directory save trained model files (.bson). Created exist. estimator character; estimator(s) train: \"\" (default), \"npe\", \"nbe\". K integer; number training parameter sets sample prior. m integer vector; range sample sizes simulated datasets (e.g., 1000:4000). epochs integer; maximum number training epochs. stopping_epochs integer; early stopping patience (epochs without improvement). quick logical; TRUE, uses reduced training settings quick testing (K=20000, m=500:1000, epochs=10). mc.cores integer; number parallel cores data simulation. Forced 1 Windows. seed integer NULL; random seed reproducibility. verbose logical; TRUE, print progress messages.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_begpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Train a neural estimator for bivariate BEGPD — train_begpd","text":"named list file paths saved .bson model files (invisible).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_begpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Train a neural estimator for bivariate BEGPD — train_begpd","text":"training procedure: Samples parameters uniform priors. Simulates bivariate BEGPD data using rbegpd. Applies variance-stabilizing (signed log) log parameter transforms. Trains neural network(s) using NeuralEstimators::train(). Saves trained states .bson files.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_begpd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Train a neural estimator for bivariate BEGPD — train_begpd","text":"Sainsbury-Dale, M., Zammit-Mangion, ., Huser, R. (2024). Likelihood-free parameter estimation neural Bayes estimators. American Statistician, 78(1), 1–14.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_begpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Train a neural estimator for bivariate BEGPD — train_begpd","text":"","code":"if (FALSE) { # \\dontrun{ paths <- train_begpd(savepath = tempdir(), quick = TRUE) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/train_mdgpd.html","id":null,"dir":"Reference","previous_headings":"","what":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","title":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","text":"Trains Neural Posterior Estimator (NPE) /Neural Bayesian Estimator (NBE) networks MDGPD inference. Based Aka, Kratz & Naveau (2025) framework. Requires Julia (>= 1.11) NeuralEstimators.jl Flux.jl installed, plus R packages JuliaConnectoR NeuralEstimators.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_mdgpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","text":"","code":"train_mdgpd(   savepath = \"inst/models\",   family = c(\"mdgpd\", \"zimdgpd\"),   data_dim = 2L,   estimator = c(\"both\", \"npe\", \"nbe\"),   K = NULL,   m = NULL,   epochs = NULL,   stopping_epochs = 10,   quick = FALSE,   mc.cores = parallel::detectCores() - 1L,   seed = 1L,   verbose = TRUE )"},{"path":"https://sdwfrost.github.io/egpd/reference/train_mdgpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","text":"savepath character; directory save trained model files (.bson). Created exist. family character; \"mdgpd\" (4 parameters) \"zimdgpd\" (5 parameters, adds pi0). data_dim integer >= 2; dimension multivariate data (default 2L). separate neural network trained data dimension. estimator character; estimator(s) train: \"\" (default), \"npe\", \"nbe\". K integer; number training parameter sets sample prior. m integer vector; range sample sizes simulated datasets. epochs integer; maximum number training epochs. stopping_epochs integer; early stopping patience. quick logical; TRUE, uses reduced training settings. mc.cores integer; number parallel cores data simulation. seed integer NULL; random seed reproducibility. verbose logical; TRUE, print progress messages.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_mdgpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","text":"named list file paths saved .bson model files (invisible).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_mdgpd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","text":"function experimental interface may change. training procedure: Samples parameters uniform priors:     sigma ~ U(0.1, 10), xi ~ U(0.01, 0.5),     lambda ~ U(0.01, 5), rho ~ U(0.01, 0.99),     ZIMDGPD: pi0 ~ U(0.01, 0.9). Simulates data_dim-dimensional MDGPD data using     rmdgpd rzimdgpd. Applies variance-stabilizing (signed log) parameter transforms     (log sigma/xi/lambda, logit rho pi0). Trains neural network(s). Saves trained states .bson files. Model files named dimension-specific prefix (e.g., MDGPD_NPE.bson data_dim = 2, MDGPD_3D_NPE.bson data_dim = 3).","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/train_mdgpd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","text":"Aka, S., Kratz, M., Naveau, P. (2025). Multivariate discrete generalized Pareto distributions: theory, simulation, applications dry spells. arXiv preprint arXiv:2506.19361.","code":""},{"path":[]},{"path":"https://sdwfrost.github.io/egpd/reference/train_mdgpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"\\[Experimental\\] Train a neural estimator for MDGPD — train_mdgpd","text":"","code":"if (FALSE) { # \\dontrun{ # 2D (default) paths <- train_mdgpd(savepath = tempdir(), family = \"mdgpd\", quick = TRUE) # 3D paths3 <- train_mdgpd(savepath = tempdir(), family = \"mdgpd\",                        data_dim = 3L, quick = TRUE) } # }"},{"path":"https://sdwfrost.github.io/egpd/reference/vcov.egpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance-covariance matrix for egpd fits — vcov.egpd","title":"Variance-covariance matrix for egpd fits — vcov.egpd","text":"Variance-covariance matrix egpd fits","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/vcov.egpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance-covariance matrix for egpd fits — vcov.egpd","text":"","code":"# S3 method for class 'egpd' vcov(object, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/vcov.egpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance-covariance matrix for egpd fits — vcov.egpd","text":"object fitted egpd object. ... used.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/vcov.egpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variance-covariance matrix for egpd fits — vcov.egpd","text":"variance-covariance matrix object$Vp row column   names matching coefficient names.","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/zidegpd_bamlss.html","id":null,"dir":"Reference","previous_headings":"","what":"bamlss family for zero-inflated discrete EGPD (ZIDEGPD) — zidegpd_bamlss","title":"bamlss family for zero-inflated discrete EGPD (ZIDEGPD) — zidegpd_bamlss","text":"Creates family.bamlss object fitting zero-inflated discrete Extended Generalized Pareto Distribution models bamlss().","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/zidegpd_bamlss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bamlss family for zero-inflated discrete EGPD (ZIDEGPD) — zidegpd_bamlss","text":"","code":"zidegpd_bamlss(m = 1, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/zidegpd_bamlss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bamlss family for zero-inflated discrete EGPD (ZIDEGPD) — zidegpd_bamlss","text":"m integer 1–4 selecting G transformation (see egpd_bamlss details) ... arguments passed link specification","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/zidegpd_bamlss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bamlss family for zero-inflated discrete EGPD (ZIDEGPD) — zidegpd_bamlss","text":"object class family.bamlss","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ziegpd_bamlss.html","id":null,"dir":"Reference","previous_headings":"","what":"bamlss family for zero-inflated continuous EGPD — ziegpd_bamlss","title":"bamlss family for zero-inflated continuous EGPD — ziegpd_bamlss","text":"Creates family.bamlss object fitting continuous zero-inflated Extended Generalized Pareto Distribution models bamlss().","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ziegpd_bamlss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bamlss family for zero-inflated continuous EGPD — ziegpd_bamlss","text":"","code":"ziegpd_bamlss(m = 1, ...)"},{"path":"https://sdwfrost.github.io/egpd/reference/ziegpd_bamlss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bamlss family for zero-inflated continuous EGPD — ziegpd_bamlss","text":"m integer 1–4 selecting G transformation (see egpd_bamlss details) ... arguments passed link specification","code":""},{"path":"https://sdwfrost.github.io/egpd/reference/ziegpd_bamlss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bamlss family for zero-inflated continuous EGPD — ziegpd_bamlss","text":"object class family.bamlss","code":""}]
